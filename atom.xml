<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全栈之路</title>
  
  <subtitle>田_田的博客</subtitle>
  <link href="https://wangzitian0.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangzitian0.github.io/"/>
  <updated>2020-09-30T04:59:07.880Z</updated>
  <id>https://wangzitian0.github.io/</id>
  
  <author>
    <name>田_田</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跳槽前前后后思考的几个问题</title>
    <link href="https://wangzitian0.github.io/2018/03/17/Some-thinking-those-days/"/>
    <id>https://wangzitian0.github.io/2018/03/17/Some-thinking-those-days/</id>
    <published>2018-03-17T12:26:00.000Z</published>
    <updated>2020-09-30T04:59:07.880Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下这两个月的思考</p><a id="more"></a><h2 id="技术的边界是什么？"><a href="#技术的边界是什么？" class="headerlink" title="技术的边界是什么？"></a>技术的边界是什么？</h2><p>凯文·凯利认为，技术是六种已知的生命形态——植物、动物、原生生物、真菌、原细菌、真细菌——之外的第七种生命形态，因为技术和生命的演化路径惊人地相似。</p><p>技术的进步速度，远远超过人们的想象。我们生活在一个机器世界里，但又不懂这些机器，这是一种怎样的处境？现在的模式是，我们花钱购买服务，让懂的人或公司来操作和维护机器。但是，如果有一天，你请不到人，或者机器索性坏了，你不就困在了机器组成的监狱里了吗？就比如上了年纪的人不会用打车软件就真的打不到车，有些人无法理解为什么淘宝账号不能登陆京东。</p><p>我们的社会已经如此依赖技术，为了适应外界，你至少要知道如何使用它。糟糕的是，技术已经变得如此复杂，没有人能够全部搞懂。系统越来越复杂，分工越来越细，一个人已经不可能从头到尾掌握整个系统了。根本无法预测和判断，某个领域的技术发展会引起整个系统怎样的变化。也不可能去制定五年规划或十年规划…在科技行业，整体的准确安排和控制，不存在的。</p><p>技术已经到了这样一个地步，我们走一步看一步，谁也不知道五年十年后，技术会突破到什么程度。</p><h2 id="未来10年，哪些东西会变？"><a href="#未来10年，哪些东西会变？" class="headerlink" title="未来10年，哪些东西会变？"></a>未来10年，哪些东西会变？</h2><pre><code>I very frequently get the question: &#39;What&#39;s going to change in the next 10 years?&#39; And that is a very interesting question; it&#39;s a very common one. I almost never get the question: &#39;What&#39;s not going to change in the next 10 years?&#39; And I submit to you that that second question is actually the more important of the two — because you can build a business strategy around the things that are stable in time.</code></pre><p>亚马逊CEO贝索斯曾经围绕“变还是不变”这一问题有过很精妙的概括：“我非常频繁地被问到这样的问题，在未来10年里将会发生什么变化，这是一个非常有趣的问题，也是很常见的问题。但我几乎从来没有被问过相反的问题：在未来十年中什么不会发生变化?</p><p>第二个问题实际上是更加重要的，因为你可以围绕未来一段时间不会变化的东西建立战略和壁垒。”</p><p>我们把精力放到这些不变的事物上，我们知道现在在上面投入的精力，会在10年里和10年后持续不断让我们获益。当你发现了一个对的事情，甚至10年后依然如一，那么它就值得你将大量的精力倾注于此。</p><p>我倒是想写写十年之内不会怎么变的东西：</p><h4 id="企业家精神"><a href="#企业家精神" class="headerlink" title="企业家精神"></a>企业家精神</h4><p>这三个点我几年前在总结里就写过，还是这三个点，但这两年有新的理解：</p><ul><li>拥抱新技术。站着巨人的肩膀上，先决条件成熟了，产业革命自然而然就来了。而且，产业革命之所以能被称作革命，不是因为它是渐进式的，往往当你意识到革命来临的时候，革命已经结束了。</li><li>召集好团队。做人做事有好品格是最符合长期利益的选择，不诚无以聚人心，不公无以令天下。有些事情走点歪路，看上去短期收益了，实际上是损伤长期利益的。</li><li>有巨大的野心。人一定要有一点赌性，不急于享受，乐于把自己的收成投入再生产。格局决定了一个人能走多远。还有就是在激进和保守之间，适当的选择激进往往会发展更快。</li></ul><h4 id="技术向善"><a href="#技术向善" class="headerlink" title="技术向善"></a>技术向善</h4><p>近期刷了黑镜第四季，构建了大量未来人们由于科技发展的世界观，人们因此获利也因此被科技绑架。因为技术的副作用就不应该发展技术了么？说到底，技术是人类用来解决族群面临的共同挑战，改变自身命运的工具，就其本质来说，技术的价值观应该是向善的。如果你有机会留下一些东西给未来的人们，你为什么要留一些垃圾给他们呢？为什么不留一些更好的东西？</p><h4 id="经济常识"><a href="#经济常识" class="headerlink" title="经济常识"></a>经济常识</h4><p>能做到不人云亦云，有常识和自己的判断力的人并不是那么多。</p><p>吴晓波近期出了本新书《水大鱼大》，几乎梳理了近十年混出名堂所有的公司，有正面的例子也有负面的。</p><p>如果说中国的水很好，为什么那么多的公司非正常死亡？为什么那么多正经做事的人被假冒伪劣驱逐？</p><p>如果是水不好，为什么能成长出腾讯阿里这样世界领先的公司？为什么500强公司超过100家？</p><p>只是觉得，永远不要抱怨环境，也不要抱怨制度，学会自己适应，学会发掘别人看不到的东西。</p><p>另外，从加入WTO一直到现在，各国以邻为壑，以民为壑的印钞周期已经几乎结束，中国官方2017的M2总量是8.3%，再跌就有可能出现通缩了，持续了十几年的量化宽松局面还真不一定会维持。<br>用过去的经济形式来判断现在的各种金融品，并且得出一系列乱七八糟的结论勇加杠杆，只能敬你是条24K真汉子咯。</p><p>O2O也好，其他的子行业也好，非量化宽松周期的无条件烧钱竞争会越来越少。要么演变成巨头的代理战（入股获得的流量获客成本低于广告成本的时候，巨头倾向于入股而不是打广告）。要么有盈利的能力，本身有很快的增长。</p><h4 id="自己做选择的能力"><a href="#自己做选择的能力" class="headerlink" title="自己做选择的能力"></a>自己做选择的能力</h4><p>自己做的选择，就算是吃屎，一般来说也会吃干净。吃屎倒不是什么坏事，老是抱怨别人给你喂屎就说不过去了。</p><p>有些事情只能自己对自己负责，有很多同龄人喜欢把一些大事的决定权交给父母。但中国经济增长太快了，每隔七八年就翻倍，隔个二十年，翻个七八倍的时候，社会运行模式就不一样了，导致很多上一辈人的认知和人生经验不一定对我们这代人有指导意义。</p><p>从做事的层面上来说，两个人做同样事情，晚三年的这人个影响力一般不如早三年的，因为早三年那个人正值壮年，干得好自然不会退休。</p><h2 id="我对行业的思考"><a href="#我对行业的思考" class="headerlink" title="我对行业的思考"></a>我对行业的思考</h2><h4 id="5G"><a href="#5G" class="headerlink" title="5G"></a>5G</h4><p>大学读的是北邮网络工程，一直关注通信和计算机两个行业的发展。</p><p>一个大的点是5G，三套协议三张网，eMBB，mMTC，URLLC。分别对应高速率，大容量，低延时。</p><ul><li>第一张网对应的速率可以到10Gbps，和现在的WiFi一个水平，ar、vr、8K视频、3D直播等等都有可能全面普及</li><li>第二张网对应极低的功耗和海量设备接入，同一个基站4G时代可能只能接入K级别的设备，但是mMTC支持的设备接入数量是M级别。智慧电网、物流、农业、家居等等都有可能不再是现在大家理解的样子。</li><li>第三张网是低延时网络，王者荣耀之类的游戏建立的前提是网络延时在100ms内，但是这张网应该会把延时下降到10ms级别，可以用于远程医疗，自动驾驶，工业控制等。</li></ul><p>三张网络加起来，想象空间之大，远不是现在的4G所能比拟的，目前看起来2020年之前就会开始组城市级别的网。腾讯阿里市值成为世界前十，小巨头TMD的成长，和4G的快速爆铺有关，又会有哪些公司会伴随5G成长起来呢？不得而知。</p><h4 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h4><p>至于人工智能，之前看了李开复的《人工智能》，里面给了一张图，对未来的预判让我印象很深刻：</p><p><img src="/images/ai.jpg" alt="ai.jpg"><br>个人</p><ul><li>非结构化数据的模式识别、感知，尤其是cv，近几年的发展真的是超出想象。</li><li>始终觉得很多视觉公司都以安防为切入点特别奇怪。海康威视和大华在前面挡着，市场盘子就那么大，增长取决于gov的投入，增长很容易到瓶颈。</li><li>人工智能整个行业会是一种非常奇怪的业态，收入要么为0，要么收入爆炸，不太存在中间态or线性增长。选择这个行业需要有一点赌性。</li></ul><h4 id="流量生意接近枯竭"><a href="#流量生意接近枯竭" class="headerlink" title="流量生意接近枯竭"></a>流量生意接近枯竭</h4><ul><li>微信的用户数已经到达10亿，剩下的人几乎都是难以使用智能机的人群。</li><li>至少接下来两到三年，在5G普及之前，流量生意会被几家巨头以各种不同的形式垄断。</li><li>获客成本从之前的几毛到现在的大几十，创业公司不太可能靠C端流量来成长。要么像腾讯头条这样自己给自己倒流，要么砸钱打广告，要么等死。</li><li>C端创业公司的生存空间被挤压到狭缝之中。B端生意会好做一些，成为独角兽比较容易，但是再往上很容易触及天花板。</li><li>某些O2O公司，看上去成长速度非常快。但是技术人员加进去之后能发挥多么重要的作用，换种问法就是开掉一个程序猿和开掉一个运营人员，老板会更心疼谁？对于这一点，我始终持保留意见。</li><li>这种格局只有等物联网、区块链之类的分布式场景出现才有可能打破。</li></ul><h4 id="比特币-区块链"><a href="#比特币-区块链" class="headerlink" title="比特币/区块链"></a>比特币/区块链</h4><p>我的观点是从来没有一个天然通缩的东西能成为货币或者等值物，通缩的东西人们一定会倾向于收藏而不是流通，一个不流通的东西也配称为币？</p><p>当然，只要黑产行业承认XX币，长线来看，由于通缩属性的存在，XX币会可能涨价。又或者像某政府发行了石油币，用政府信用作担保发币。</p><p>除此之外我不看好各种乱发的币。</p><p>如果硬件设备和网络环境没有实质性的突破或者改变，也不看好区块链这件事情。</p><h4 id="高端制造国产化"><a href="#高端制造国产化" class="headerlink" title="高端制造国产化"></a>高端制造国产化</h4><p>中国的制造特点就是一般不做第一个吃螃蟹的人，一旦有人验证模式、方法可行了，再通过自己的体量和规模赶超对手。吃别人的饭，让别人无饭可吃。同样价钱的东西，外国人会亏损，勤劳善良勇敢的中国人去造就能赚钱，这是一个非常神奇且牛逼的事情，如果不理解这件事，就很难理解很多中国公司的崛起。</p><p>有段时间在知乎看到一个关于答案，然后去1688看了一下，搜搜日常用品（比如毛巾）。从此我知道啥叫产能过剩，利润太薄了。但是，新的增长正在崛起。从大飞机总成到航用轮胎，从手机集成到面板芯片，从路桥隧道到模块化建筑，从航母制造到节气阀，很多东西由于卖方不多，中国拥有定价权。</p><p>中国人的目标是星辰大海，但凡我们能造的东西，一定会被我们变成白菜价。</p><h4 id="中低端制造业IP化"><a href="#中低端制造业IP化" class="headerlink" title="中低端制造业IP化"></a>中低端制造业IP化</h4><p>典型如三只松鼠、小米生态链和伏牛堂，分别代表123产业。很多人觉得实体生意难做。我看并不是，只是你的实体生意难做，做得好的人能创造更好更大更赚钱的品牌。趋势大致如下：</p><ul><li>单品爆款，通过均摊降低研发、模具、营销等固定成本</li><li>中端线路。低端线路1分钱1分货，高端线路是10分钱10分货，而中端线路是3分钱8分货。</li><li>品控严格，无论何时何地都是一个味道、一个样子、一个体验。</li><li>形成印象，只要选了这个牌子，不会太差。IP形成。</li></ul><h4 id="汽车行业"><a href="#汽车行业" class="headerlink" title="汽车行业"></a>汽车行业</h4><p>汽车行业是典型的高端制造，汇集上面所有的点，接下来十年一定是起飞的十年。</p><p>汽车的零部件，总成预装组件，车辆总成，车辆设计等等都会有完全自主产权的玩家出现。涉及的产业链大几十个。</p><p>伴随着电动车的发展和无线通信的发展，车的智能电气化自然而然，将来的“车”一定不是你现在理解的车，城市的格局也会随之改变。</p><p>无人驾驶是人工智能之母，一旦一种技术能在无人车上使用，一定能找出更多的非车场景使用。数据信息的采集闭环模式是通用的。</p><h4 id="生物医药信息学"><a href="#生物医药信息学" class="headerlink" title="生物医药信息学"></a>生物医药信息学</h4><p>改变现有医学框架的人可能不会是学医的或者是学生物的，有可能是写代码的。</p><p>麻省理工每年都会有十大科技评论，往往评论上的东西需要五到十年的落地期。近几年，生物医药、基因工程相关的技术革新越来越多。</p><p>FDA向来以审批医药严格出名，而不久前第一次批准允许基因工程治病。（病毒T-VEC 来治疗皮肤黑色素瘤的新疗法）至少在我的认知里面，FDA通过的药比绝大多数副作用不明的中成药靠谱。</p><p>未来世界可能不再“王侯将相，宁有种乎？”，而是“王侯将相，真的有种”。治病、抗衰老，极有可能变成有钱人的专利。</p><h2 id="做技术的人应不应该大方谈论钱？"><a href="#做技术的人应不应该大方谈论钱？" class="headerlink" title="做技术的人应不应该大方谈论钱？"></a>做技术的人应不应该大方谈论钱？</h2><p>有人用“我们想要一辆会飞的汽车，得到的却是 140 个字符”来讽刺现在的科技发展，前者没赚到多少钱，后者可能发财了。<br>可是我觉得，而是没有这140 个字符，飞行汽车只会更晚到来。</p><p>假设这世界上只有100000个人类，那今天有能力研究飞行汽车的，不会超过10个人。但真正在搞飞行汽车的，只有9个人。为什么？10个人里面最聪明的那1个人，去研究宇宙飞船了。</p><p>这群人在任何时代都只有这点规模，在18世纪研究通信的也是这9个人，在19世纪研究电气的也就是这9个人，60年代研究操作系统的是这9个人，70年代研究互联网的也是这9个人，90年代研究分布式系统的是这9个人，00年代研究深度学习的也是还是9个人。</p><p>等待总是很漫长，那99990人里面相对比较聪明的100人，站着10个人的肩膀上，在等待飞行汽车的过程中搞出了摩托罗拉，通用，微软，谷歌，抖音，吃鸡，让剩下的99890个人在等待飞行汽车的时间里有事可做。</p><p>这99890个人里面又有些握有财富的人，大概1000人，他们自己无法发明出twitter，更没本事鼓捣出飞行汽车，但是他们觉得可以给这些东西提供自己的帮助，让twitter尽快的普及，让飞行汽车能早点到来，顺便自己也发笔财。于是，产生了一个东西叫资本市场。</p><p>现在问题来了。</p><p>这1000个人因为100个人的努力发财了，那100人更是发了大财。有些人觉得那9个搞飞行汽车的也会被吸引去搞twitter和做金融，这下飞行汽车更没指望了，对么？</p><p>我觉得不会这样，也许那9个人里会有那么4～5个人，投身100人去搞互联网，甚至随了那1000人去搞金融。<br>但是，这个过程社会资源更多的流向了这100个人，只要这100人里有人那么几个愿意去投资飞行汽车团队，那么飞行汽车项目可以拿到比过去多百倍千倍的资金。</p><p>这一切，在过去是难以想象的，这是一个绝好的时代。也许我们离飞行汽车依然很遥远，但已经比任何时代要更近了。所以，大胆的谈论吧，市场经济就要用市场经济的方式来做技术。</p><p>不过，我觉得更值得大家关心的是那位投身宇宙飞船的朋友，会混得怎么样？</p><h2 id="END-当然是内推了"><a href="#END-当然是内推了" class="headerlink" title="END 当然是内推了"></a>END 当然是内推了</h2><p>造不了飞行汽车的来造无人车吧，pony.ai正在招人，我直接贴几天前发的帖子。</p><p>“Pony AI 小马智行成立于2016年底，致力于构建完整的L4/5级自动驾驶方案。</p><p>公司创立之初就获得了红杉中国和 IDG 资本的天使轮投资，并于2018年1月宣布完成由晨兴资本和君联资本领投，红杉中国、IDG等多家机构参与的1.12亿美元A轮融资。</p><p>CEO James Peng 彭军：前百度首席架构师，曾全面负责百度无人车的技术方向；还曾负责互联网变现技术、大数据和基础架构等。本科毕业于清华大学，博士毕业于斯坦福大学。</p><p>CTO 楼天城：ACRush、人称“楼教主”的编程第一人。连续十年 TopCoder 中国排名第一，两次获得 Google 全球编程挑战赛冠军。前百度无人车主任架构师，百度最年轻的 T10 工程师。曾参与 Google 无人车研发。本科与博士均毕业于清华大学。”</p><p>公司长期招聘研发工程师，只要心气正&amp;&amp;码力强&amp;&amp;兴趣浓，对于过往的经历没有太多条条框框，其他的事情都好商量，加州湾区、北京海淀和广州南沙设有三个研发中心，你可以考虑身份/签证/户口/生活节奏/美食/气候/对象（if object!=null）等问题之后自己选呆哪。</p><p>面试难度和国内一线互联网公司差不多，不会变态但是也不会简单，基础知识为主&amp;&amp;考察编码能力&amp;&amp;肯定不会问一点手指就能搜到的概念。（如果你在某些方面有专长，公司一定能找出和你谈笑风生的人，公司有一半的人背景∈{noi金、ioi、acm wf、acm区域赛金、姚班、在顶会灌水的博士}，有兴趣的各位不妨来试试：）</p><p>此外可以去微信公众号 pony_ai 了解更多信息，欢迎大家投简历到 <a href="mailto:&#x7a;&#x69;&#x74;&#105;&#x61;&#x6e;&#64;&#x70;&#x6f;&#x6e;&#121;&#x2e;&#x61;&#105;">&#x7a;&#x69;&#x74;&#105;&#x61;&#x6e;&#64;&#x70;&#x6f;&#x6e;&#121;&#x2e;&#x61;&#105;</a> ，也欢迎加我微信聊找工作、面试、互联网八卦 wzt_000 ，鄙人校招/社招拿过BAT头条小米微软宜信领英等加起来大概十个offer，说不定可以提供一些不一样的视角。</p><p><a href="https://campus.pony.ai/">Pony的JD页</a></p><p><a href="http://www.ocn.com.cn/touzi/chanye/201802/imsif26090439.shtml">关于无人驾驶行业万亿市场</a></p><p><a href="https://wangzitian0.github.io/2017/12/23/Autopilot-tech/">无人车技术的基本介绍</a></p><p>来来来，简历砸过来～</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下这两个月的思考&lt;/p&gt;</summary>
    
    
    
    
    <category term="Thinkings" scheme="https://wangzitian0.github.io/tags/Thinkings/"/>
    
  </entry>
  
  <entry>
    <title>CheatSheet and Tools</title>
    <link href="https://wangzitian0.github.io/2018/03/14/Some-cheat-sheet/"/>
    <id>https://wangzitian0.github.io/2018/03/14/Some-cheat-sheet/</id>
    <published>2018-03-14T11:53:42.000Z</published>
    <updated>2020-09-30T04:59:07.880Z</updated>
    
    <content type="html"><![CDATA[<p>把见过的比较好的CheatSheet还有开源的傻瓜工具集都记录下来，打印出来提高工作效率，我会持续更新这批文章。</p><a id="more"></a><h2 id="CheatSheet"><a href="#CheatSheet" class="headerlink" title="CheatSheet"></a>CheatSheet</h2><p><a href="https://www.cheatography.com/richardjh/cheat-sheets/ubuntu-unity/pdf/">Ubuntu</a></p><p><a href="https://www.cheatography.com/joel/cheat-sheets/ohmyzsh-git-plugin/pdf/">Oh-My-ZSH-git</a></p><p><a href="https://www.cheatography.com/davechild/cheat-sheets/linux-command-line/pdf/">Linux Command Line</a></p><p><a href="https://www.cheatography.com/davechild/cheat-sheets/regular-expressions/pdf/">Regex</a></p><p><a href="https://foxutech.com/vim-cheat-sheet/">VIM</a></p><p><a href="http://blog.csdn.net/voidccc/article/details/37599203">Google C++ Code Style</a></p><p><a href="https://steve-parker.org/sh/cheatsheet.pdf">Shell Script</a></p><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p><a href="https://github.com/amix/vimrc">The Ultimate vimrc</a></p><p><a href="https://github.com/robbyrussell/oh-my-zsh">Oh My Zsh</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;把见过的比较好的CheatSheet还有开源的傻瓜工具集都记录下来，打印出来提高工作效率，我会持续更新这批文章。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>调整博客结构 + 文档索引</title>
    <link href="https://wangzitian0.github.io/2018/03/10/Index-of-JS-and-Web/"/>
    <id>https://wangzitian0.github.io/2018/03/10/Index-of-JS-and-Web/</id>
    <published>2018-03-10T14:07:14.000Z</published>
    <updated>2020-09-30T04:59:07.879Z</updated>
    
    <content type="html"><![CDATA[<p>把之前翻译的各种文档降权，并且把发布时间统一调早到2013年，外加之前<a href="https://github.com/gothinkster/golang-gin-realworld-example-app">golang-gin-realworld-example-app</a>的建站手记。<br>这样保障archive的前面是高质量的原创文章。</p><a id="more"></a><h2 id="Golang-Gin-从零到一建站"><a href="#Golang-Gin-从零到一建站" class="headerlink" title="Golang Gin 从零到一建站"></a>Golang Gin 从零到一建站</h2><p><a href="/2013/06/29/zero-to-one-1/">从零到一建站（1）</a></p><p><a href="/2013/07/12/zero-to-one-2/">从零到一建站（2）</a></p><p><a href="/2013/07/26/zero-to-one-3/">从零到一建站（3）</a></p><p><a href="/2013/07/26/zero-to-one-4/">从零到一建站（4）</a></p><h2 id="Airbnb-CSS-SASS-Style-Guide"><a href="#Airbnb-CSS-SASS-Style-Guide" class="headerlink" title="Airbnb CSS / SASS Style Guide"></a>Airbnb CSS / SASS Style Guide</h2><p><a href="/2013/10/26/Airbnb-CSS-SASS-Style-Guide/">Airbnb CSS / SASS Style Guide</a></p><p><a href="/2013/07/28/Airbnb-JavaScript-Style-Guide/">Airbnb-JavaScript-Style-Guide (1)</a></p><p><a href="/2013/08/08/Airbnb-JavaScript-Style-Guide-2/">Airbnb-JavaScript-Style-Guide (2)</a></p><p><a href="/2013/08/08/Airbnb-JavaScript-Style-Guide-3/">Airbnb-JavaScript-Style-Guide (3)</a></p><h2 id="Ember-Cli的文档翻译"><a href="#Ember-Cli的文档翻译" class="headerlink" title="Ember Cli的文档翻译"></a>Ember Cli的文档翻译</h2><p><a href="/2013/11/07/Embercli1/">Embercli 文档（1）：开始</a></p><p><a href="/2013/11/09/Embercli2/">Embercli-文档（2）：模块、解释器、命名惯例</a></p><p><a href="/2013/11/09/Embercli3/">Embercli 文档（3）：Ember Data &amp; 测试</a></p><p><a href="/2013/11/13/Embercli4/">Embercli-文档（4）：资源编译-依赖管理/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;把之前翻译的各种文档降权，并且把发布时间统一调早到2013年，外加之前&lt;a href=&quot;https://github.com/gothinkster/golang-gin-realworld-example-app&quot;&gt;golang-gin-realworld-example-app&lt;/a&gt;的建站手记。&lt;br&gt;这样保障archive的前面是高质量的原创文章。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>无人驾驶技术简介</title>
    <link href="https://wangzitian0.github.io/2017/12/23/Autopilot-tech/"/>
    <id>https://wangzitian0.github.io/2017/12/23/Autopilot-tech/</id>
    <published>2017-12-23T15:52:26.000Z</published>
    <updated>2020-09-30T04:59:07.876Z</updated>
    
    <content type="html"><![CDATA[<p>稍微总结一下近期看的无人车相关的资料。</p><a id="more"></a><p>巨巨任少卿看完之后的几点勘误：<br>“双目感知用于 3D 建模，人眼开车本质也是视觉” 人开车用的是单目视觉<br>“KITTI 数据集包括6小时 1M 张 140w 像素的彩色图片，目前业内顶尖水平的平均处理时间约需要0.3s” 30fps是必须的<br>”寒武纪！！还是发了几个处理器，名字有点傻傻的：DianNao，DaDianNao，PuDianNao，ShiDianNao”是他们paper的名字:)</p><h2 id="自动驾驶分级简介"><a href="#自动驾驶分级简介" class="headerlink" title="自动驾驶分级简介"></a>自动驾驶分级简介</h2><p>一个大致的介绍可以看这个文档：<a href="http://www.wetouchsky.com/sae-levels-of-driving-automation/">无人驾驶五级分类</a>，另外附上一个 <a href="https://www.huxiu.com/article/113258/1.html">主流的高端车的自动驾驶级别</a>，还有一个是知乎上一个自动驾驶工程师写的文章 <a href="https://www.zhihu.com/question/65799732/answer/238516359">自动驾驶攻破的难点在哪，何时能到Level 5？</a>。</p><p>主流的分级有两个，一个是美国机动车工程师协会 SAE（L0-L5），另一个是美国国家公路交通安全管理局 NHTSA（L0-L4）。</p><p>这边给一个NHTSA的汽车自动化分级：</p><ul><li>L0 - 无自动化<ul><li>车辆操控上无智能化，可能实现了某些辅助功能。</li><li>自动雨刷，自动车灯，转向车辆检测等</li><li>EBD/CBC制动力分配系统，ABS防抱死系统等，这些功能介于 L0 和 L1之间，总的来说可以放 L0。</li></ul></li><li>L1 - 单一功能级别的自动化<ul><li>和上一级别的主要区别是，开车会省力很多。</li><li>ACC自适应巡航，根据前车以及本车的行驶状态来自动加减速。</li><li>EBA应急刹车，驾驶员用了和平时不一样的节奏踩刹车，就会自动全力刹车。</li><li>LKS车道保持，通过传感器使得车在车道中间行驶。</li><li>中档车多多少少会有一点。</li></ul></li><li>L2 - 部分自动化<ul><li>和上一级的主要区别是，一般场景可以手脚同时离开车，人不再是主要操控者。</li><li>典型的，如结合 ACC 和 LKS 我们可以认为实现了 L2。</li><li>只有很高档车的会有这些。特斯拉介于 L2 和 L3 之间，低速场景堵车场景可以不用人操作。</li></ul></li><li>L3 - 有条件自动化<ul><li>和上一级别的主要区别是某些场景下，车辆可以完全接管汽车。</li><li>保留驾驶员接管车辆的可能，预留足够的预警时间让驾驶员接管车辆。</li><li>目前只有奥迪 A8 一款车号称 L3，五年之内应该会加大份额。</li></ul></li><li>L4 - 完全自动化<ul><li>和上一级的区别是，空车也能跑。</li><li>可以理解为不需要人操作车辆，在指定范围内点到点。</li><li>波士顿咨询给的时间表：预计2021，进场。预计2035，市场份额25%。</li></ul></li></ul><p>L0-L2应该正经叫法是 ADAS，L3-L4才能叫自动驾驶。可能大家为了 PR 会故意叫高端一些吧。</p><h2 id="无人驾驶系统"><a href="#无人驾驶系统" class="headerlink" title="无人驾驶系统"></a>无人驾驶系统</h2><p>大的来说，系统分为三个大块：系统端，算法端，云端。系统端更多指传感器驱动和数据融合，算法端主要做感知和决策，云端用来建模追踪等等。</p><h3 id="系统端"><a href="#系统端" class="headerlink" title="系统端"></a>系统端</h3><h4 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h4><p>一般来说还是需要很多传感器的数据融合的，毕竟有些传感器在某些场景下会失效。</p><ul><li><p>GPS 全球定位系统</p><ul><li>关注新一代GPS：差分 GPS系统</li><li>精度可以到达 30 厘米级别，数据刷新频率大概10 Hz</li><li>城市内由于多路径问题造成的误差可以大大减小。</li><li><a href="http://tech.feng.com/2017-10-02/Broadcom-has-released-a-new-generation-of-GPS-chip-positioning-accuracy-of-30-cm_692199.shtml">博通新一代芯片，BCM47755</a></li></ul></li><li><p>IMU 惯性传感器</p><ul><li>价差巨大，消费者电子产品里的几美分到几美元，车载几百上千，洲际导弹几十万美元。</li><li>刷新频率轻松 1 kHz，结合 GPS 就可以得到非常精确的定位。</li><li>距离是加速度的二次积分，误差累计非常大。</li><li>MEMS的传感器还有测角速度的版本，然后 A 股里有 MEMS 的厂商给电子产品供货（逃</li></ul></li><li><p>LIDAR 激光雷达</p><ul><li>检测位置信息，检测距离100米以上，形成“点云”可以充分表征周围的环境。</li><li>10Hz 旋转扫描四周，数据量巨大无比，16线雷达每秒需要处理 300 K 个点，64线雷达每秒需要处理 2200 K 个点。</li><li>空气有悬浮物，大雾霾大雨直接跪</li><li>很贵，16线目前 8000 刀，64线 10w 刀。据说今年 CES 发布的固态设备会降到300。</li><li>特斯拉没有用。。。</li></ul></li><li><p>摄像头</p><ul><li>几乎所有的方案都用了 8 个以上的摄像头。</li><li>车道线检测，交通灯检测，行人检测都是以摄像头的数据为主。</li><li>60 Hz 拍照，1080P 的数据的话，一张图2M，每秒G级别的数据。</li></ul></li><li><p>雷达/声呐</p><ul><li>底线级别的安全保障，检测到近距离障碍物就避让或者制动。</li><li>很多高端车现在已经有类似套系统。</li></ul></li></ul><h4 id="车载平台"><a href="#车载平台" class="headerlink" title="车载平台"></a>车载平台</h4><ul><li>硬件系统<ul><li>由于数据量太大，基本上不可能实时上报，大部分东西都要在车载设备上算。<ul><li>车载专属类 GPU 芯片，主流芯片算力是 5-20 TFlops这个级别，当然功率也极高。FPGA 或者类 ARM 移动 SoC在这个场景可以获得更高的能效。</li><li>各家芯片商都开始出自己的驾驶芯片了，<a href="https://zhuanlan.zhihu.com/p/29751954">特斯拉捅翻了马蜂窝！自动驾驶芯片战争爆发</a></li><li>某度的车怼了一个 XEON E5 cpu 和4-8个 Nvidia K80 gpu，峰值功率 5 kw。</li></ul></li><li>V2X车联网。<ul><li>5G 协议的一部分，普及情况非常不明朗。</li></ul></li></ul></li><li>软件系统<ul><li>大的来说都是 linux/unix 下，部分模块可能上实时操作系统，或者弄成嵌入式系统来保障安全性。<ul><li>有很多是基于 ROS 来做的。ROS 本身可以接管通信机制，发现同步机制之类的事情。但问题很多：1. 安全性，可用性都需要自己弄解决方案，2.广播、消息系统的性能不太好。等等</li><li>也有很多直接自己糊程序，不使用框架。</li></ul></li></ul></li></ul><h3 id="算法端"><a href="#算法端" class="headerlink" title="算法端"></a>算法端</h3><h4 id="定位算法"><a href="#定位算法" class="headerlink" title="定位算法"></a>定位算法</h4><ul><li>GPS/IMU方案<ul><li>可以通过 Kalman Filter 进行数据融合得到精准的坐标。</li><li>精度在米级别，寻路没问题，车道不好说，肯定需要配合其他方案</li><li>多路径问题干扰，封闭隧道之类不可用</li></ul></li><li>视觉方案<ul><li>立体图可以获得深度信息</li><li>连续的深度图可以预估运动情况</li><li>配合地图上的特征点可以得到厘米级别的精准位置</li></ul></li><li>雷达方案<ul><li>粒子滤波算法，和已知地图进行比较，得到精准信息</li><li>配合地图上的特征点可以得到厘米级别的精准位置</li></ul></li></ul><h4 id="物体识别和感知"><a href="#物体识别和感知" class="headerlink" title="物体识别和感知"></a>物体识别和感知</h4><ul><li>KITTI 数据集。一个集成了刚才说过的各种传感器的开源标注数据集。</li><li>Optical Flow。图片序列或者视频的像素密集对应关系。如每个像素得到一个二维偏移矢量。</li><li>MDP 马尔科夫决策过程 MOT 算法。把识别出来的图像进一步识别为 active，tracked，lost，inactive 四种状态。</li><li>CNN 算法</li></ul><h4 id="CNN-花式玩法"><a href="#CNN-花式玩法" class="headerlink" title="CNN 花式玩法"></a>CNN 花式玩法</h4><p>这部分将来再去多研究一下吧，连接口都没全看明白。先把索引列在这里：</p><ul><li>双目感知 <ul><li>用于 3D 建模，人眼开车本质也是视觉</li><li>Matching-Cost CNN</li><li>FlowNet</li></ul></li><li>物体检测<ul><li>必不可少的部分，提供周边环境的物体信息是很重要的。</li><li>Deformable Parts Model</li><li>R-CNN &amp; Faster R-CNN &amp; MS-CNN<ul><li>大致来说 R-CNN 是把 CNN 分为两段式，一段想办法做高召回率的区域划分，另一段做高准确率的区域内对象识别。</li><li>Faster R-CNN是一个比较新的版本，合理的手段能快速得到区域并且复用一部分数据到第二阶段。</li><li>在无人车这种尺度变化比较大的场景，Faster R-CNN 效果上还有空间，然后 MS-CNN 通过一些做法能得到更好的效果，但是要慢一些。</li></ul></li><li>SSD<ul><li>实时运行，更有准确度的算法。</li></ul></li></ul></li></ul><h4 id="增强学习"><a href="#增强学习" class="headerlink" title="增强学习"></a>增强学习</h4><p>同样不明觉厉。。。。。。唯一看懂的事情是有个叫 Torcs 的游戏，可以用 Deep Q-Learning 跑出很厉害的结果。</p><ul><li>REINFORCE</li><li>Deep Q-Learning</li><li>用来帮助决策</li></ul><h4 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h4><ul><li>路径规划<ul><li>本质上还一个有向带权图吧，然后是Dijstra 和 <code>A*</code>算法</li><li>车辆行驶的基本路径取决于车道规划，车道处理上会有特殊技巧</li></ul></li><li>行为决策<ul><li>对车辆而言行驶、跟车、转弯、变道、停车几个大类场景</li><li>对每一个障碍物而言，会有停车、超车、让行、停车、躲避几个典型的决策</li><li>具体的参数非常多</li></ul></li><li>动作规划<ul><li>轨迹规划</li><li>速度规划</li><li>需要考虑的参数也很多</li></ul></li><li>反馈控制<ul><li>自行车模型</li><li>PID 反馈控制</li></ul></li></ul><h3 id="云端"><a href="#云端" class="headerlink" title="云端"></a>云端</h3><ul><li><p>现在大部分公司的策略是 人工模型覆盖主要负责驾驶策略，云平台负责常规的模拟器回放和回归测试，然后剩下的部分直接路测。</p><ul><li>KITTI 数据集包括6小时 1M 张 140w 像素的彩色图片，目前业内顶尖水平的平均处理时间约需要0.3s。单机跑至少100小时。</li></ul></li><li><p>长期来说一定会形成闭环，采集的新数据可以通过模型反馈到算法决策端。</p><ul><li>目前纯算法建模的问题很多，而且出现了 edge case 几乎没有办法调试，所以几乎没有采用。</li><li>闭环的形成主要是一个工程问题，需要建设可靠且性能要求高的平台。</li></ul></li><li><p>汇总数据，更新驾驶模型，更新策略</p></li></ul><h3 id="高精度地图"><a href="#高精度地图" class="headerlink" title="高精度地图"></a>高精度地图</h3><ul><li>这个部分是典型的数据越多，地图精度越高的互联网闭环系统。</li><li>传统地图可以做到米级别的精度，但是无人驾驶需要的是厘米级别的精度。</li><li>激光雷达可以覆盖方圆100m，一次的数据约4MB。路面宽度假设20米，理论极限每次扫描可以下降到0.8M。1T 硬盘可以存10w km 的公路。</li></ul><h2 id="商业现状"><a href="#商业现状" class="headerlink" title="商业现状"></a>商业现状</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>一方面，各种传感器和各种算法都有可能成为无人驾驶的瓶颈，处处体现 trade off。另一方面，可以去买股票啊！！！<br>需要集成多种技术，多个传感器，有强实时性和可靠性要求，需要兼顾成本和功率、体积等因素。<br>车辆的微机控制器 ECU 和目前的计算机系统不是一个体系，车控需要主动去融合车厂的车规。</p><h3 id="传感器-1"><a href="#传感器-1" class="headerlink" title="传感器"></a>传感器</h3><h4 id="激光雷达"><a href="#激光雷达" class="headerlink" title="激光雷达"></a>激光雷达</h4><p>原理：可见和近红外波发射和接收来探测物体。<br>有效距离： 0 - 150 m。<br>价格：巨高，几千美元到几十万美元。主流市场4，8… 64，128线雷达。激光线数越多价格越高。<br>例子：Velodyne HDL-64 是一款 64 线雷达，价格大概10w 刀左右，扫描距离120米左右，精度为2厘米，每秒产生1.3M个像素，功率60w。<br>发展情况：很多厂商的环境感知是以激光雷达为主要信息。Velodyne，Quanergy 还有不少国内厂商都号称要量产成本在百元美金级别的固态激光雷达。总的来说一旦量产，激光雷达会满足摩尔定律。<br>缺陷：大雾大雨等不好的天气效果不好。<br>周边：<br><a href="http://36kr.com/p/5096700.html">已经有的激光雷达玩家</a></p><h4 id="毫米波雷达"><a href="#毫米波雷达" class="headerlink" title="毫米波雷达"></a>毫米波雷达</h4><p>原理：1-10mm 波长的无线电新号反射。分长中短几种，范围略有不同。<br>价格：很低，200-600美元<br>例子：奥迪 A4用1长+4短的组合，可以用来实现自动跟车功能。<br>发展情况：已经在开始在中高端车使用了。分24Ghz 和77Ghz 两个频段，24G 主要应用车后方应用，在前方和侧向也有使用。77G 是汽车前向的主流方向，一般是相互搭配的。将来逐步会全部使用77Ghz。几个大玩家出货量已经可以到千万片级别。77Ghz 目前被大厂垄断。24Ghz 的雷达已经有几个靠谱的中国供应商了。<br>缺陷：无法检测上漆的木头或者塑料（隐形飞机），难以检测行人，弯曲金属如易拉罐可能被误认为大型平面。<br>周边：<br><a href="http://blog.csdn.net/segments/article/details/52037785">毫米波雷达的开发与应用技术</a></p><h4 id="摄像头"><a href="#摄像头" class="headerlink" title="摄像头"></a>摄像头</h4><p>原理：图像识别，模式识别，匹配算法，最后估算相对距离和相对速度。<br>价格：看情况，不同摄像头价格差距很大。30-100美金<br>例子：特斯拉装了8个摄像头（前3，左右各2，后方1），提供360度环视功能，最远能够测量 250 米范围内的物体。<br>发展情况：<br>1.单目摄像头安装在挡风玻璃上面、车位、车的侧面等等，可以很好的还原四周的场景。难点是如何适应恶劣的环境和如何提升模式识别精度、智能程度。2，双目立体摄像头，可以利用双目视差得到好的距离信息，需要维护的东西远远小于单目。难点是如何双目同步和双目定位。3.半自动化的 ADAS  系统一般用 6+ 个摄像头，配合广角和单双目。<br>直接说车载系统需要的特点，就能看出和传统摄像头的区别，每一条都需要商业上的权衡：1高动态适应快速明暗变化，2帧率60或120，3角度要求苛刻，135°广角+55°高视距摄像头，4温度适应 -40° - 80°，5防磁，6抗震，7预期寿命至少10年。<br>缺陷：<br>上面的几点很难再低成本下同时完成。</p><h4 id="GPS-IMU"><a href="#GPS-IMU" class="headerlink" title="GPS/IMU"></a>GPS/IMU</h4><p>GPS 和 IMU 两个传感器都太成熟了，但是导弹上和玩具上的传感器完全不是一个概念。10-100000美元。这个没太多说的</p><h4 id="V2X"><a href="#V2X" class="headerlink" title="V2X"></a>V2X</h4><p>Vehicle to Vehicle车车，Vehicle to Instruction车路，Vehicle to Pedestrian车人，车和各种其他东西的通信，有一个车厂联盟，这里面故事和利益纠葛非常多，美国已经开始推行轻型新车都要安装 V2V 系统的法规。而且本身 LTE-V 极有可能被纳入5G 的标准。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>红外线传感器 探测距离0.2 - 120 m，600-2000美元，夜视效果很好，被国外垄断。<br>超声波传感器 仅仅用于超近距离防撞，15-20美元，倒车和侧面车辆检测，已经很成熟。</p><h3 id="计算平台"><a href="#计算平台" class="headerlink" title="计算平台"></a>计算平台</h3><p>某些公司把元件怼一起 至强E5 12核+8个 K80 GPU，做成计算盒。一个盒算力64.5TOP/S。然后怼俩计算盒提升可用性和效果，极端功率到达了车辆上比较难处理的 5000W。</p><h4 id="GPU-方案"><a href="#GPU-方案" class="headerlink" title="GPU 方案"></a>GPU 方案</h4><p>单个 GPU 能做到同价格 CPU 吞吐量的10-100倍。<br>NVIDIA 发布了多个芯片，帕斯卡架构的深度学习芯片Tesla P4和 Tesla P40，价格约6000刀一块。还有解决方案PX2，两个 SoC 和两个 Pascal GPU 组合，1.5w美元，处理能力可以到2800帧/s。</p><h4 id="DSP-方案"><a href="#DSP-方案" class="headerlink" title="DSP 方案"></a>DSP 方案</h4><p>（很神奇，以前没觉得这玩意可以做这事<br>数字信号处理是使用数据总线和地址总线分开的架构，允许同时取出和执行指令。德州仪器 TDA2x SoC 有两个 DSP 内核 + 四个视觉加速器，比 arm 的 cortex-15快8倍。3K 刀。</p><h4 id="FPGA-方案"><a href="#FPGA-方案" class="headerlink" title="FPGA 方案"></a>FPGA 方案</h4><p>深度学习有很多云服务商用了 FPGA 方案，无人驾驶有潜力。<br>Altera 公司的 Cyclone 5，已经用在奥迪 A8L 里的无人驾驶模块。 Zynq 公司的 Ultra ScaleMpSoC，能效14帧/瓦/秒，高于Tesla P40的4帧/瓦/秒。</p><h4 id="ASIC-方案"><a href="#ASIC-方案" class="headerlink" title="ASIC 方案"></a>ASIC 方案</h4><p>MobilEye 的 EyeQ5 SOC 装备了四种异构全编程加速器。为各种任务分配不同的处理单元。<br>全定制设计周期最长，半定制，用FPGA设计：从左至右，设计成本依次降低，芯片成本依次升高。</p><h4 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h4><p>这部分值得多看看，中国芯片有希望弯道超车。<br>1.Google TPU。用来训练后的决策分析速度快。<br>2.概率芯片。概率算法牺牲精度提升性能，物体追踪之类的场景比传统芯片速度快100倍，能耗还低10倍以上。还是08年的麻省理工十大科技评论<br>3.寒武纪！！还是发了几个处理器，名字有点傻傻的：DianNao，DaDianNao，PuDianNao，ShiDianNao，<br>4.中星微！！嵌入式神经网络处理器 NPU</p><h4 id="总结？"><a href="#总结？" class="headerlink" title="总结？"></a>总结？</h4><p>肯定将来是混着用的，GPU 做卷积什么的快且节能，CPU 擅长逻辑控制，FPGA 适合做多分支任务，DSP 适合做特征提取之类的流任务。<br>可能将来需要拼拼凑凑去弄计算平台吧，然后应用层的东西抽象成相同的计算任务。</p><h3 id="控制平台"><a href="#控制平台" class="headerlink" title="控制平台"></a>控制平台</h3><h4 id="电子控制单元ECU"><a href="#电子控制单元ECU" class="headerlink" title="电子控制单元ECU"></a>电子控制单元ECU</h4><ul><li><p><a href="https://zhuanlan.zhihu.com/p/24217391">什么是汽车ECU？</a></p></li><li><p>也可以叫车用单片机，可以理解为一种更加可靠的单片机。 基本单元包括不限于 CPU，ROM，RAM，I/O接口，A/D 转换器。</p></li><li><p>现在的中高端车的电气化程度非常的高，可能一台车包含100个 ECU 系统和200+芯片。</p></li><li><p>中国加油，这部分几乎是片空白。。。</p></li></ul><h4 id="车控总线"><a href="#车控总线" class="headerlink" title="车控总线"></a>车控总线</h4><ul><li>SAE 把总线分为 ABCD 四类，速度依次增加。</li><li>A 类总线面向传感器或执行器管理的低速网络。&lt;20Kb/s<ul><li>典型代表 本地互联网协议（Local Interconnect Network）</li><li>电动门窗，座椅灯光，车锁等</li></ul></li><li>B 类总线面向独立控制权共享信息的中速网络。10~125 Kb/s<ul><li>典型代表 控制器局域网 CAN 协议（ Controller Area Network）</li><li>车辆控制，测试仪表等</li></ul></li><li>C 类总线面向闭环实时控制的多路高速网络。125~1000 Kb/s<ul><li>复用 CAN 协议，ISO 11898-1覆盖了 BC 两种速率。但是实际上可能高低速部署到两条总线上。</li></ul></li><li>D 类总线面向多媒体和高速数据流的高性能网络。&gt;1000 Kb/s<ul><li>典型代表 FlexRay 协议</li><li>可以同时监控各个部件的车速、加速度、角度。高速响应特性可以用到类似电子减震系统里。</li></ul></li></ul><h3 id="高精地图"><a href="#高精地图" class="headerlink" title="高精地图"></a>高精地图</h3><p>传统 GPS 地图已经很成熟，高精度地图国内玩家也都是刚起步，百度高德四维之类。<br>一辆测绘车需要几百万美金，采集数据可以做到厘米级别。考虑到车道线，路障，车道标记，立交桥等极端情况，目前可以实现95%+的路标和车道标记准确度。<br>不排除车辆公司基于自己的数据做高精地图的可能性。毕竟自动驾驶车辆的传感器十分丰富。但是涉及牌照问题，地图在中国是敏感信息。。。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>据说很严重，连特斯拉量产的 Model S都被人轻松 Hack 了。其他的非量产 demo 车估计全是漏洞。</p><h3 id="伦理道德"><a href="#伦理道德" class="headerlink" title="伦理道德"></a>伦理道德</h3><p>1.肯定长期是要人做驾驶席的，有人背锅，有人在危险情况接管车辆。<br>2.类似不转弯撞死5个人，转弯撞死一个人，该怎么操作这种问题？我的理解是都撞死就好了，只有在无人驾驶出现了这样的 case 且全撞死，数量上还远远小于人类开车的时候，真正的无人驾驶才会出现。</p><h3 id="隐私"><a href="#隐私" class="headerlink" title="隐私"></a>隐私</h3><p>车辆产品很容易拿到用户的长相，坐标，常用生活地址之类的信息，对应的缺陷就是，对着车内的传感器，你没有隐私。</p><h3 id="极端天气"><a href="#极端天气" class="headerlink" title="极端天气"></a>极端天气</h3><p>目前可能没有好的解决方案，只能多传感融合。</p><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>目前 5G 也没确定完整的技术标准，V2X 可以解决很多问题，但是目前遥遥无期。</p><h2 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h2><h3 id="Taas"><a href="#Taas" class="headerlink" title="Taas"></a>Taas</h3><p>类似滴滴现在的模式。拼车成本变为原来三分之一至五分之一。</p><h3 id="快递"><a href="#快递" class="headerlink" title="快递"></a>快递</h3><p>快递行业最重要的成本就是人力，可以释放的潜力很大。</p><h3 id="工业场景"><a href="#工业场景" class="headerlink" title="工业场景"></a>工业场景</h3><p>大卡车很可能是第一个商用的自动驾驶场景。还有一些需要在封闭场景的工业场景，码头、高速之类快速投递。</p><h2 id="最后，关于汽车行业"><a href="#最后，关于汽车行业" class="headerlink" title="最后，关于汽车行业"></a>最后，关于汽车行业</h2><p>车辆行业早期用市场换技术，但是传统燃油车的核心技术落后别的国家很多年。最后这场游戏只剩了四个玩家，美日德中，中国没捡到什么便宜，但是好歹上桌了，借此培养出大量的世界级零部件供应商。<br>电动车在不久的将来会对汽车制造进行洗牌，车辆电动带来的影响就是三电系统（电池、电机、电控）几乎需要完全重构，汽车智能化志在必行。无人驾驶这件事也许还需要走至少十年的路，但高级别的 ADAS 一定会在不久的将来迅速提升装车率。<br>目前，看起来只有中国和美国两个玩家。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;稍微总结一下近期看的无人车相关的资料。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>大数据面试题</title>
    <link href="https://wangzitian0.github.io/2017/12/15/Bigdata-interview-problem/"/>
    <id>https://wangzitian0.github.io/2017/12/15/Bigdata-interview-problem/</id>
    <published>2017-12-15T03:27:00.000Z</published>
    <updated>2020-09-30T04:59:07.876Z</updated>
    
    <content type="html"><![CDATA[<p>先来把网上搜到的大数据面试题归类列出来，然后聊聊方法、总结和方法论。</p><a id="more"></a><h2 id="题目汇总"><a href="#题目汇总" class="headerlink" title="题目汇总"></a>题目汇总</h2><h3 id="频率类"><a href="#频率类" class="headerlink" title="频率类"></a>频率类</h3><ul><li>海量1T日志数据，找出某日访问次数最多的那个IP。</li><li>搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节，找出最多的 query。</li><li>怎么在海量数据中找出重复次数最多的一个？</li></ul><h3 id="Top-K"><a href="#Top-K" class="headerlink" title="Top K"></a>Top K</h3><ul><li>1G个数中找出最大的100个数。</li><li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li><li>海量1T数据分布在多台电脑（可以假设数据为字符串），想个办法高效统计出这批数据的TOP10。</li><li>上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</li><li>100G 个 int64 中找出第 K 大的数，1G 内存</li></ul><h3 id="排序类"><a href="#排序类" class="headerlink" title="排序类"></a>排序类</h3><ul><li>有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复，内存1G。要求你按照query的频度排序。</li></ul><h3 id="判重类"><a href="#判重类" class="headerlink" title="判重类"></a>判重类</h3><ul><li>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</li><li>在10亿个 int 中找出不重复的整数，1G 内存。</li><li>给40亿个单词，没排过序的，然后再给一组 query 词，如何快速query 是否在那40亿个单词中？</li></ul><h3 id="瞎搞类"><a href="#瞎搞类" class="headerlink" title="瞎搞类"></a>瞎搞类</h3><ul><li>一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中位数。</li></ul><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="内存空间计算方法"><a href="#内存空间计算方法" class="headerlink" title="内存空间计算方法"></a>内存空间计算方法</h3><h4 id="单位大小"><a href="#单位大小" class="headerlink" title="单位大小"></a>单位大小</h4><table><thead><tr><th>Symbol</th><th>Prefix</th><th>SI Meaning</th><th>Binary meaning</th><th>Size difference</th></tr></thead><tbody><tr><td>k</td><td>kilo</td><td>10^3   = 1000^1</td><td>2^10 = 1024^1</td><td>2.40%</td></tr><tr><td>M</td><td>mega</td><td>10^6   = 1000^2</td><td>2^20 = 1024^2</td><td>4.86%</td></tr><tr><td>G</td><td>giga</td><td>10^9   = 1000^3</td><td>2^30 = 1024^3</td><td>7.37%</td></tr><tr><td>T</td><td>tera</td><td>10^12  = 1000^4</td><td>2^40 = 1024^4</td><td>9.95%</td></tr><tr><td>P</td><td>peta</td><td>10^15  = 1000^5</td><td>2^50 = 1024^5</td><td>12.59%</td></tr><tr><td>E</td><td>exa</td><td>10^18  = 1000^6</td><td>2^60 = 1024^6</td><td>15.29%</td></tr><tr><td>Z</td><td>zetta</td><td>10^21 = 1000^7</td><td>2^70 = 1024^7</td><td>18.06%</td></tr><tr><td>Y</td><td>yotta</td><td>10^24 = 1000^8</td><td>2^80 = 1024^8</td><td>20.89%</td></tr></tbody></table><ul><li>程序里的内存默认是指上面表的Binary meaning，而硬盘内存大小一般是指SI Meaning。</li><li>1 bit：基本单元，只能表示0或1</li><li>1 byte：也是 <em>1B</em>，字节，8个bit，表示[0,256)的一个数字。</li><li>一般来说算法只关注复杂度，所以会忽视 size difference，绝大多数时候为了方便都是默认转换使用 10^n 这种形式，更加直观。</li></ul><p>程序语言常用类型大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char ：1个字节</span><br><span class="line">short int : 2个字节</span><br><span class="line">int：  4个字节</span><br><span class="line">unsigned int : 4个字节</span><br><span class="line">float:  4个字节</span><br><span class="line">double:   8个字节</span><br><span class="line">long:   4个字节</span><br><span class="line">long long:  8个字节</span><br><span class="line">unsigned long:  4个字节</span><br><span class="line">需要特殊注意的是：</span><br><span class="line">char*（指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器是8个字节）</span><br></pre></td></tr></table></figure><h4 id="数据结构知识背景"><a href="#数据结构知识背景" class="headerlink" title="数据结构知识背景"></a>数据结构知识背景</h4><ul><li>面试嘛，最难不过二叉树，知乎搜到了一个问题，直接看看吧，有一个大致的介绍<a href="https://www.zhihu.com/question/20176446">数据结构与算法中，树一般会应用在哪些方面？为什么？</a></li><li>重点，不懂的可以多查查关键词：<ul><li>基础的，栈，队列，链表。</li><li>Heap，堆<ul><li>快速查询 Top 1 类问题，可以快速增删元素。</li></ul></li><li>TRIE，字典树，可以快速查询字符串类的映射，处理前缀问题。<ul><li>加强版，AC 自动机。</li></ul></li><li>Treap，同时维护一个排序树Tree和一个堆Heap。<ul><li>典型的双权树还有 AVL，Splay。</li></ul></li><li>块状链表，神器级别的乱搞大法。<ul><li>普通的线性结构增删改查必有一个或者多个慢，但是它能在 O(sqrt(n))时间复杂度完成多种操作。加强版，莫队算法。</li></ul></li><li>B, B+, B-。<ul><li>最好了解下他们的区别，设计上的区别带来的影响是什么。</li></ul></li><li>KD-tree，用来解决高维度查询问题<ul><li>典型的是查询平面最近点距离。</li></ul></li><li>抽样哈希算法，可以用来校验完整性，用于对象选桶，可以保证分布均匀，同一个对象每次算出来是一样的值。<ul><li><a href="https://www.byvoid.com/zhs/blog/string-hash-compare">字符串哈希</a> &amp; <a href="https://baike.baidu.com/item/MD5">MD5</a></li></ul></li></ul></li></ul><h4 id="业内常用解决方案思路"><a href="#业内常用解决方案思路" class="headerlink" title="业内常用解决方案思路"></a>业内常用解决方案思路</h4><p>虽然一般不会直接问，但是业内的方案可以用来开拓思路。</p><ul><li>Redis 内部5种数据结构的实现方式。</li><li>MapReduce 的基本原理和例子。</li><li>MySQL 如何做到增删改查的复杂度都是<code>O(log n)</code><ul><li>具体可以研究下这个例子，尤其要体会一下批量更新懒标记：<a href="https://my.oschina.net/XYleung/blog/99604">如何在关系型数据库存树</a></li></ul></li><li>各种语言的类似 Map，HashMap，OrderedMap，Set的实现方式<ul><li>抽象概念是如何增删改查 k-v 对。</li><li>无序列表的实现方式，重点是哈希表。<code>O(1)</code></li><li>有序列表的实现方式，重点是平衡树。<code>O(log n)</code></li><li>需要仔细了解每个结构的基本节点占用多少地址空间</li></ul></li><li>全文索引技术<ul><li>倒排索引，<a href="https://www.cnblogs.com/zlslch/p/6440114.html">介绍</a>。</li></ul></li></ul><h2 id="题目解答"><a href="#题目解答" class="headerlink" title="题目解答"></a>题目解答</h2><h3 id="频率类-1"><a href="#频率类-1" class="headerlink" title="频率类"></a>频率类</h3><ul><li>海量1T日志数据，1G内存，找出某日访问百度次数最多的那个IP。</li><li>搜索引擎会通过 1T 日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为 1-255 字节，找出最多的那个query。</li><li>怎么在1T数据中找出重复次数最多的行。</li></ul><h4 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h4><p>问题本质：原始数据无序，需要实现一个内存无法完全装下的 Map，key 为查询，value 为频率。</p><p>方法论：把需要统计的东西无依赖分块，处理每个块的时候让Map可以装下。</p><p>基本思路：</p><ol><li>先扫一遍整个文件，将其分块写入 M 个文件/块，确保每个块对应的 key 集内存能装下。</li><li>对每个块进行处理，每次处理分别得到一个 Map。</li><li>记录每次 Map 对应的最大值即可。</li></ol><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><p>问题一：</p><ol><li>IP 地址本质可以表示为一个 unsigned int，32bit，按 IP 取模 M 的值将它们写入到 M 个文件，这样同一个 IP 一定会被写到同一个文件内，确保每个块对应的 IP 集内存能装下。</li><li>1T 的数据说明答案需要使用 int64来装；基于哈希表的 Map 基本单元一个额外链表的地址空间和 <code>O(n)</code> 级别的链表头；如果是64位操作系统，地址空间会占用 int64，链表头一个 int64，加起来是 <code>8B+8B*2</code>，表头为什么需要和哈希基本单元数量差不多可以仔细想一想。一个合适的选择是 <code>2 * 10^7</code>（对应的M为216），会占用 <code>24 * 2 *10^7 B</code> 地址，这样可以把内存压榨到一个比较极限（略超一半）的情况。</li><li>遍历第2.步的 Map，记录一个最大值，M 个最大值的答案就是最终答案。</li></ol><p>问题二：<br>几乎和问题一一摸一样。<br>把记录答案的 int64 的 8B 换成长度 256B 的字符串即可。</p><p>问题三：<br>1.和2.的步骤完全一样，3.步骤做一个变换，使用多路归并排序即可，然后就是读文件的时候可以每次读 <code>内存总量/路数</code> 大小的 block。</p><h3 id="Top-K-1"><a href="#Top-K-1" class="headerlink" title="Top K"></a>Top K</h3><ul><li>1G个数中找出最大的100个数。</li><li>有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。</li><li>海量1T数据分布在多台电脑（可以假设数据为字符串），想个办法高效统计出这批数据的TOP10。</li><li>上千万或上亿数据（有重复），统计其中出现次数最多的前N个数据。</li></ul><h4 id="分析方法-1"><a href="#分析方法-1" class="headerlink" title="分析方法"></a>分析方法</h4><p>问题本质：局部排序。</p><p>方法论：Top K 数字大小问题的经典解法有几种，</p><ul><li>求前 K 大的数，维护一个有 K 个元素的小根堆。（内存必须能装下整个堆）</li><li>类似快速排序的快速分区法，可以很快得到前 K 大的元素。</li><li>多路归并排序。</li><li>求Ranking K加一种分块的方法，将 N 个数字可能存在的范围分成 M 个区间，分别统计数字频次，然后对子区间进行递归处理。如数据<code>1...9</code>九个数字求第5大数字，可以分成3个区块，统计<code>[1...3,4...6,7...9]</code>在区间内出现的频率分别为<code>[3,3,3]</code>，然后子问题转换为：求<code>[4...6]</code>这个区间的第 2 大数字。需要扫描<code>O(log(N)/log(M))</code>次文件。</li></ul><p>基本思路：</p><ol><li>如果 K 不大，内存足够装下，直接使用堆（也可以是其他可以维护有序的数据结构）维护，结构里面始终保持 K 个元素即可。</li><li>如果 K 很大，先进行分块写入到 M 个文件中，确保内存足够单个文件排序。然后使用多路归并排序合并若干块。在操作的时候不要一次读一行，而是一次从一个文件读取多行。甚至可以在文件剩余元素不多的时候提前预读。(请确保 <code>每次读取行数* 行的大小 * 归并路数 &lt; 内存</code>)</li></ol><h4 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h4><p>问题一：<br>维护一个有 K 个元素的小根堆。</p><p>问题二：<br>0. 最坏情况所有词都不相同，一共拥有约 <code>6.3 * 10^7</code> 个单词。</p><ol><li>同之前频率类的算法，64位机器的哈希基本单元需要空间<code>(16B+8B*2)</code>，1M 内存大约可以装 <code>3 * 10^4</code> 个单词，所以将单词写到大约2500个<code>(6.3 * 10^7 / 3 * 10^4)</code>文件内。</li><li>每个文件使用 Map 分别做词频统计，此时每个文件对应一组 Map（K 为单词，V 为词频），将2500组的 Top 100 词频 KV 对写入到一个新的文件。</li><li>此时，问题已经转换为问题一，求最大的 100 个 V 对应的取值。 </li></ol><p>问题三：<br>0. 唯一的区别在于多台电脑，场景非常像 Hadoop 对应的 MapReduce。</p><ol><li>使用一个均匀的哈希，将每个字符串发送到唯一的电脑上。</li><li>每台电脑统计自己的 Top 10.</li><li>汇总到一台机器，此时转换为问题一。</li></ol><p>问题四：<br>0. 区别在于 N 没有给范围，可能很大。</p><ol><li>操作和问题二几乎一样。</li><li>将用于统计的 Map 完整的 K-V 按照降序对写到一个文件。</li><li>使用多路归并排序，归并之后的前 N 个元素就是答案。</li></ol><p>问题五：</p><ol><li>int64范围大约有 <code>2 * 10^19</code>个数字，我们可以选择方法论中的分块法，分成10^7个块即可。</li><li>之所以不用上面的方法，是因为这个方法可以不需要写入任何内容到磁盘，只需要读三次这个文件。</li></ol><h3 id="排序类-1"><a href="#排序类-1" class="headerlink" title="排序类"></a>排序类</h3><p>偷个懒，直接去看别人的文章吧 </p><ul><li><a href="http://blog.jobbole.com/11745/">视觉直观感受 7 种常用的排序算法</a></li><li><a href="http://www.jianshu.com/p/98090954f049">怎样给一个磁盘文件排序</a></li><li><a href="http://www.epubit.com.cn/article/301">常见的内排序和外排序算法</a></li><li><a href="http://blog.csdn.net/yangzhongblog/article/details/8184707">补充一个黑科技，Python 实现 sort 的 TimSort，复杂度小于 n log n 的稳定排序算法</a></li></ul><h3 id="判重类-1"><a href="#判重类-1" class="headerlink" title="判重类"></a>判重类</h3><ul><li>给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？</li><li>在10亿个 int 中找出不重复的整数，1G 内存。</li><li>给40亿个单词，没排过序的，然后再给一组 query 词，如何尽可能快的判断一个query是否在那40亿个单词中？</li></ul><h4 id="分析方法-2"><a href="#分析方法-2" class="headerlink" title="分析方法"></a>分析方法</h4><p>问题本质： 离在线问题，理应把各种操作抽象成某种数据结构的增删改查。</p><p>基本思路：</p><ol><li>类似词频的分块统计。使用哈希将数据分布到小文件，直接使用 Map 查询。</li><li>充分利用内存空间，直接打01标记，分别表示是否出现过。</li><li>字符串特定结构，TRIE字典树，压缩查询路径的字典树，AC 自动机。</li></ol><h4 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h4><p>问题一：</p><ol><li>将 A 和 B 分别拆成 M 个小文件A1…Am，B1…Bm，必须使用同一个哈希函数来确保 同一个 url 被分配到同一编号的小文件 Ax 和 Bx 中，请确保每个文件的 url 能在内存中装下。</li><li>对于每一组文件 Ax 和 Bx，使用一个 Set，将 Ax 中的所有 url 加入 Set，然后一次判断 Bx 中的 url 是否在 Set 中。</li><li>将所有答案汇总写到一个文件里。</li></ol><p>问题二：<br>0. 先考虑一个简化版本：在10亿个 int 中找出出现的整数，1G 内存。我们假设可以使用01标记来表示是否出现，计算一下需要的位置有多少，对应的内存是多少，int 对应的数字有 2^32 个 bit 位，除以8之后，也就是需要2^29B 大小，对应的空间约 500M。</p><ol><li>此时回头思考这个问题，可以有一个做法，2bit，表示一个数字是否出现过，一个位置表示是否出现过，另一个位置表示是否出现了重复。<ul><li>另数字初始值全部为0</li><li>一个数如果没有出现过，则把它的第一个标记为打成1</li><li>如果发现一个数已经出现过，则把它的第二个标记为打成1</li><li>统计一遍第一个标记位为1，第二个标记位为0的数字。</li></ul></li><li>上面的思路是很好的思路，但是严格来说是不对的。为什么？我们计算一下空间使用，int 对应的数字有 2^33 个 bit 位，除以8之后，也就是需要2^20B 大小，对应的空间约 1G。但是！但是！但是！1G 不等于2^30B，查看我前面给的表吧。</li><li>加思路。事实上，信息是足够多且有浪费的，第二个标记的初始值是没有意义的。一个位置 Zi，初始为0，如果有数字出现，给它标记为，如果它已经是2，不进行操作。一个 int 有32个位，我们计算一下需要的空间极限，<code>(log 3/log 2)* 2^32</code> bit，这个值小于1G。没想清楚？每一个数字三种状态，总状态数其实只有 <code>3 * 2^32</code>。举个例子，按上一个方案存储3个数字的信息需要6bit，事实上状态只有3^3个，只需要 <code>ln(3^3)/ln(2) = 3.296/0.693 &lt; 5</code>，也就是5个 bit 的信息足够表示这个状态。</li></ol><p>问题三：<br>给两种复杂度是<code>O(length)</code>的方法<br>直接试用哈希，然后对哈希值进行比较，哈希值相同认为字符串相同，否则认为不同。<a href="http://blog.csdn.net/u012926924/article/details/50717407">数学论证</a><br>建一个 TRIE，字典树可以依次去按照字符串的第0，1，2，3…个字符依次查询子集，几乎只有单纯的寻址工作，效率非常高。</p><p>另外，然后倒排索引也是一种答案，在生产环境应该是效率非常高的，因为网站的80%的流量会落在20%的 query 上，但是十分不严谨。</p><h3 id="瞎搞类-1"><a href="#瞎搞类-1" class="headerlink" title="瞎搞类"></a>瞎搞类</h3><ul><li>一共有N个机器，每个机器上有N个数。每个机器最多存O(N)个数并对它们操作。如何找到N^2个数的中位数。</li></ul><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>有一部分题目是几种模型的结合或者没有什么特别的模型，但是只要用好分类的思想，让它形成可以分治的计算任务就可以做</p><h4 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h4><p>问题一：这个题目网上有很多人抄某个哥们的解答，但是那个解答有问题，一个是不通用算法，一个太慢了。另外，N 台机器跑 O(log N)的算法，复杂度还是<code>O(log N)</code>，很多答案都没有充分利用这点。<br>方法1，转换为上面的第 K 大问题，每台机器先自己排序<code>O(N*log(N))</code>，然后直接多路并归排序，找到第 <code>N*N/2</code> 大的数字就是答案。<code>O(N*N*log(N*N))</code><br>方法2，先每台机器数据排升序<code>O(N*log(N))</code>，接下来二分中位数的大小<code>O(log(MaxNumber))</code>。分别查询每一台机器查询小于中位值的数字个数，如果个数小于<code>N*N/2</code>，拉高下界，否则拉低上限，直到数字个数和刚好等于<code>N*N/2</code>，由于每台机器去查询。复杂度<code>O(N*log(N))+O(log(MaxNumber))*(O(log N) + O(N))</code>后面的三个 O 实际意义分别是二分中位数复杂度，二分查找数字复杂度，数组并发求和复杂度，总复杂度应该是<code>O(N*log(max(N,MaxNumber)))</code></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>欢迎大家给我补充相关的题目，以及讨论有没有更好的做法。<br>做完这些题目，我的感觉是应该就能理解为什么要有 MapReduce 这种框架了，将数据计算过程拆成 Map 和 Reduce 确实是一种很巧妙的设计。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;先来把网上搜到的大数据面试题归类列出来，然后聊聊方法、总结和方法论。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Interview" scheme="https://wangzitian0.github.io/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>什么是全栈工程师？</title>
    <link href="https://wangzitian0.github.io/2017/06/28/What-is-fullstack-engineer/"/>
    <id>https://wangzitian0.github.io/2017/06/28/What-is-fullstack-engineer/</id>
    <published>2017-06-28T12:35:00.000Z</published>
    <updated>2020-09-30T04:59:07.881Z</updated>
    
    <content type="html"><![CDATA[<p>谈一下我理解的全栈工程师和为什么我希望成为全栈工程师。</p><a id="more"></a><h2 id="什么是全栈工程师？"><a href="#什么是全栈工程师？" class="headerlink" title="什么是全栈工程师？"></a>什么是全栈工程师？</h2><h3 id="源于-Facebook"><a href="#源于-Facebook" class="headerlink" title="源于 Facebook"></a>源于 Facebook</h3><p>Quora 上有一个答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A full stack developer is capable of performing tasks at any level of the technical stack in which they reside. It means:</span><br><span class="line"></span><br><span class="line">Working with systems infrastructure (knowing what hardware to ask for , what OS to install, how to prepare the system and dependencies for all software)</span><br><span class="line">Understanding, creating, manipulating, and querying databases</span><br><span class="line">API &#x2F; back-end code in one or more languages, e.g. Ruby, Java, Python, etc.</span><br><span class="line">Front-end code in one or more languages, e.g. HTML, JavaScript, Java, etc.</span><br><span class="line">Project management &#x2F; client work, e.g. gathering requirements, creating technical specifications and architecture documents, creating good documentation, managing a project timeline (e.g., someone who knows Agile&#x2F;SCRUM&#x2F;Kanban) </span><br></pre></td></tr></table></figure><p>全栈工程师是指能在任何能在一个技术栈的任何层次完成工作的工程师。</p><ul><li>知道计算机操作系统的基本运行原理</li><li>知道如何操作数据库</li><li>用一种语言写后端的 API 代码</li><li>前端合适的技术可以实现业务逻辑</li><li>工程管理，包括不限于需求分析、敏捷开发、文档管理等等</li></ul><p>这种说法最开始源于 Facebook，“Nothing at Facebook is Somebody Else’s Problem”，换句话说，有问题就马上评估是否值得解决。如果值得解决，你就应该着手去解决，而不是假设别人比你更合适解决这个问题。</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>举个例子，你原本是一个后端工程师，在做响应时间的调优，初期后端上改进很大，后期效果已经不明显，但是你发现网络传输和前端有很大空间。假设现在前端的工程师对这两块也不是很了解，这个时候怎么办？</p><ul><li>顺其自然，不了了之。</li><li>从外面招一个会的工程师。</li><li>自己学相关知识然后直接去调整。</li></ul><p>Facebook 之所以选择第三种，有这么几点理由：</p><ul><li>本身的挑战已经非常大了，极大的用户量带来极大的问题，很难从市面上直接找一个能解决问题的人。</li><li>如果解决掉新发现的一个问题大于手里正在做的事情，哪怕它不是自己擅长的，也应该自己去把它做好。</li><li>真正高素质的人不仅仅是掌握知识，而是拥有学习知识的知识，也就是学习能力。有了学习能力，具体的知识总能学会。</li><li>每个技术都有自己的背景和优势劣势。有时候强行规定使用的技术反而会限制大家的产出。倒不如根据需求去选择合适的技术。</li><li>关注整个公司的产出和效率。大部分提升效率的地方往往来源于别人没有思考过的问题，不如谁发现，谁解决。</li></ul><h3 id="外行看把式，内行看门道"><a href="#外行看把式，内行看门道" class="headerlink" title="外行看把式，内行看门道"></a>外行看把式，内行看门道</h3><p>并不是深究技术不重要，顺着业务的发展，技术的难度和深度会自然而然的增加。但是，过分在某一种技术实现方案上过分深究是没有必要的，工程师应该去深度研究计算机工程学的基本原理，以解决问题的心态来选择合适的技术。在现有方案都不完美的情况下，甚至可以自己造轮子。好的开发者，即使不是全栈，也要融会贯通多种技术。学习门道需要充分研究各种把式，不可能凭空学。</p><p>回到刚才的话题，Facebook鼓励的是刚毕业不太久的这群人全栈，面向产品快速迭代，面向价值产出效率的提升，技术上追求的是切实解决问题，而不是局限于自己原有的技术知识。到了一定的阶段，工程师自然而然地在在某些方面变得资深。</p><h3 id="为什么在国内会招黑？"><a href="#为什么在国内会招黑？" class="headerlink" title="为什么在国内会招黑？"></a>为什么在国内会招黑？</h3><p>仔细想想，其实全栈工程师也可以分为这几种类型。</p><h4 id="装逼型"><a href="#装逼型" class="headerlink" title="装逼型"></a>装逼型</h4><p>连栈是啥玩意儿都没明白，自称”全栈工程师”比较高端。</p><p>不招黑才怪。</p><h4 id="菜鸟型"><a href="#菜鸟型" class="headerlink" title="菜鸟型"></a>菜鸟型</h4><p>追求『 ▇ 』 型人才是好事，但是一个普通智商的人能做到『 T 』型人才就很牛逼了，实在不行也可以做『 l 』型人才。</p><p>但是一个 『一』型的跑过来说自己是 ▇  不被黑才怪。</p><h4 id="创业型"><a href="#创业型" class="headerlink" title="创业型"></a>创业型</h4><p>在互联网早期，程序员基本都是『全栈』。</p><p>全民创业的背景下，这种全栈工程师也称为demo工程师</p><p>还有一类，可以别称“因为老板加不了钱请不起人所以全部得干的加班狗”</p><h4 id="前端型"><a href="#前端型" class="headerlink" title="前端型"></a>前端型</h4><p>原来搞 H5 的人，研究了一下 nodejs。</p><p>这种至少好于前三种，是对于技术场景的自然延伸。为了适应网络特点，而使用更先进的架构，让服务端处理更多的数据，减小客户端尤其是移动端的计算压力。</p><p>前端工程师一直处于鄙视链的底端。这么几个原因：</p><ul><li>很多H5工程师是培训班出来的，素质堪忧，基本上只会做一做简单的交互。</li><li>相比于其他工种，前端工程的发展时间相对较短【06年左右，前端工程真正开始发展以XHR纳入 W3c 为标志，而后端是1996年左右就开始发展了】，这里的原理和这句话一样：“震惊！九零后程序员竟然无一人超过三十岁！”。</li><li>前端这三四年很乱，天天有人造轮子。WEB发展早期有各大语言框架之争，而前端是 JavaScript 一统天下，自然而然会涌现出各种框架。</li></ul><p>鄙视链如此，前端级别不太高的工程师想往全栈发展的特别多。</p><p>如同俄国是资本主义的薄弱环节，十月革命从俄国发起。前端是计算机工程的薄弱环节，全栈的风潮是从前端发起。</p><p>但是，个人觉得全栈应该从“后端”学起。</p><h4 id="架构型"><a href="#架构型" class="headerlink" title="架构型"></a>架构型</h4><p>这个级别的人都是全栈工程师。知识太局限的人无法成为重要项目的负责人，也无法创造业界影响力。</p><p>关注了很久的一个有趣的问题：<a href="https://www.zhihu.com/question/29910703">腾讯T4专家工程师是什么水平？</a></p><p>比如滴滴在业务暴增期用了腾讯云的业务，这时候会找一些T4资深的架构师来 review，目的就是规避不可预知的风险。</p><p>试问，怎样才能规避海量流量接入的系统风险？没有各个层面的知识能做到么？</p><h4 id="极客型"><a href="#极客型" class="headerlink" title="极客型"></a>极客型</h4><p>Twitter 早期创业使用的 RoR 框架，一种开发非常高效的 MVC 框架，用极短的时间可以做出非常多的事情，<a href="http://www.guokr.com/blog/388679/">采访Ruby语言创始人松本行弘</a>。</p><p>Instagram 在被 Facebook 10亿美金收购的时候，整个公司团队有惊人的13个，怎么做到的？使用的框架是 Django，一个类似 RoR 的高效全家桶WEB开发框架。<a href="http://blog.sae.sina.com.cn/archives/4215">Instagram的技术架构</a></p><p>不错的互联网公司人均产值是百万美金，腾讯阿里级别的生态公司一般是1000万美金，而Instagram的早期，直接接近亿级别。</p><p>国外很多的小公司使用 RoR，国内更多的是 Python 系的人。然后就是黑客与画家的作者极度推崇 Lisp，也是这种风格的语言。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>招黑的是前三类和第四类的一部分人。</p><h2 id="工程师分级"><a href="#工程师分级" class="headerlink" title="工程师分级"></a>工程师分级</h2><p>摘录自吴军博士《硅谷之谜》的等级划分，非常有意思。</p><h3 id="第五等工程师"><a href="#第五等工程师" class="headerlink" title="第五等工程师"></a>第五等工程师</h3><p>第五等工程师，是能够独立设计和实现一项功能的人。这是对工程师的基本要求，如果一个人只是懂一点工程实现的手段，需要别人告诉他怎么做，那最多算是助理工程师或技工。</p><h3 id="第四等工程师"><a href="#第四等工程师" class="headerlink" title="第四等工程师"></a>第四等工程师</h3><p>第四等的工程师就需要有点产品头脑了，也就是说他们在做一件事之前，要知道所作出来的东西是否有用、易用，是否便于维护，是否性能稳定，等等。除了要具备产品设计方面的基本知识，还要具有一定的领导才能，能在整个产品的生命周期从头到尾将一个产品负责到底。这在很多硅谷的公司里，基本上是一个高级工程师所应有的基本素质，对大部分工程师来讲，这些素质不是一个工学院能培养出来的，而是需要在工业界实际锻炼三四年甚至更长的时间。当然，个别天赋很好的年轻人在学校里就具备了这种素质，但这是可遇不可求的。</p><h3 id="第三等工程师"><a href="#第三等工程师" class="headerlink" title="第三等工程师"></a>第三等工程师</h3><p>第三等的工程师可以做出行业里最好的产品。他们与第四等工程师有着质的区别，这不仅反映在技术水平、对市场的了解、对用户心理的了解以及组织能力等诸多方面，而且也反应在悟性的差异上。当然，这种悟性很多是后天培养出来的，但这就需要更长的时间了。有些人从工作一开始，可能需要十年八年，经过多次失败，不断总结，终于在某个时间点豁然开朗。而另一些人可能非常幸运，在一开始就有幸和最优秀的人一起工作，加上善于学习，五六年下来就能达到第三等的水平。在硅谷，有极少数工程师只花了五六年时间就达到了这个水平。但是，即使一个人再聪明，基础再好，也需要在工程上花足够的时间才能达到这个水平，一个年轻人工作了四五年就开始做行政管理工作，基础上就和这个水平无缘了。</p><h3 id="第二等工程师"><a href="#第二等工程师" class="headerlink" title="第二等工程师"></a>第二等工程师</h3><p>第二等的工程师是那些可以给世界带来惊喜的人，比如实现第一台实用化个人计算机的沃兹尼亚克、DSL之父约翰·西奥菲、iPhone和Google Glass的总设计师，以及开发Android系统的如宾等等。他们与第三四五等工程师的差别在于其工作的原创性以及对世界的影响力。当然，他们的工作不是科学研究，这一点和科学家毕竟不同。</p><h3 id="第一等工程师"><a href="#第一等工程师" class="headerlink" title="第一等工程师"></a>第一等工程师</h3><p>第一等的工程师是开创一个全新行业的人，历史上有爱迪生、特斯拉、福特，二战后有保时捷博士、本田宗一郎和硅谷的诺伊斯等人。这些工程师不仅在技术和产品等各个方面上与第二等的工程师有了质的差别，而且在经验和管理上也是好手，他们通常也是企业家，并通过自己的产品改变了世界。这一类人常常是可遇不可求的，正如朗道列出的第一等物理学家只有个位数一样，第一等的工程师也是如此。朗道认为每一等物理学家之间的贡献相差十倍，每一等工程师的差距也是这么大。</p><h3 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h3><p>工程师不应该束缚自己，不应该固定方向。</p><p>工程师应该动用一切可以用的资源，造出好用的东西。</p><p>伟大的工程师要能发现并解决有十倍百倍增长空间的事情。</p><p>保三争二学一。</p><h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>逛 github 的时候发现一个毕业还只有三年，但知识结构很完整的哥们 <a href="https://github.com/phodal/growth-ebook">phodal’s Github</a>，知识结构在创业公司里面会非常有用。虽说感觉这哥们在性能调优方面理解不是很到位，但是综合实力应该碾压绝大多数毕业三年左右的本科生。</p><p>往小了说，WEB 技术栈是一个技能集，往大了说，WEB 技术栈是一个知识树：</p><h3 id="WEB-技术栈"><a href="#WEB-技术栈" class="headerlink" title="WEB 技术栈"></a>WEB 技术栈</h3><ul><li>熟悉*nix操作系统命令行和脚本</li><li>熟悉常见开源数据库的使用</li><li>熟悉主流的几种编程语言</li><li>熟悉一种后端框架</li><li>熟悉一种前端框架</li><li>熟悉各种缓存策略</li><li>熟悉一种数据分析工具</li><li>熟悉如何给产品加跟踪器</li><li>熟悉如何部署代码</li><li>了解前后端分离技术</li><li>了解基本的虚拟机和容器技术</li><li>了解 CDN 技术</li><li>了解基本的队列技术</li><li>了解基本的微服务、混合云技术</li></ul><h3 id="WEB-知识栈"><a href="#WEB-知识栈" class="headerlink" title="WEB 知识栈"></a>WEB 知识栈</h3><h4 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h4><ul><li>语言语法</li><li>数据结构</li><li>基本算法</li><li>设计模式</li></ul><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><ul><li>操作系统原理</li><li>数据库原理</li><li>计算机网络原理</li><li>编译原理</li></ul><h4 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h4><ul><li>测试开发</li><li>持续集成</li><li>部署和运维</li><li>工程架构</li><li>性能调优</li><li>自动化处理琐事</li></ul><h4 id="编码效率"><a href="#编码效率" class="headerlink" title="编码效率"></a>编码效率</h4><ul><li>IDE 使用配置</li><li>版本管理</li><li>重构技巧</li><li>会逛github</li></ul><h4 id="宽广的知识面"><a href="#宽广的知识面" class="headerlink" title="宽广的知识面"></a>宽广的知识面</h4><ul><li>UX 入门</li><li>SEO 入门</li><li>经济学原理入门</li><li>商业知识入门</li><li>数据分析入门</li><li>公司运作的原理</li><li>行业趋势的认知</li><li>文史知识</li><li>讲故事的能力</li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>不知道我理解的全栈和你理解的是不是一个东西？<br>是与不是都欢迎交流。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;谈一下我理解的全栈工程师和为什么我希望成为全栈工程师。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Fullstack" scheme="https://wangzitian0.github.io/tags/Fullstack/"/>
    
    <category term="Engineering" scheme="https://wangzitian0.github.io/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>WEB 服务器探究</title>
    <link href="https://wangzitian0.github.io/2017/06/27/WEB-server-explore/"/>
    <id>https://wangzitian0.github.io/2017/06/27/WEB-server-explore/</id>
    <published>2017-06-27T07:40:00.000Z</published>
    <updated>2020-09-30T04:59:07.881Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 web 服务器基本概念，和常见的服务端演替路线。</p><a id="more"></a><h2 id="几种不同名字的服务器有什么区别？"><a href="#几种不同名字的服务器有什么区别？" class="headerlink" title="几种不同名字的服务器有什么区别？"></a>几种不同名字的服务器有什么区别？</h2><p>WEB服务器、应用程序服务器、HTTP服务器</p><p>具体的内容可以看 <a href="http://www.javaworld.com/article/2077354/learn-java/app-server-web-server-what-s-the-difference.html">这篇文章</a> 和它的 <a href="http://blog.csdn.net/flykobesummer/article/details/5024304">翻译版</a></p><p>我只说结论：</p><ul><li>HTTP服务器本质上也是一种应用程序</li><li>Web服务器的基本功能就是提供Web信息浏览服务。它只需支持HTTP协议、HTML文档格式及URL。与客户端的网络浏览器配合。因为Web服务器主要支持的协议就是HTTP，所以通常情况下HTTP服务器和WEB服务器是相等的，说的是一回事。 </li><li>应用服务器可能包含PC机上运行的GUI进程，web服务器，甚至其他的app服务器。app服务器和客户端之间的通信并不局限于简单的显示标记，而是可以由程序逻辑，比如数据表单、方法调用，而非静态的HTML。这样，客户端程序就可以按需去用。</li><li>举个例子，QQ 的后台是应用程序服务器，QQ 空间的后台是WEB服务器。</li></ul><h2 id="tomcat-与-nginx，apache的区别是什么？"><a href="#tomcat-与-nginx，apache的区别是什么？" class="headerlink" title="tomcat 与 nginx，apache的区别是什么？"></a>tomcat 与 nginx，apache的区别是什么？</h2><p>知乎有一个关于这个问题的答案 <a href="https://www.zhihu.com/question/32212996">tomcat 与 nginx，apache的区别是什么？</a><br>还有一个 Nginx 和 Apache 的对比 <a href="http://www.sohu.com/a/128940634_468650">三大Web服务器对比分析</a></p><p>总的来说：</p><ul><li><p>应用程序服务器</p><ul><li>Tomcat能够动态的生成资源并返回到客户端。<ul><li>Java Servlet技术以及衍生的Java Server Pages技术可以让Java程序也具有处理HTTP请求并且返回内容。</li><li>它有直接部署 java 程序的能力</li></ul></li><li>Tomcat运行在JVM之上，它和HTTP服务器一样，绑定IP地址并监听TCP端口<ul><li>管理Servlet程序的生命周期</li><li>将URL映射到指定的Servlet进行处理</li><li>与Servlet程序合作处理HTTP请求</li></ul></li></ul></li><li><p>web 服务器</p><ul><li>Apache和Nginx都能够将某一个静态资源文件的内容通过HTTP协议返回到客户端。<ul><li>无论何时、任何人访问它得到的内容都是完全相同的</li></ul></li><li>Apache和Nginx可以通过其他模块来支持动态资源<ul><li>通过Shell、PHP、Python脚本程序来动态生成内容</li><li>其他语言可以通过 CGI、WSGI 等协议接入 web 服务器。</li></ul></li><li>Apache vs Nginx<ul><li>Apache 的 rewrite 更强大，社区模块非常多，bug极少</li><li>nginx 轻量，用 epoll可以扛并发，可以反向代理</li></ul></li></ul></li></ul><h2 id="各种语言的简易web服务器"><a href="#各种语言的简易web服务器" class="headerlink" title="各种语言的简易web服务器"></a>各种语言的简易web服务器</h2><p>这个地方的 web 服务器应该理解为只能访问静态资源的 web 服务器。</p><p>换句话说，在硬盘某个地方放一些文件，搭起服务器后，可以在浏览器里通过网络协议来访问这些资源。</p><p><a href="https://github.com/eidheim/Simple-Web-Server">C++</a></p><p><a href="https://github.com/itang/gohttp">Golang</a></p><p><a href="http://coolshell.cn/articles/1480.html">Python</a></p><p><a href="https://stackoverflow.com/questions/6084360/using-node-js-as-a-simple-web-server">Nodejs</a></p><ul><li>推荐 light-server </li></ul><p><a href="https://github.com/youngj/httpserver">PHP</a></p><h2 id="正经网站的结构"><a href="#正经网站的结构" class="headerlink" title="正经网站的结构"></a>正经网站的结构</h2><p>这部分内容的结构来源于【<a href="https://book.douban.com/subject/25723064/">大型网站技术架构</a>】，然后加上我自己的理解和常见的工具、现代化 MVP 处理方式。</p><p>正经网站基本上都需要需要存储结构化数据，有不同身份用户交互的，需要存储音乐图片视频等媒体文件的，然后是用网络协议调用外部服务。</p><ul><li>在书里说是 xxx 服务器，但更准确的说法是 xxx 服务，比如缓存，我们很多时候可以和应用程序使用同一个服务器硬件。</li><li>更现代的方式应该是监控各种服务的资源占用情况，然后根据资源占用情况混合部署，充分利用 CPU、内存、硬盘 IO 性能等等</li><li>这里可以把 xxx 服务器理解为抽象概念的服务器，哪怕调用 memcache 这样的插件也是走网络协议 socket 或者 http 协议</li><li>各个部件用不同的协议和端口，所以抽象层逻辑上的单机和多机区别不大，集群带来的效果更多关注总的 CPU 算力、总内存、总硬盘 IO 量等等。</li></ul><h3 id="初始阶段的网站架构"><a href="#初始阶段的网站架构" class="headerlink" title="初始阶段的网站架构"></a>初始阶段的网站架构</h3><p>一般来讲，大型网站都是从小型网站发展而来，一开始的架构都比较简单，随着业务复杂和用户量的激增，才开始做很多架构上的改进。当它还是小型网站的时候，没有太多访客，一般来讲只需要一台服务器就够了，这时应用程序、数据库、文件等所有资源都在一台服务器上，网站架构如下图所示：<br><img src="/images/web-server-1.png" alt="web-server-1"><br>HINT：</p><ul><li>这个级别基本上属于本科生大作业级别</li><li>直接在应用程序里面写东西去连接 client，操作文件，操作数据库</li><li>几乎没有抗风险能力，一挂全挂</li><li>面向自己的程序这么写是没问题的，开发起来很快，也不需要多余的轮子</li><li>比较好的实践是自己封装一些lib，用来隔离各种不相关操作</li></ul><h3 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h3><p>随着网站业务的发展和用户量的增加，一台服务器就无法再满足需求了。大量用户访问导致访问速度越来越慢，而逐渐增加的数据也会导致存储空间不足。这时就需要将应用和数据分离，应用和数据分离后整个网站使用 3 台服务器：应用服务器、文件服务器和数据库服务器。这 3 台服务器对硬件资源的要求各不相同：应用服务器业务逻辑，需要强大的CPU数据库服务器对磁盘读写操作很多，需要更快的磁盘和更大的内存文件服务器存储用户上传的文件，因此需要更大的磁盘空间此时，网站系统的架构如下图所示：<br><img src="/images/web-server-2.png" alt="web-server-2"><br>HINT：</p><ul><li>这个阶段一般关注两件事：数据库索引、缓存系统</li><li>做一个好的数据库设计，让并让绝大多数查询打在索引上，避免掉不必要的多级join 、limit 很大数字 等速度极慢的艹库行为。</li><li>内存 io 实力比硬盘高很多数量级，设计好精巧的缓存能把网站抗压能力提高一到三个数量级。因为很多场景，82原理可以用两次（80%的流量打在20%的页面和数据库上，64%的流量打在4%的页面和数据库上）</li><li>绝大多数时候，认真设计数据模型+靠谱的缓存就能解决大部分并发，比加机器更有效</li></ul><h3 id="使用缓存改善网站性能"><a href="#使用缓存改善网站性能" class="headerlink" title="使用缓存改善网站性能"></a>使用缓存改善网站性能</h3><p>随着用户再增加，网站又会一次面临挑战：数据库压力太大导致整站访问效率再此下降，用户体验受到影响。一个网站，往往 80% 的业务访问集中在 20% 的数据上，比如微博请求量最多的肯定是那些千万级粉丝的大 V 的微博，而几乎没有人关注的你的首页，除了自己想起来之外根本不会被打开。既然大部分业务访问集中在一小部分数据上，那就把这一小部分数据先提前缓存在内存中，而不是每次都去数据库读取，这样就可以减少数据库的访问压力，从而提高整个网站的访问速度。 网站使用的缓存一般分为缓存到应用服务器或者缓存在专门的分布式缓存服务器。缓存到应用服务器自己的访问速度快很多，但是受自身内存限制，往往不太适用。远程分布式缓存使用一个集群专门负责缓存服务，当内存不够还可以轻松得动态扩容。<br><img src="/images/web-server-3.png" alt="web-server-3"><br>HINT：</p><ul><li>缓存是个可以分很多层级的事情<ul><li>全局级别。比如全局的通知，这类东西全局缓存一份就可以。</li><li>页面级别。每个页面缓存一定时间，挡掉别人的连续刷新打库。浏览器也有类似机制。</li><li>模块级别。比如某些资源的计数器，不是强一致性要求的功能一般可以这么做。</li><li>变量级别。最常见的缓存，推荐一篇文章<a href="http://coolshell.cn/articles/17416.html">缓存更新的套路</a></li></ul></li><li>常用的两个<a href="http://gnucto.blog.51cto.com/3391516/998509">Redis与Memcached</a><ul><li>redis 内存内核是单线程的，且支持事务，支持丰富的数据结构，不仅仅是全内存、有 swap 空间、支持 CoW 持久化数据。</li><li>memcached 更充分发挥 cpu 等硬件的潜力，有 cas 支持，吞吐量更大。</li><li>分布式集群方案<ul><li>同时支持 redis &amp; memcached：twitter 的方案 <a href="https://github.com/twitter/twemproxy">twemproxy</a>，NetFlix 的方案  <a href="https://github.com/Netflix/dynomite">Dynomite</a></li><li>memcached 方案：facebook 的 <a href="https://github.com/facebook/mcrouter">mcrouter</a>，已经过恐怖的线上流量验证，FB大部分数据直接扔里面</li><li>redis 方案：豌豆荚的<a href="https://github.com/CodisLabs/codis">Codis</a>，国内用的人比较多。</li></ul></li></ul></li></ul><h3 id="使用应用服务器集群改善网站的并发处理能力"><a href="#使用应用服务器集群改善网站的并发处理能力" class="headerlink" title="使用应用服务器集群改善网站的并发处理能力"></a>使用应用服务器集群改善网站的并发处理能力</h3><p>使用缓存后，数据访问压力得到了缓解，但是单一应用服务器能够处理的请求连接有限，在网站访问高峰期，应用服务器就成了整个网站的效率瓶颈。使用分布式集群是网站解决高并发、海量数据问题的常用手段。当一台服务器的处理能力和存储空间不足时，不要尝试去更换更强大的服务器，对大型网站而言，多么强大的服务器，都满足不了网站持续增长的业务需求。这种情况下，更恰当的做法是增加一台服务器分担原有服务器的访问及存储压力。 对网站架构而言，只要能通过增加一台服务器的方式改善负载压力，就可以以同样的方式持续增加服务器不断改善系统性能，从而实现系统的可伸缩性。通过负载均衡调度服务器，可以将来自用户浏览器的访问请求分发到应用服务器集群中的任何一台服务器上，如果有更多用户，就在集群中加入更多的应用服务器，使应用服务器的压力不再成为整个网站的瓶颈。应用服务器实现集群是网站可伸缩架构设计中较为简单成熟的一种，如下图所示：<br><img src="/images/web-server-4.png" alt="web-server-4"></p><ul><li>不同层面有不同做法<ul><li>LVS在操作系统层，构建虚拟服务器集群<ul><li>负责TCP/IP层的转发</li><li>实现负载均衡，与业务无关</li></ul></li><li>nginx 在应用层面<ul><li>nginx 支持反向代理，吞吐量极大，接近物理极限</li><li>提供页面级缓存，通过修改正则式和if-modified-since等 header 可以精准的控制过期策略</li><li>可以当文件服务器，通过修改X-Accel-Redirect等 header 可以完成身份认证</li></ul></li><li>docker 容器、微内核层面<ul><li>OpenStack 可以自建集群</li><li>Paas 平台可以直接用</li></ul></li></ul></li></ul><h3 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h3><p>网站在使用缓存后，使对大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作（缓存访问不命中、缓存过期）和全部的写操作都需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。 目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。网站利用数据库的这一功能，实现数据库读写分离，从而改善数据库负载压力。如下图所示：应用服务器在写数据的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库，这样当应用服务器读数据的时候，就可以通过从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离对应用透明。<br><img src="/images/web-server-5.png" alt="web-server-5"><br>HINT:</p><ul><li>最开始的场景是对单数据库的热备份，后来逐步发展成把读请求全部发到从库上</li><li>不适合强一致性数据，数据从主库复制到从库需要时间。如果强行等待，反而降低了响应时间。</li><li>主从只负责各自的读和写，一般场景是读多写少，通过多加读的从库增加读的性能。</li><li>综上，作者的观点我不认同。主从架构更多是是一种用于数据容错的高可用性解决方案，而不是一种处理高并发压力的解决方案。解决并发只能多数据库分表分库或者newSQL（用paxos 或者两段式提交）。</li></ul><h3 id="使用反向代理和-CDN-加速网站响应"><a href="#使用反向代理和-CDN-加速网站响应" class="headerlink" title="使用反向代理和 CDN 加速网站响应"></a>使用反向代理和 CDN 加速网站响应</h3><p>随着网站业务不断发展，用户规模越来越大，由于中国复杂的网络环境，不同地区的用户访问网站时，速度差别也极大。有研究表明，网站访问延迟和用户流失率正相关，网站访问越慢，用户越容易失去耐心而离开。为了提供更好的用户体验，留住用户，网站需要加速网站访问速度。主要手段有使用 CDN 和反向代理。如下图所示：<br><img src="/images/web-server-6.png" alt="web-server-6"><br>HINT：</p><ul><li>反向代理主要两个作用：安全+加速<ul><li>外部连接是接到反向代理服务器，这样对应用服务器更加安全。</li><li>对于可以缓存的东西，反向代理层可以增加自动化页面级别缓存</li></ul></li><li>CDN 内容分发网络<ul><li>根据网络流量和各节点的状况把用户请求导向离用户最近的服务节点上，让用户可就近取得所需内容</li><li>CDN 的分发能力很强很快，但是由于内容冗余和缓存，默认姿势是写入之后不可变，因此上 cdn 的东西一般要加一个摘要算法判断版本。</li></ul></li></ul><h3 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h3><p>任何强大的单一服务器都满足不了大型网站持续增长的业务需求。数据库经过读写分离后，从一台服务器拆分成两台服务器，但是随着网站业务的发展依然不能满足需求，这时需要使用分布式数据库。文件系统也一样，需要使用分布式文件系统。分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同业务的数据部署在不同的物理服务器上。如下图所示：<br><img src="/images/web-server-7.png" alt="web-server-7"><br>HINT:</p><ul><li>分布式文件系统<ul><li>最常用自建文件系统的应该是 HDFS ，云服务提供更好的对象存储服务</li><li><a href="https://linux.cn/thread-14527-1-1.html">常见的分布式文件系统介绍</a></li></ul></li><li>分布式数据库<ul><li>优先注意 CAP 原理，按照自己需要选择</li><li>这篇文章里面有一张图，大致说明了各个数据库如何取舍 cap <a href="http://www.cnblogs.com/hxsyl/p/4381980.html">分布式系统之CAP理论</a></li><li>Spanner，TiDB，PhxSQL，Oceanbase 这些 newSQL 在数据查询上和 MySQL 几乎没有区别，cap 上有一个比较不错的均衡点，它们基本上都可以解决95% 的 OLTP 场景和 70% 的 OLAP 场景。</li></ul></li></ul><h3 id="使用-NoSQL-和搜索引擎"><a href="#使用-NoSQL-和搜索引擎" class="headerlink" title="使用 NoSQL 和搜索引擎"></a>使用 NoSQL 和搜索引擎</h3><p>随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，网站需要采用一些非关系数据库技术如 NoSQL 和非数据库查询技术如搜索引擎。<br>NoSQL 和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。如下图所示：<br><img src="/images/web-server-8.png" alt="web-server-8"><br>HINT：</p><ul><li>绝大多数场景和情况，MySQL 加上 Memcache/Redis 已经够用，但是有一些场景用 noSQL 会有更好的效果。</li><li>业内用得比较多的 noSQL 基本介绍<ul><li><a href="http://www.infoq.com/cn/news/2014/01/12-free-and-open-source-nosql">12款免费与开源的NoSQL数据库</a></li><li><a href="http://blog.jobbole.com/1344/">8 种 NoSQL 数据库系统对比</a></li></ul></li><li>我说说我用过的和仔细看过介绍的的几款<ul><li>MongoDB。非常火的文档数据库，360、github、几乎所有的大前端团队都用 mongo 来存数据。本身结构无 schema，可以快速 restful，支持基本的索引。</li><li>Redis。数据结构数据库。独特的性质决定用法多样，从队列到计数器，到秒杀系统，各种地方都有它的身影。</li><li>memcached。经典缓存框架，成熟的大公司要么自己就用 memcache，要么实现了一套类似的 kv 内存存储数据库，吞吐量极高。</li><li>Neo4j。图数据库市场上的唯一选择。做复杂的 join 操作极快。本身提供的cypher就是一种图结构的抽象。赤兔的关系链用的这个数据库。</li><li>HDFS/HBase。适合存海量的文件/行数据。几乎是 Apache 生态的基石，Zoomkeeper，MapReduce，kafka 等很多框架存储数据都是用的 hbase。</li></ul></li><li>搜索和推荐<ul><li><a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/">Elasticsearch</a>应该是业内用得最多的搜索开源框架，基于<a href="https://www.ibm.com/developerworks/cn/java/j-lo-lucene1/index.html">Lucene</a>工具包建全文索引，自带分布式、近实时索引、Schema-Free、RESTful api、面向文档设计等。</li><li>开源推荐系统相对要多一些。我只用过Mahout 里的 itemBase 推荐算法，已经实现好并留下了接口，只需要去覆盖几个函数就能运行。</li><li>机器学习框架，TensorFlow，Torchnet。这俩没玩过，之后有机会仔细研究一下。</li></ul></li></ul><h3 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h3><p>大型网站为了应对日益复杂的业务场景，通过使用分而治之的手段将整个网站业务分成不同的产品线。如大型购物交易网站都会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责。具体到技术上，也会根据产品线划分，将一个网站拆分成许多不同的应用，每个应用独立部署。应用之间可以通过一个超链接建立关系（在首页上的导航链接每个都指向不同的应用地址），也可以通过消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统，如下图所示：<br><img src="/images/web-server-9.png" alt="web-server-9"><br>HINT：</p><ul><li>上面的架构图里出现的最重要的一个东西就是消息队列，之前数据状态变化必须写数据库，有了队列就可以有新的设计方法。八字真言：削峰解耦，提速广播。<ul><li>削峰。消息队列可以帮助抹平峰值，给架构带来巨大弹性</li><li>解耦。复杂任务、耗时任务可以用更好的方式拆解，对应可以为架构带来非常多的可能性</li><li>提速。同样配置服务器下，大部分消息队列的吞吐量都大于 MySQL。像 kafka 这种自带内存 buffer 的队列速度更快。</li><li>广播。可以由队列在协议层完成广播，比自己轮转通知效率高很多。</li></ul></li><li>常见队列介绍<a href="http://techlog.cn/article/list/10182733">常用消息队列介绍与对比</a><ul><li>我用过 RabbitMQ 和 kafka，两个都是可持久化队列。RabbitMQ是一个很重也很全的分布式队列，当年 OJ 用它来分发判题任务，跨语言实时队列用这个不错。kafka主要场景还是离在线混合任务，比如线上有了访问记录，可以用 kafka 来驱动一个计算函数更新某些数值。然后就是听说 nsq 不错，但是我没用过。</li><li>QPS 1W以下用什么队列都一个样，如果慢肯定是用搓了，高于这个了就得关注关注各家特点了。</li></ul></li></ul><h3 id="分布式服务"><a href="#分布式服务" class="headerlink" title="分布式服务"></a>分布式服务</h3><p>随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难。由于所有应用要和所有数据库系统连接，在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方，导致数据库连接资源不足，拒绝服务。既然每一个应用系统都需要执行许多相同的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作。大型网站的架构演化到这里，基本上大多数的技术问题都可以得以解决了。<br>如下图所示：<br><img src="/images/web-server-10.png" alt="web-server-10"><br>HINT：</p><ul><li>架构演化到这个地方，最重要的事情是 RPC 和服务治理<ul><li>RPC生态一般要有序列化反序列化工具、数据交换协议、跨语言的自动生成工具等</li><li>服务治理一般要有监控系统、自动化上线回滚系统、负载均衡、版本容错等等</li></ul></li><li>我只做过序列化，没有做过服务治理，大致看过一些资料，欢迎pr这几节。<ul><li><a href="http://www.grpc.io/">gRPC</a>： 用 google 的 protobuf 序列化，<a href="https://github.com/grpc-ecosystem/go-grpc-prometheus">grpc服务治理</a>，包括企鹅在内的很多公司在用protobuf，然后 rpc 框架用自研的。</li><li><a href="http://dubbo.io/">dubbo</a>：阿里和阿里浪在用的 rpc 框架，当你负责人去过北邮校赛讲座，当年没觉得这哥们多牛逼，现在觉得真特么碉堡了。</li><li><a href="https://thrift.apache.org/">thrift</a>：Facebook 在用的 rpc 框架，应该是目前多语言支持最好的框架。某头条也在用这个。</li><li><a href="https://github.com/phunt/avro-rpc-quickstart">avro</a>：Apache 系的东西，很多数据分析的人喜欢这个玩意，不明觉厉。</li></ul></li></ul><h2 id="若干个人观点"><a href="#若干个人观点" class="headerlink" title="若干个人观点"></a>若干个人观点</h2><ul><li>只有系统复杂度到了这后面两三步了才有必要开始用 docker 这些 LXC 工具，初期十来二十台服务器直接脚本化就可以解决大部分问题。</li><li>如果基于云的 SaaS 做架构，很多事情会简单很多，甚至一步到位。国外三四十个人撑起十几亿美金估值靠的就是这种结构。运维的压力和系统的风险指数级减少。</li><li>架构师不会失业，各个部件需要多少容量，这个事情接下来很多年还是需要有经验的工程师来做，每家公司也都会有需求。但是大部分 DBA 类的职位危险了。</li><li>搞存储之类的事情，将来只有大厂和云服务商有需求。剩下的工程师会逐步转变成全栈工程师，以业务为基石来调用各种平台的 API，不需要专门一个后台/后端工程师来帮助产后端接口。</li><li>FB 鼓励刚毕业的人做”全栈”工程师，足够了解整个栈且技术素养发展到一定阶段再去选择深入的方向。<ul><li>同样的一个功能在不同技术栈上由同一个人完成，沟通的成本比七八个人同时工作要低</li><li>设计师的工作范围变宽，各种设计工具<a href="https://juejin.im/entry/5902b801a22b9d0065cd0ada">React-SketchApp</a>帮助生成对程序员更友好的设计稿</li><li>运维架构后端工程师来管理诸如数据库 Schema、自动化流程、开发工具等基础性工具和规范。</li><li>中间的部分归全栈工程师管：自己定数据库 schema，自己定表单验证方式，自己定前端交互数据流，自己定在哪个位置渲染，连接设计师的各种细节。</li></ul></li><li>安卓和 iOS 如果使用 react-native 或者 weex 可以进一步加速研发流程。</li><li>最后来个鸡汤：<a href="http://blog.jobbole.com/97985/">如何成为一名优秀的全栈工程师？</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍 web 服务器基本概念，和常见的服务端演替路线。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Backend" scheme="https://wangzitian0.github.io/tags/Backend/"/>
    
    <category term="Architecture" scheme="https://wangzitian0.github.io/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>如何理解Web框架</title>
    <link href="https://wangzitian0.github.io/2017/06/19/How-to-understand-web-framework/"/>
    <id>https://wangzitian0.github.io/2017/06/19/How-to-understand-web-framework/</id>
    <published>2017-06-19T05:21:00.000Z</published>
    <updated>2020-09-30T04:59:07.878Z</updated>
    
    <content type="html"><![CDATA[<p>Web 应用框架，或者简单的说是“Web 框架”，是建立 web 应用的一种方式。在此之前希望已经了解这篇文章的内容 <a href="https://wangzitian0.github.io/2017/06/16/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5RESTful/">HTTP协议的的最佳实践RESTful</a>。</p><a id="more"></a><h2 id="为什么会需要框架"><a href="#为什么会需要框架" class="headerlink" title="为什么会需要框架"></a>为什么会需要框架</h2><p>很多人把会一个框架当做 web 工程师的必要条件，但是实际上的理解并不到位。要真的理解框架，需要理解下面的这些东西。<br>web 技术的发展其实是有这样一个路径的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">源码&lt;-&gt;最佳实践&lt;-&gt;设计模式</span><br><span class="line">协议-&gt;SDK-&gt;类库-&gt;框架-&gt;架构</span><br></pre></td></tr></table></figure><h2 id="虚路径"><a href="#虚路径" class="headerlink" title="虚路径"></a>虚路径</h2><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最佳实践(best practice)，是一个管理学概念，</span><br><span class="line">认为存在某种技术、方法、过程、活动或机制可以使生产或管理实践的结果达到最优，并减少出错的可能性。</span><br></pre></td></tr></table></figure><p>典型的例子如 <a href="http://coolshell.cn/articles/17416.html">缓存更新的套路</a>。<br>大致是说”先删除缓存，然后再更新数据库，而后续的操作会把数据再装载的缓存中。“是逻辑是错误的。</p><p>两个并发操作，一个是更新操作，另一个是查询操作。更新操作删除缓存后，查询和操作同时发生，且同时艹库，如果是先更新，后查询的没有问题。但是如果先查询完成后更新完成，查询结果被缓存导致缓存中的数据是脏的，而且还一直这样脏下去了。</p><p>最常用最常用的缓存实践，对于绝大多数应用使用这个方案就够了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</span><br><span class="line">命中：应用程序从cache中取数据，取到后返回。</span><br><span class="line">更新：先把数据存到数据库中，成功后，再让缓存失效。</span><br></pre></td></tr></table></figure><p>这种做法还是有可能有脏数据，那就是数据库更新完成之后，缓存失效之前，但是这种数据最多脏这一小会，宏观上可以接受，大部分应用少数几秒的一致性降低不会导致用户体验变差。</p><p>缓存更新的实践是非常老古董的，而且历经长时间考验的策略，从mysql数据库到memcache/redis，很多东西是计算机体系结构里的设计。类似的还有CPU的缓存，硬盘文件系统中的缓存，硬盘上的缓存，数据库中的缓存。</p><p>进一步要求，有的时候这种设计经常某一瞬间穿透缓存，满足不了需求的时候，可以用一个队列来分开读写，把压力强行挡在数据库外面。</p><p>工程学上所谓的Best Practice有些东西需要细想才会发现精巧。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。</span><br><span class="line">设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。</span><br><span class="line">这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</span><br></pre></td></tr></table></figure><p>最佳实践进一步抽象就是设计模式，有些东西已经编程语言或者框架已经实现了，所以我们并不需要完完全全了解实现原理，只需看看文档就能使用。只说说我印象深刻的几个：</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p>几乎大家都知道或者用过 MVC 模式，本质上就是一个观察者模式和其他模式结合的的高级抽象。实质上还是把数据和行为进行分离，M其实也相当于观察者模式中的被观察者，Ｖ相当于观察者。</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>意图：创建具有现有对象的对象，以便向外界提供功能接口。为其他对象提供一种代理以控制对这个对象的访问。</p><p>MySQL 设计的时候会有 oneToOneField，提供一个外键来访问某个对象。</p><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p>做一个事情前和后分别加点事情，给一个对象添加一些额外的方法，而且可以不改变调用方。不用把新的逻辑注入到原始代码里。</p><h4 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h4><p>意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>比如 RPC 框架做一些基础服务，帮助开发者看哪些服务活着，压力如何，然后分配流量，又比如 web 框架里的中间件，所以的请求都需要经过一遍中间件，有效的减少层与层之间的交叉调用。</p><p>其他的去看书吧… 总之，设计模式&amp;最佳实践&amp;代码是相互作用的，相互促进螺旋上升，随着计算机学科的发展大致变成了现在的样子。这几年互联网架构的发展，本质上还是这些模式，但是形式变成了在廉价集群上实现，重点变成了兼容不可靠设备。</p><h2 id="实路径"><a href="#实路径" class="headerlink" title="实路径"></a>实路径</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">网络传输协议或简称为传送协议（Communications Protocol），是指计算机通信或網路設備的共同语言。 </span><br><span class="line">现在最普及的计算机通信为网络通信，所以“传送协议”一般都指计算机通信的传送协议。</span><br><span class="line">如：TCP&#x2F;IP、NetBEUI、DHCP、FTP等。</span><br></pre></td></tr></table></figure><p>TCP 之类就不说了，资料太多了。拿序列化这件事情来说，有了协议，各种语言才会无障碍通信。内存对象包含各种地址和指针，传输和存储的试试需要去除这种机器相关的影响，只关注数据和数据的关联，转化为字符串，这个过程叫做序列化。字符串变成内存里的可执行可操作的对象，叫做反序列化。</p><p>Json 是序列化协议，XML 是序列化协议，而且对人类友好，数据的结构可以肉眼轻松的看出来。</p><p>ProtoBuf 和 Thrift 也是序列化协议，但是底层使用更高效的二进制协议，而且官方有 gRPC 框架和Thrift RPC框架来帮助开发者做一些诸如服务发现、负载均衡的工作，能够很好的减少前后端之间数据交换、各种基础计算服务调用的麻烦程度。</p><ul><li><a href="http://jsonapi.org.cn/format/">Json怎么写</a></li><li><a href="http://www.jianshu.com/p/xNasBo">XML怎么写</a></li><li><a href="http://www.iloveandroid.net/2015/10/08/studyPtorobuf/">ProtoBuf怎么写</a></li><li><a href="http://dongxicheng.org/search-engine/thrift-guide/">Thrift怎么写</a></li></ul><p>协议本身制定是为了更好的序列化反序列化，又比如 http 协议，公认的最佳实践是 restful API，可以看看开篇介绍的另一篇博客。</p><p>又比如HTML5的协议，由 RFC 文件来规定，由浏览器厂商来执行。典型的HTML 协议文档可以看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5">Mozilla的文档</a></p><h3 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">软件开发工具包（Software Development Kit, SDK）一般是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、作業系统等建立应用软件的开发工具的集合。</span><br></pre></td></tr></table></figure><p>典型的如 <a href="https://developer.android.com/studio/index.html">安卓SDK</a></p><p>里面包括很多的工具、API文档、本地编译包、IDE 等等很多东西。根据官方文档的描述，开发必须下载的东西有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SDK Tools 必须</span><br><span class="line">SDK Platform-tools 必须</span><br><span class="line">SDK Platform必须至少安装一个版本</span><br><span class="line">System Image建议安装</span><br><span class="line">Android Support建议安装</span><br><span class="line">SDK Samples建议安装</span><br></pre></td></tr></table></figure><p>开源世界目前以 Github 为核心，模式稍微有一些变化。SDK 被拆解到各个地方，比如 npm 来帮助管理各种依赖和版本，然后文档直接放到 Github 相关的文档里，源码直接使用 git 下载而不一定发布打包集成版。</p><h3 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类库(Class Library)是一个综合性的面向对象的可重用类型集合，这些类型包括：接口、抽象类和具体类。</span><br></pre></td></tr></table></figure><p>写过 C++ 的人都一定熟悉STL，集成了常用的内存数据结构和常用算法。实现的效率都不错，接口也很通用。有了这些类库，很多重复性的工作被省略。</p><p>写 JavaScript 的程序员有一部分是只会 jQuery 的，由于 jQuery 的封装十分简单，且给每个对象都加入了一些常用的方法，不需要再去记复杂的 api，大大提高了开发效率。</p><p>刚才两个例子都是外部实现的标准组件，STL 根据编译器配置不同可以使用 Boost 或者 SGI 版本，g++ 编译器支持一套 linux 上肯定能跑的 STL。jQuery 干脆直接由程序员自己来引入，本身完全没有放入 JavaScript 体系。</p><p>有一个神奇的存在，那就是 Golang，你可以先看看 <a href="http://studygolang.com/pkgdoc">Golang Libs 文档</a>，由于 Golang 是一个完全现代化的语言，出现时间晚，因此很多 web 世界用到的东西，直接被官方支持的类库收录和实现了。包括不限于用来控制并发的互斥锁，用来数据共享管道channel，自带的json序列化反序列化工具等等。第三方实现的东西往往没有语言原生就实现靠谱和稳定，正因如此 golang 在 web 开发世界迅速崛起。</p><p>一般来说，我们说一个语言的生态好不好，主要是指它的类库多不多，其次才看对应的文档是否充要&amp;社区是否活跃。</p><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Web应用框架（Web application framework）是一种开发框架，用来支持动态网站、网络应用程序及网络服务的开发。</span><br></pre></td></tr></table></figure><p>按照我的理解，框架和类库最重要的区别是控制权的不同。</p><p>使用框架像是装饰一颗圣诞树，树干在那个地方且已经定型，你能做的就是往上面装东西，使它能完成装饰的作用。而类库是为了解决重复性工作的方法和工具，装饰圣诞树的时候需要批量给礼物打包、分类、挂上钩子，类库就像是能快速整洁的打包工具、扔进去礼物就会打乱的桶、批量把钢丝捏成钩子的钳子。</p><p>web 开发来说，框架的控制权在框架手上，你是按照框架的体系和规范去往里面添加东西，由它来调用你的代码。类库的控制权在你手中，类库只是帮你封装好了大量实用的函数，帮助你实现自己的目的，你通过调用类库来避免重复造轮子。</p><p>两者都是为了提高自己的研发效率，但是是不同的层面，类库和框架一般都是混合在一起用的。</p><p>框架涉及到一个流派之争Rails Like vs Sinatra Like</p><h4 id="Rails-Like"><a href="#Rails-Like" class="headerlink" title="Rails Like"></a>Rails Like</h4><p>典型代表: Rails(Ruby), Django(Python), Sails(JavaScript), Revel(Golang)</p><ul><li>编程要爽。可以甩锅给工具的事情就不要接，应该专注于造东西，快速的做出 MVP 的产品。例子：写好配置，帮你生成基本的增删改查API，你不需要去想 SQL 怎么写比较优美。</li><li>约定优于配置（CoC），主张大部分都这么做，那框架就这么做吧，有问题你自己去该配置得了。例子：数据库的模型叫做 Problem，那么模板就放problem_tmp，业务放在 ProblemView 里面，你可以填充自动生成的migration文件，然后数据库里存的表名默认使用 problem_migration1。</li><li>主厨精选。吃饭要相信营养大师的选择，web 开发也一样，大师你默认给我个全家桶吧。例子：ORM 直接由框架提供好了，数据库由大师去做匹配，然后支持常见的关系型数据库。</li></ul><h4 id="Sinatra-Like"><a href="#Sinatra-Like" class="headerlink" title="Sinatra Like"></a>Sinatra Like</h4><p>典型代表 Sinatra(Ruby), Flask(Python), Express(JavaScript), Gin(Golang)</p><ul><li>编程要自由。我想怎么用其他的库就怎么用，只要是语言能支持的都可以，这样能够根据我的需要选择最合适的技术。例子：Flask 你可以使用ORM 工具，SQLAlchemy来同时支持MySQL/PostgreSQL/MSSQL/sqlite3 等数据库，也可以使用Flask-PyMongo来支持 mongoDB 这样的 noSQL，总之，想用啥用啥。</li><li>我们不需要令人生厌的模式（WDNNSP）。我只想吃根黄瓜，你非得给我一个果篮，其他水果挺浪费的，还贵。例子：我只是搭建一个 Restful API 服务器，并不需要模板引擎，除了 join 数据没有复杂的操作，因此不需要太复杂的中间件，这种时候 Django 这样的框架远远么有 Flask 灵活。</li><li>我需要一个极速的框架。对于大公司而已，效率是一件非常非常重要的事，有的时候为了效率需要牺牲一部分优美值和愉快值。例子：假设我们要框架返回一个不查库的页面（只用到路由绑定和少数变量模板渲染），gin 这个单机随便扛 2W QPS 请求，同样配置的 Django 做同样的事情只能扛2K QPS。</li></ul><p>两派其实差别并没有想象中大。到了一定程度会变得折中。Rails Like的框架把影响效率的模块换成更快的，但是保留着基本的配置准则。而Sinatra Like的框架写多了代码就会把不该重复的地方抽象成新对象，慢慢会形成优美代码准则。 Django 这样慢吞吞的框架也能撑起 Instagram 这样的巨型公司，Flask 在很多小公司用得非常愉快。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Architecture is like teenage sex，everybody talks about it，nobody really knows what is it。</span><br></pre></td></tr></table></figure><p>我理解的架构，一方面是根据要解决的问题，对目标系统的边界进行界定，然后切分功能，最后让各个功能可以有一个沟通机制。另一方面是保证性能和可以性作出的设计。</p><p>前者使得每个部分的功能可以相对独立，也就是高内聚低耦合：</p><ul><li>像 Linux 这样的操作系统，需要有好的架构。具体来说，一个精简的不容易出错的内核来负责核心的抽象操作，一系列适应硬件的驱动程序来实际操作，一系列中间层软件包负责集成 API，最后是应用层，只需要关注继承号的 API。</li><li>互联网大型 Web 系统更加需要好的架构。一个核心的数据库来记录一切，各种级别的缓存系统提供高性能的访问，CDN 来负责静态的重复的资源的分发，异步队列来拆解耗时的操作，监控、回滚系统来保证可用性和持续的集成。</li></ul><p>后者如大型互联网应用使用各种开源工具：</p><ul><li>普通 PC 需要知道的几个数据，可能有误差，但是数量级不会错。<ul><li>内存。响应时间可以忽略不计，吞吐量可以到 1e8-1e9 IOPS、读写5Gbps。</li><li>机械硬盘。响应时间需要 5-10 ms，吞吐量可以到 100-300 IOPS，读200Mbps，写50Mbps。</li><li>SSD。响应时间也是需要 5-10 ms，吞吐量可以到 5-10W IOPS，读写400-1000Mbps。</li></ul></li><li>web 后端需要记住的数字<ul><li>关系型数据库，如MySQL 5-10K QPS</li><li>noSQL，事务方面支持差一些，如mongoDB，10-20K QPS</li><li>经典的队列，如RabbitMQ/NSQ  10-30K QPS</li><li>数据结构服务器，如Redis 10-50K QPS</li><li>内存服务器，如Memcached 100-300K QPS</li><li>buffering队列，Kafka 100-300K QPS</li></ul></li></ul><h2 id="框架做了哪些事"><a href="#框架做了哪些事" class="headerlink" title="框架做了哪些事"></a>框架做了哪些事</h2><p>它们接收 HTTP 请求，分派代码，产生 HTML，创建带有内容的 HTTP 响应。事实上，所有主流的服务器端框架都以这种方式工作的（ JavaScript 框架除外）。但愿了解了这些框架的目的，你能够在不同的框架之间选择适合你应用的框架进行开发。</p><h3 id="路由和模板、表单"><a href="#路由和模板、表单" class="headerlink" title="路由和模板、表单"></a>路由和模板、表单</h3><p>围绕建立 web 应用的所有问题中，三个核心问题尤其突出：</p><ul><li>我们如何将请求的 URL 映射到处理它的代码上？</li><li>我们怎样动态地从数据库中取信息构造请求的 HTML 返回给客户端？</li><li>前端产生的数据后端如何拿到，并根据需要进行存储？</li></ul><p>三个问题的答案就是标题，研究一个框架也是先研究这三个问题。</p><p>每个 web 框架都以某种方法来解决这些问题，也有很多不同的解决方案。用例子来说明更容易理解，所以我将针对这些问题讨论 Django 的解决方案。</p><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p>处理请求 URL 到负责生成相关的 HTML 的代码之间映射的过程。核心问题主要有两个，一个是准确的调用对应的代码，另一个是如何将Request 里数据传递给对应的代码。</p><h5 id="Django-中的路由"><a href="#Django-中的路由" class="headerlink" title="Django 中的路由"></a>Django 中的路由</h5><p>urls.py来指定 url 绑定某个函数或者某个 url 根绑定某个模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">from django.contrib import admin</span><br><span class="line">from app1 import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">  url(r&#39;^index&#x2F;$&#39;, views.index),</span><br><span class="line">  # 访问 http:&#x2F;&#x2F;host&#x2F;index ， 框架会帮助调用views模块里的index函数</span><br><span class="line">  url(r&#39;^admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">  # 访问 http:&#x2F;&#x2F;host&#x2F;admin&#x2F; ，会把admin.site.urls里的集成的路由引入</span><br><span class="line">  url(r&#39;^app1&#x2F;&#39;, include(&#39;app01.urls&#39;)),</span><br><span class="line">  # http:&#x2F;&#x2F;host&#x2F;app1 ， 会把app01模块里的路由引入</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>app1/urls.py，用来处理请求的url，使之与views建立映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns &#x3D; [</span><br><span class="line">  url(r&#39;index&#x2F;$&#39;, views.index),</span><br><span class="line">  # http:&#x2F;&#x2F;host&#x2F;app1&#x2F;index ，请求先被上面那个文件里的代码分发，框架会帮助调用app1.views模块里的index函数</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="传参形式的动态路由"><a href="#传参形式的动态路由" class="headerlink" title="传参形式的动态路由"></a>传参形式的动态路由</h3><p>利用正则表达式的分组方法，将url以参数的形式传递到函数，可以不按顺序排列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns &#x3D; [</span><br><span class="line">  url(r&#39;^user_list&#x2F;(?P&lt;v1&gt;\d+)&#x2F;(?P&lt;v2&gt;\d+)$&#39;,views.user_list),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>(?P<v1>\d+)<br>这是一个 Django 的正则表达式的分组，P 是指定参数类型，传递的数据相当于一个字典， key=v1, value=\d+。 {“v1”:”\d+”}</p><p>然后将此参数传递到views里对应的函数，可以不按照顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def user_list(request,v2,v1):</span><br><span class="line">  return HttpResponse(v1+v2)</span><br></pre></td></tr></table></figure><p>参数v1 = (?P<v1>\d+)</p><p>参数v2 = (?P<v2>\d+)</p><h4 id="模板template"><a href="#模板template" class="headerlink" title="模板template"></a>模板template</h4><p>我们可以从不同的来源先收集数据，然后进行处理，最后得到一个数据集。<br>现在是要把数据集变成 HTML 源码。</p><p>典型的代码hello.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def hello(request):</span><br><span class="line">    context          &#x3D; &#123;&#125;</span><br><span class="line">    context[&#39;hello&#39;] &#x3D; &#39;Hello World!&#39;</span><br><span class="line">    return render(request, &#39;hello.html&#39;, context)</span><br></pre></td></tr></table></figure><p>典型的模板 hello.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;&#123;&#123; hello &#125;&#125;&lt;&#x2F;h1&gt;</span><br></pre></td></tr></table></figure><p>这时页面会把 py 代码里面对应的字符串填充进 html 模板里面。</p><p>大量经典的模板包括简单的判断语句和循环语句，还包括helper function，你可以在模板当中调用 py 的 函数来生成更加复杂的 html。</p><p>PS：现代的框架流行前后端分离，这个步骤往往在前端完成，后端直接把数据序列化之后传递给前端。</p><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p>表单可以用来前端给后端服务器提交数据。</p><p>request 是一个 Python 的经典库，里面对 http 进行了一个不错的封装，常用的函数和数据都被转换成 Python 对象，我们可以用 Python 的代码来得到一个 request 里面对应的 URL param 和 form data、COOKIES、meta 等等各种数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 接收请求数据，并返回一条消息</span><br><span class="line">def search(request):  </span><br><span class="line">    request.encoding&#x3D;&#39;utf-8&#39;</span><br><span class="line">    if &#39;q&#39; in request.GET:</span><br><span class="line">        message &#x3D; &#39;你搜索的内容为: &#39; + request.GET[&#39;q&#39;]</span><br><span class="line">    else:</span><br><span class="line">        message &#x3D; &#39;你提交了空表单&#39;</span><br><span class="line">    return HttpResponse(message)</span><br><span class="line">    </span><br><span class="line"># 接收POST请求数据，并且使用post.html模板渲染返回值</span><br><span class="line">def search_post(request):</span><br><span class="line">    ctx &#x3D;&#123;&#125;</span><br><span class="line">    if request.POST:</span><br><span class="line">        ctx[&#39;rlt&#39;] &#x3D; request.POST[&#39;q&#39;]</span><br><span class="line">    return render(request, &quot;post.html&quot;, ctx)</span><br></pre></td></tr></table></figure><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>很多网站会使用关系型数据库来存储数据。你可以自己使用 SQL 来实现增删改查。这里拿 ORM 来举例</p><h4 id="Django-Model"><a href="#Django-Model" class="headerlink" title="Django Model"></a>Django Model</h4><p>一个典型的 Django 模型 ORM</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line">class Group(models.Model):</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;128)</span><br><span class="line">    members &#x3D; models.ManyToManyField(Person, through&#x3D;&#39;Membership&#39;)</span><br><span class="line"></span><br><span class="line">    def __str__(self):              # __unicode__ on Python 2</span><br><span class="line">        return self.name</span><br></pre></td></tr></table></figure><p>只需要几行简单的命令，常见的数据库增删改查以及关系型数据库特有的join、order_by等SQL由框架去生成，我们只需要关注它留给我们的 Python API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Post.objects.create(author&#x3D;me, title&#x3D;&#39;Sample title&#39;, text&#x3D;&#39;Test&#39;)</span><br><span class="line">User.objects.get(username&#x3D;&#39;ola&#39;)</span><br><span class="line">Post.objects.all()</span><br><span class="line">Post.objects.filter(author&#x3D;me)</span><br><span class="line">Post.objects.filter(title__contains&#x3D;&#39;title&#39;)</span><br><span class="line">Post.objects.order_by(&#39;created_date&#39;)</span><br><span class="line">Post.objects.filter(published_date__lte&#x3D;timezone.now()).order_by(&#39;published_date&#39;)</span><br></pre></td></tr></table></figure><h4 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h4><p>django 中有一种叫做ModelForm的东西，当你生成了一个 Model 之后，只需要简单的指定 fields，它会根据 fields 来生成表单。</p><p>按照先读取Model里指定的类型，然后再去Form里面读取选项，最后生成 包含 form 的 HTML 模板。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class PostForm(forms.ModelForm):</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; Post</span><br><span class="line">        fields &#x3D; (&#39;title&#39;, &#39;text&#39;,)</span><br></pre></td></tr></table></figure><p>验证表单&amp;存储数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def post_edit(request, pk):</span><br><span class="line">    post &#x3D; get_object_or_404(Post, pk&#x3D;pk)</span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">        form &#x3D; PostForm(request.POST, instance&#x3D;post)</span><br><span class="line">        if form.is_valid():</span><br><span class="line">            post &#x3D; form.save(commit&#x3D;False)</span><br><span class="line">            post.author &#x3D; request.user</span><br><span class="line">            post.published_date &#x3D; timezone.now()</span><br><span class="line">            post.save()</span><br><span class="line">            return redirect(&#39;post_detail&#39;, pk&#x3D;post.pk)</span><br><span class="line">    else:</span><br><span class="line">        form &#x3D; PostForm(instance&#x3D;post)</span><br><span class="line">    return render(request, &#39;blog&#x2F;post_edit.html&#39;, &#123;&#39;form&#39;: form&#125;)</span><br></pre></td></tr></table></figure><p>表单的提交一般通过 POST 请求，pk是数据的主键，post是根据 pk 读取的现在的数据库里的数据，PostForm根据request.POST里的 form data进行表单验证，如果合法则保存数据的author和published_date被存进数据库。</p><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>事实上，很多请求有相似的需求，比如验证一个人的登陆状态，如果我们每个函数都写一个验证，不符合 DRY 原则也不优美。</p><p>这个时候引入一个概念：中间件。由中间件来负责做这些重复的事情，Django 中间件的具体做法是：</p><p>在请求阶段中，调用视图之前，Django会按照MIDDLEWARE_CLASSES中定义的顺序自顶向下应用中间件。在响应阶段中，调用视图之后，中间件会按照相反的顺序应用，自底向上。</p><p>中间件处理 request实现这两个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">process_request()</span><br><span class="line">process_view()</span><br></pre></td></tr></table></figure><p>处理 response 实现这三个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process_exception()（仅当视图抛出异常的时候）</span><br><span class="line">process_template_response()（仅用于模板响应）</span><br><span class="line">process_response()</span><br></pre></td></tr></table></figure><p>你可以想象一下一个典型场景，我需要通过 csrf_token 来唯一辨认用户，现在服务器每次接受请求的时候需要验证这个参数，如果参数不对要直接报错。参数对了，又需要在返回请求的时候在相应的header 里面再次写上 token，这种事情就非常适合由中间件来做。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES &#x3D; (</span><br><span class="line">    &#39;django.contrib.sessions.middleware.SessionMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.common.CommonMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.auth.middleware.SessionAuthenticationMiddleware&#39;,</span><br><span class="line">    &#39;django.contrib.messages.middleware.MessageMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;,</span><br><span class="line">    &#39;django.middleware.security.SecurityMiddleware&#39;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>很多事情中间件都能做，具体的可以去查看你在学的框架文档和源码。</p><h3 id="Serverless-架构"><a href="#Serverless-架构" class="headerlink" title="Serverless 架构"></a>Serverless 架构</h3><p>由于云服务的发展，现在 web 开发常见的需求，很多原来需要消耗人力的特性都可以直接使用云服务。现在的一个趋势是 <a href="https://serverless.com/framework/docs/providers/aws/">Serverless</a> ，大致意思是就是以函数为基本单位来部署功能。由集群根据这些函数的资源调用历史来分配对应的计算服务。</p><ul><li>数据库存储，基于 Paxos 的 NewSQL 现在几乎每家都支持，可以理解为无限大的 MySQL</li><li>缓存服务器，云服务商实现好集群，我们只需要考虑需要的内存大小，不需要花精力去考虑一致性，得到一个可以按需扩张的超大缓存服务器。</li><li>CDN 存储，前端需要用的视频，css 等文件，可以通过 cdn 网络来快速下发。</li><li>图片存储，云服务的图片存储很好用，url 指定一下大小、格式就能直接返回符合要求的图片</li><li>log 服务，帮助你做 tracking，分析产品的使用情况，收集各个地方产生的 bug/error。</li><li>持续集成，你只需要指定自己的函数依赖的函数对应的版本区间，服务发现会自动去寻找对应的服务生成调用链。</li><li>充分利用资源和硬件特点部署函数，比如大数乘法，我们可以使用 FPGA 来做傅里叶变换，比 CPU 可能要快上一千倍。</li><li>机器学习和大数据分析。AWS 直接开放了对应的接口，只需要按照要求填写一部分 meta data，云服务直接帮你分析结果。</li></ul><p>结论，这个时间点学习架构一定是混合云架构。</p><p>也正是有了这些服务，国外才会有那种十几个人撑起日活几百万的现象级公司。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Web 应用框架，或者简单的说是“Web 框架”，是建立 web 应用的一种方式。在此之前希望已经了解这篇文章的内容 &lt;a href=&quot;https://wangzitian0.github.io/2017/06/16/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5RESTful/&quot;&gt;HTTP协议的的最佳实践RESTful&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTML" scheme="https://wangzitian0.github.io/tags/HTML/"/>
    
    <category term="Framwork" scheme="https://wangzitian0.github.io/tags/Framwork/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议的最佳实践RESTful</title>
    <link href="https://wangzitian0.github.io/2017/06/16/HTTP-best-practice-RESTful/"/>
    <id>https://wangzitian0.github.io/2017/06/16/HTTP-best-practice-RESTful/</id>
    <published>2017-06-16T06:44:00.000Z</published>
    <updated>2020-09-30T04:59:07.878Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下我学习 http 协议和 RESTful 最佳实践的学习过程。</p><a id="more"></a><blockquote><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p></blockquote><p>换句话说，http 的表现是文本，所有的数据都通过文本来体现，各个控制传输的参数也是文本来提现。（ps：http2协议是二进制协议，但是核心思想没有变）</p><h2 id="知识储备-amp-预备"><a href="#知识储备-amp-预备" class="headerlink" title="知识储备&amp;预备"></a>知识储备&amp;预备</h2><h3 id="what-happens-after-enter-url"><a href="#what-happens-after-enter-url" class="headerlink" title="what happens after enter url"></a>what happens after enter url</h3><p>首先要对整个 web 栈有一个理解，最典型的问题就是问自己，输入 url 到页面完整的完成，过程中发生了什么：<br><a href="https://github.com/skyline75489/what-happens-when-zh_CN">https://github.com/skyline75489/what-happens-when-zh_CN</a></p><h3 id="tcp-协议"><a href="#tcp-协议" class="headerlink" title="tcp 协议"></a>tcp 协议</h3><p><a href="http://www.jianshu.com/p/ef892323e68f">http://www.jianshu.com/p/ef892323e68f</a><br>理解一下 http 为什么是可靠连接</p><h3 id="osi-七层协议"><a href="#osi-七层协议" class="headerlink" title="osi 七层协议"></a>osi 七层协议</h3><p><a href="http://www.jianshu.com/p/4b9d43c0571a">http://www.jianshu.com/p/4b9d43c0571a</a><br>我们主要是在应用层使用 http 协议</p><h2 id="http主要特点"><a href="#http主要特点" class="headerlink" title="http主要特点"></a>http主要特点</h2><p>基础知识在这：<br><a href="http://www.jianshu.com/p/80e25cb1d81a">http://www.jianshu.com/p/80e25cb1d81a</a></p><p>现在的 web 框架本质上是对 http 的Request &amp;&amp; Response请求的封装。</p><h3 id="http-协议的Request和Response由哪几个部分组成？服务器和客户端如何相互确定需要的信息？"><a href="#http-协议的Request和Response由哪几个部分组成？服务器和客户端如何相互确定需要的信息？" class="headerlink" title="http 协议的Request和Response由哪几个部分组成？服务器和客户端如何相互确定需要的信息？"></a>http 协议的Request和Response由哪几个部分组成？服务器和客户端如何相互确定需要的信息？</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview">https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview</a></p><h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><p>http methed，请求方法。可以使动词方法 GET, POST，或者名词OPTIONS or  HEAD，协议头。定义一次请求想干啥。 </p><ul><li><a href="http://honglu.me/2015/07/13/%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84HTTP-header/">常用 header</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">常用 methed</a></li><li>header 的内容包括不限于缓存控制，语言，数据格式，用户身份认证等</li><li>header 里的重点  <a href="http://javascript.ruanyifeng.com/bom/cookie.html">cookies</a>，<a href="http://www.cnblogs.com/xinzhao/p/5099807.html">缓存控制策略相关 header</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">CORS 跨域相关的 header</a>，注意<a href="https://tools.ietf.org/html/rfc7231#section-5.3.2">Accept</a>和<a href="http://honglu.me/2015/07/13/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8DContent-Type/">Content-Type</a>的不同，一个是来一个是回。</li></ul><p>Path of resource，资源路径。 定义和标识需要操作的资源。包括一个协议头、地址、端口等。</p><ul><li>路径的的表示方法分为<a href="http://web.jobbole.com/83452/">url urn uri</a>。</li><li>常用的<a href="https://wsgzao.github.io/post/service-names-port-numbers/">协议和端口</a></li></ul><p>HTTP version，协议版本.</p><ul><li><a href="http://www.jianshu.com/p/52d86558ca57">优雅的谈论http版本</a></li></ul><p>Body，正文，比如 POST 请求，数据会放在 body 里。</p><ul><li><a href="https://imququ.com/post/four-ways-to-post-data-in-http.html">常见的 POST 提交数据</a>，<code>Content-Type</code>控制。</li></ul><h4 id="response"><a href="#response" class="headerlink" title="response"></a>response</h4><p>HTTP version，协议版本，同上。</p><p>Status code, 状态号，告知你请求是否成功，怎样成功或者失败。</p><ul><li><a href="http://www.runoob.com/http/http-status-codes.html">状态码</a></li></ul><p>Status message, 一段简单的文字状态描述。</p><p>HTTP headers,请求头，同上。</p><ul><li>header 进一步详细的的介绍可以看这个 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">mozilla docs</a> </li><li>对 header 如果很熟悉就可以试着去玩一下 Nginx，有各种通过正则式改写 header 和 url 的技巧</li><li>写 header 可以完成某些转发、跨域、缓存、身份验证、文件下载等需求。</li></ul><p>Body，应该返回的数据或者媒体资源文件。</p><ul><li>json 是 JavaScript 的经典数据描述，但是表示一个对象有更多的 <a href="http://www.infoq.com/cn/articles/serialization-and-deserialization">序列化和反序列化</a> 工具。</li></ul><h3 id="post-和-get-有什么区别？put-和-patch-有什么区别？"><a href="#post-和-get-有什么区别？put-和-patch-有什么区别？" class="headerlink" title="post 和 get 有什么区别？put 和 patch 有什么区别？"></a>post 和 get 有什么区别？put 和 patch 有什么区别？</h3><p>细节可以看这个<a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp">post&amp;get对比</a></p><p>post 和 get 设计上主要的区别是有没有幂等性，get执行一次和执行 n 次结果一样。符合范式的 get 应该是请求无数次后也不会改变服务器状态。其他的特性都是为了保障幂等性而做的限制：</p><ul><li>get 可以缓存，post 不能。因为执行 n 次对结果没有影响，那么只要记录一次，再执行 n 次结果也应该一样。</li><li>get 只能 ASCII 字符编码，数据以 param 的形式被编码进URL，而且有长度限制，是为了对数据进行更好的标识，方便缓存等行为。而 post 可以提交的数据类型可以是 multipart/form-data 甚至是 file存贮在 body 中，数据不会被暴露在 url 里。url 在传输的时候是不会对 header 和 url 进行加密的。</li><li>post 刷新之后数据会被重新提交，参数不会被保存在浏览器历史中，是为了防止 post被多次提交改变服务器状态。</li></ul><p>patch 是新版 http 协议里支持的方法，在RESTful里面，put 是把应该对象完整的放到 uri，而 patch 是对一个对象的部分属性进行更新。举个例子：<br>服务器有对象 {a:1, b:2},<br>请求 PUT {a:2} 之后，服务器的对象变为{a:2}。<br>请求 PATCH {a:2} 之后，服务器的对象变为{a:2, b:2}</p><h3 id="http协议栈如何分层，更高一层使用了哪些技术。"><a href="#http协议栈如何分层，更高一层使用了哪些技术。" class="headerlink" title="http协议栈如何分层，更高一层使用了哪些技术。"></a>http协议栈如何分层，更高一层使用了哪些技术。</h3><p><a href="http://blog.csdn.net/xijiaohuangcao/article/details/6105623">HTTP、TCP、UDP、Socket</a></p><h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><h3 id="what？"><a href="#what？" class="headerlink" title="what？"></a>what？</h3><h4 id="origin"><a href="#origin" class="headerlink" title="origin"></a>origin</h4><p>REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。</p><p>Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。</p><p>论文中给了很多的建议，以至于这些建议很多都已经成为开源世界的默认标准。</p><h4 id="define"><a href="#define" class="headerlink" title="define"></a>define</h4><p>REST，是Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。如果一个架构符合REST原则，就称它为RESTful架构。</p><h4 id="details"><a href="#details" class="headerlink" title="details"></a>details</h4><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息，它可以是一段文本、一张图片、一首歌曲、一种服务。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，然后 RESTful 现在定义了 一组能唯一标识资源的 path 和对资源进行的操作的一种规范，RESTful 架构的意思就是，满足与网上一系列资源互动的一组规范的架构。</p><h3 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h3><h4 id="scene"><a href="#scene" class="headerlink" title="scene"></a>scene</h4><p>现在考虑这样的资源和操作，我们要分为两个不相关的步骤：</p><ul><li>第一步，通过某些标识唯一指定某个资源</li><li>第二步，骤以及对这个资源进行操作，转换成我想要的样子。</li></ul><h4 id="define-1"><a href="#define-1" class="headerlink" title="define"></a>define</h4><p>前者叫做表现层RE（Representation），后者叫做状态转换ST（State Transfer）</p><p>具体来说，我要从服务器拿一段文本。可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；它可以是不同的语言。<br>现在我们希望分成这两个要素 RE 和 ST</p><ul><li>RE: URI只代表资源的实体，不代表它的形式。比如网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于 ST 范畴，而 URI 应该只代表”资源”的位置。</li><li>ST: 它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。它的语言应该在Accept-Language中指定</li></ul><h4 id="RESTful-1"><a href="#RESTful-1" class="headerlink" title="RESTful"></a>RESTful</h4><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面的操作方式动词：GET、POST、PUT、PATCH、DELETE。它们分别对应增删改查基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT、PATCH用来更新资源，DELETE用来删除资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）每一个URI代表一种资源；</span><br><span class="line">（2）客户端和服务器之间，传递这种资源的某种表现层；</span><br><span class="line">（3）客户端通过HTTP动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;。</span><br></pre></td></tr></table></figure><h3 id="how"><a href="#how" class="headerlink" title="how?"></a>how?</h3><h4 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h4><p>常见增删改查，注意下安全性和幂等性。</p><ul><li>安全性：不会改变资源状态，可以理解为只读的；</li><li>幂等性：执行1次和执行N次，对资源状态改变的效果是等价的。</li></ul><p>安全性和幂等性均不保证反复请求能拿到相同的response。以 DELETE 为例，第一次DELETE返回200表示删除成功，第二次返回404提示资源不存在，这是允许的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;zoos：列出所有动物园</span><br><span class="line">POST &#x2F;zoos：新建一个动物园</span><br><span class="line">GET &#x2F;zoos&#x2F;ID：获取某个指定动物园的信息</span><br><span class="line">PUT &#x2F;zoos&#x2F;ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH &#x2F;zoos&#x2F;ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE &#x2F;zoos&#x2F;ID：删除某个动物园</span><br><span class="line">GET &#x2F;zoos&#x2F;ID&#x2F;animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE &#x2F;zoos&#x2F;ID&#x2F;animals&#x2F;ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure><h4 id="common"><a href="#common" class="headerlink" title="common"></a>common</h4><p>花式GET，并且所有请求都是可以缓存的，在浏览器，nginx，服务端代码里都应该可以缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;zoos</span><br><span class="line">GET &#x2F;zoos&#x2F;1</span><br><span class="line">GET &#x2F;zoos&#x2F;1&#x2F;employees     &#x2F;&#x2F;为id为1的动物园雇佣员工</span><br><span class="line">GET &#x2F;zoos?type&#x3D;1&amp;age&#x3D;16  &#x2F;&#x2F;允许一定的uri冗余，如&#x2F;zoos&#x2F;1与&#x2F;zoos?id&#x3D;1</span><br><span class="line">GET &#x2F;zoos?sort&#x3D;age,desc  &#x2F;&#x2F;age 第一参数，desc 第二参数排序</span><br><span class="line">GET &#x2F;zoos?whitelist&#x3D;email &#x2F;&#x2F;指定额外参数</span><br><span class="line">GET &#x2F;zoos?whitelist&#x3D;id1,id2 &#x2F;&#x2F;指定额外参数</span><br><span class="line">GET &#x2F;zoos?limit&#x3D;10&amp;offset&#x3D;3  &#x2F;&#x2F;分页器</span><br></pre></td></tr></table></figure><p>花式POST：创建单个资源。POST一般向“资源集合”型uri发起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;animals  &#x2F;&#x2F;新增动物</span><br><span class="line">POST &#x2F;zoos&#x2F;1&#x2F;employees &#x2F;&#x2F;为id为1的动物园加入雇佣员工</span><br></pre></td></tr></table></figure><p>花式PUT：更新单个资源（全量），客户端提供完整的更新后的资源。与之对应的是 PATCH，PATCH 负责部分更新，客户端提供要更新的那些字段。PUT/PATCH一般向“单个资源”型uri发起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;animals&#x2F;1</span><br><span class="line">PUT &#x2F;zoos&#x2F;1</span><br></pre></td></tr></table></figure><p>花式DELETE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;zoos&#x2F;1&#x2F;employees&#x2F;2</span><br><span class="line">DELETE &#x2F;zoos&#x2F;1&#x2F;employees&#x2F;2;4;5  &#x2F;&#x2F;花式删除关系，一般这种 url 代表关系，不一定要Delete雇员对象，这个可以自己定。</span><br><span class="line">DELETE &#x2F;zoos&#x2F;1&#x2F;animals  &#x2F;&#x2F;删除id为1的动物园内的所有动物</span><br></pre></td></tr></table></figure><p>HEAD / OPTION 作为简单请求，在 RESTful 不重要，毕竟，RESTful 可以方便的一键生成单个资源的 CRUD，快速的生成资源之间的相互 join。</p><h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><ul><li><p>API的身份认证应该使用OAuth框架，增加一个 login、logout 接口，使用 token 来确认身份。</p></li><li><p>Hypermedia API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</span><br><span class="line">&#x2F;&#x2F;比如 angular ember react-redux 都对标准的 RESTful 有一定支持，而且倾向于拿单个的对象，然后每个对象单独更新，这样每个对象都容易更新。</span><br><span class="line">&#x2F;&#x2F;在某些情况下可以把下面 zoos 对应的 url 换成一个 list，tiger 换成一个 object，框架很容易完成这件事。</span><br><span class="line">&#123;</span><br><span class="line">  &quot;zoos&quot;:  &quot;https:&#x2F;&#x2F;api.example.com&#x2F;zoos&quot;,</span><br><span class="line">  &quot;tiger&quot;:  &quot;https:&#x2F;&#x2F;api.example.com&#x2F;zoos&#x2F;1&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;List of zoos&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务的 URL 设计<br>服务应该使用名词，比如计算应该使用calculation，不应该使用calc或者calculate。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;应该根据幂等性来使用GET 和 Post，典型的就是一个函数式计算任务和一个队列提交任务。</span><br><span class="line">GET &#x2F;distance-calculation?lats&#x3D;47.480&amp;lngs&#x3D;-122.389&amp;late&#x3D;37.108&amp;lnge&#x3D;-122.448</span><br><span class="line"></span><br><span class="line">POST &#x2F;tasks</span><br><span class="line">[&#123;&quot;from&quot;:0,&quot;to&quot;:1,&quot;text&quot;:&quot;abc&quot;&#125;,&#123;&#125;,&#123;&#125;...]</span><br></pre></td></tr></table></figure><p>设计的时候应该要保证服务可以单独部署，对多个资源操作的事务由单独部署的服务来管理。</p><ul><li><p>各HTTP方法成功处理后Response的数据格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">response格式</span><br><span class="line">GET单个对象、集合</span><br><span class="line">POST新增成功的对象</span><br><span class="line">PUT&#x2F;PATCH更新成功的对象</span><br><span class="line">DELETE空, 通过状态码确认</span><br></pre></td></tr></table></figure></li><li><p>json格式的约定：<br>时间用长整形(毫秒数)</p></li><li><p>URI规范</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不用大写；</span><br><span class="line">用中杠-不用下杠_；</span><br><span class="line">参数列表要encode；</span><br><span class="line">URI中的名词表示资源集合，使用复数形式。</span><br></pre></td></tr></table></figure></li><li><p>避免层级过深的URI<br>一般根据id导航。过深的导航容易导致url膨胀，不易维护。尽量使用查询参数代替路径中的实体导航。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">相对不好的设计</span><br><span class="line">GET &#x2F;zoos&#x2F;1&#x2F;areas&#x2F;3&#x2F;animals&#x2F;4</span><br><span class="line">相对好的设计</span><br><span class="line">GET &#x2F;animals?zoo&#x3D;1&amp;area&#x3D;3；</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>对Composite资源的访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它的生命周期完全依赖父实体，无法独立存在，不直接对应表，也无id。服务器端的组合实体必须在uri中通过父实体的id导航访问。一个常见的例子是 User — Address，Address是对User表中zipCode&#x2F;country&#x2F;city三个字段的简单抽象，无法独立于User存在。必须通过User索引到Address：GET &#x2F;user&#x2F;1&#x2F;addresses</span><br></pre></td></tr></table></figure></li><li><p>URI失效<br>应该添加301到新地址，或者有一个错误提示。</p></li><li><p>版本<br>GITHUB 的处理方式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.example.com&#x2F;v1&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>不要瞎JB搞，乱包东西很丑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;H5前端工程师非常讨厌这种搞法，开源世界的库都不能愉快的使用。</span><br><span class="line">&#123;</span><br><span class="line">    &quot;success&quot;:true,</span><br><span class="line">    &quot;data&quot;:&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;xiaotuan&quot;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="So-what"><a href="#So-what" class="headerlink" title="So what?"></a>So what?</h3><p>正如前文所说，RESTful 几乎是开源世界里非rpc调用最通用的接口。很多的开源 web 框架都有对应的 RESTful 库类，可以用极少量的配置完成对对象的序列化。</p><p>典型的如 Django的django-restful-framework，100行代码可以完成一个支持邮件收发、注册改密码、身份验证、序列化反序列化、数据 schema，持久化增删改查等的 todoMVC项目。</p><p>符合规范可以可以极大的提高开发效率！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下我学习 http 协议和 RESTful 最佳实践的学习过程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTML" scheme="https://wangzitian0.github.io/tags/HTML/"/>
    
    <category term="Best Practice" scheme="https://wangzitian0.github.io/tags/Best-Practice/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wangzitian0.github.io/2017/01/04/hello-world/"/>
    <id>https://wangzitian0.github.io/2017/01/04/hello-world/</id>
    <published>2017-01-03T20:04:00.000Z</published>
    <updated>2020-09-30T04:59:07.882Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/gopher2.png" class="ggggtest" width="600" height="600" title="title text alt text"><p>之后陆陆续续把原来在 QQ 空间和 CSDN blog里的东西陆陆续续迁过来，Github page 真是好用啊。。</p><a id="more"></a><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h1 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h1><h2 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>test admin</p><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h2 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h2 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h2 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p><h1 id="Do-some-test"><a href="#Do-some-test" class="headerlink" title="Do some test"></a>Do some test</h1><h2 id="codes-amp-amp-quatos-amp-amp-images"><a href="#codes-amp-amp-quatos-amp-amp-images" class="headerlink" title="codes &amp;&amp; quatos &amp;&amp; images"></a>codes &amp;&amp; quatos &amp;&amp; images</h2><blockquote><p>content</p><footer><strong>wzt baidu.com</strong></footer></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i range(<span class="number">0</span>:<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><img src="/images/gopher2.png" class="full-image" width="100" height="100">]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/images/gopher2.png&quot; class=&quot;ggggtest&quot; width=&quot;600&quot; height=&quot;600&quot; title=&quot;title text alt text&quot;&gt;

&lt;p&gt;之后陆陆续续把原来在 QQ 空间和 CSDN blog里的东西陆陆续续迁过来，Github page 真是好用啊。。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Others" scheme="https://wangzitian0.github.io/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>不忘初心，方得始终</title>
    <link href="https://wangzitian0.github.io/2016/12/31/Never-forgot-why-you-start/"/>
    <id>https://wangzitian0.github.io/2016/12/31/Never-forgot-why-you-start/</id>
    <published>2016-12-31T08:33:00.000Z</published>
    <updated>2020-09-30T04:59:07.879Z</updated>
    
    <content type="html"><![CDATA[<p>你别无选择——这就是命运的题旨所在。正如一个农民春种夏耘，到头一场灾害颗粒无收，他也不会为此而将春种夏耘而不管秋天的收成如何。 　　　　　　—路遥</p><a id="more"></a><h1 id="零，平凡人行不凡事"><a href="#零，平凡人行不凡事" class="headerlink" title="零，平凡人行不凡事"></a>零，平凡人行不凡事</h1><p>　　今年是大学毕业的第一年，离家的第十一个年头，从一个小小的小地方出发，先到湘潭，又到了长沙，再来了北京，这中的距离是三千里，远又远不止三千里。十年一梦，来帝都之前，每一次都把这一站当做最后一站，每一次却又都下决心要去更远的地方。<br>　　只要往外走就会有环境改变，有环境改变就会有观念冲突，有观念冲突就要去找合适的方法论。否定与再否定不知道进行了多少次，每次说真话伤别人，说假话恶心自己，最后选择不说话，做好自己的事情，性格有缺陷总比表里不如一要强。<br>　　路遥的书很有共鸣感，共鸣感不在于主人公多么了不起，而恰恰在于他们的平凡，在于对待生活的态度，在于他们即使拼尽拼尽全力生活也没有好多少，却依然坚持着。身体生了大病，想让某一个细胞健康是不太可能的，要调养好需要特别长的时间。不管怎样，就像孙少平孙少安那样活着吧——看人透彻，看事通达，却又有自己的追求，面对生活没有一丝的愤怒和抱怨，安安心心的做好一个有教养有学识的平凡人，竭尽全力的做好自己的本分。<br>　　中国人讲求仪式感，逢五逢十要事应该要纪念、要感恩、要畅想。回首来看，心态最大的一次转变到现在刚好五年。想留点记录给自己，天时地利人和没沾上多少，还是很神奇的走出来了，有那么几件事情几个思考是必须记录一下的。</p><h1 id="一，成长环境"><a href="#一，成长环境" class="headerlink" title="一，成长环境"></a>一，成长环境</h1><p>　　进大学之后才算真正意义上的思考这个问题，以前接触的人和事都不够多，没有足够的对比很难把自己从环境中抽离出来。<br>　　小时候做什么事情全凭一口气，不信邪，总想做些事情来证明自己。进中学之前记忆中有太多灰色部分，在不崇尚知识、不尊重个性、还充满了暴戾的环境里生存，第一要义一定是保护自己的生存空间。有很多故事现在该忘了，有很多的争论用脚投票就行了，实在没必要每件事都争。<br>　　一个人为了快速增长可以使用很多的外部资源，但是，控制权必须留在自己的手中。如果两者冲突，一定选择控制权，失去资源只会影响发展速度，失去控制权就直接雪崩。上一代人的某些问题我本身就不想参与，也不在乎。只能尽量让每件事情到我这做一个隔离，尽量减少家庭的内耗，降低干扰。有些事情实在是太烂，做到仁至义尽即可，必要的时候与太自私的人保持距离，恪守自己的底线。<br>　　刚进大学的时候想法很多，现在却只有一条:学会与自己共存，好事坏事都是自己的一部分。<br>　　我是地地道道的在市井里长大的人，很长一段时间觉得这是劣势，市井里长大的人往往容易视短、不讲规则，直到前两年读过一本书叫做《五常学经济》，这个问题的思考盖棺定论。张五常也是市井里长大的，市井的生活经历为了他日后研究中国经济提供了众多的素材，也养成了他敏锐的直觉和谦逊的个性，进一步说，更加了解这个社会的运行状况。<br>　　中国的传统文人有一个普遍的缺点，叫做怕脏，一件事情如果看上去不体面，即使是对自己和身边的人有好处也不会去干。对于我来说，不会有这样的问题。</p><h1 id="二，我的个性"><a href="#二，我的个性" class="headerlink" title="二，我的个性"></a>二，我的个性</h1><p>　　我是偏内向性格的人，近十年的时间，有无数人说过这一点，多到我一度以为这是缺点。一方面，这两年有很多的机会去练习沟通的技巧，即使在很多人的面前做演讲，也不会怎么紧张。另一方面，我觉得内向从来就不是劣势，它是一个礼物。<br>　　内向的人更容易触摸到其他人内心柔软的角落，更容易听到夜风流水、钟声细语，更容易变得细致冷静，做事情的时候更加不骄不躁。而且，内向不代表没有自信和风度，不代表没有观察和思考，不代表没有观点和看法。<br>　　相比于话多的人，内向的人更习惯于在角落里默默听大家说。情商高的一个体现是“感同身受”，而并不是从头至尾占据着主动权或者是说个不停。相比于做一个“外向的人”，我更愿意做一个遇到事情了，能先替别人想一想的人。<br>　　内向的人更像是一个弹簧，看上去软绵绵的，但是压迫到一定程度会弹起来，从而成为优势。</p><h1 id="三，宁在锅里争，不愿碗里斗"><a href="#三，宁在锅里争，不愿碗里斗" class="headerlink" title="三，宁在锅里争，不愿碗里斗"></a>三，宁在锅里争，不愿碗里斗</h1><p>　　有些人是内战内行，外战外行，只会和自己熟悉的人去抢风头。我更希望自己始终保持一颗开放而谦卑的心，去更大的世界去找到属于自己的天地。<br>　　很多时候去碗里斗是件很稳妥的事情，而主动放弃碗里的东西很难。但是，用不了几年就会发现：那些在碗里斗得死去活来的人，几年之后还在碗里斗；而去锅里争的人，几年之后体量比整个碗都大。<br>　　人一定是有所不为，才能有所为的，顺着这个思路走了很久很久了。从最开始的面向小圈子，到面向学校，到面向全省，到面向全国，到现在的面向全球，见识到越来越多厉害的事情和人，越来越不会在把自己封闭在内心的舒适区。很多事情现在都还不敢定论，交给时间去检验吧…<br>　　吵着嚷着说要离开的人，总是会在最后红着眼弯着腰把一地的玻璃碎片收拾好。真正准备离开的人，只会挑一个风和日丽的下午，随意裹上一件外套出门，留下背影，再无归期。</p><h1 id="四，从商"><a href="#四，从商" class="headerlink" title="四，从商"></a>四，从商</h1><p>　　大概是五年前开始正式对自己有这样的一个定位，这两年看法上有一些微调。小一些的时候，可能希望能做学术，做一个有影响力的科学家，慢慢的发现那条路不适合自己。我希望去造大家实实在在用的东西，做的过程中养活自己。<br>　　第一年高考结束的时候，那段时间状态极差，力气差不多拼干净了，但是确实想做的事情没做成几件，最后还被录取到“环境工程”专业。当时备了两个方案： 一个是复读，再次填志愿的时候写一个保守的志愿，接着弄计算机相关的东西。另一个是直接工作，硬要找工作也并不是找不到，当时虽然没有能登台面的工程经验，但是编程已经有还凑合的功底了。最终采用的是方案一，其实选了方案二也没有啥大问题，也许视野不会有现在开阔，四五年工程经验下来工资水平肯定现在高。<br>　　那个暑假非常的抑郁，却又因祸得福，看了特别特别多的书，与特别特别多的人聊天。从那个时候开始，个性里面多了一些开放的成分，试着去听听同龄人在干啥，了解一下其他人的成长环境，理解一下大家对问题的看法。虽说无意与大家竞争，但是横向的比较终归是对自己有益的，能更加了解自己感兴趣并且有机会的事情是哪些。中途的过程山路十八弯，最终自己得到的结论是，我骨子里合适也希望做一个商人。<br>　　商人追求的事情是效率优先、是结果导向、是扩大自己的盈利，政治正确不是那么的重要。谈一个不太恰当的例子，扶贫，商人扶贫一般会去资助上不起学的人，而政治正确的做法是扶助最穷的人。一个家庭只要有一个读书人，就不会穷太久，扶助了一个读书人就是扶助了一个家庭。而政治正确的做法呢？无底洞，无论投入多少资源，永远很难彻底摆脱贫困这件事情。这中区别很微妙，却又本质上不一样。<br>　　有一个关于好商人、好企业家的所需要特质的论断，是一个很有名的企业家说的，具体是谁不太记得了：</p><p>1，善用新技术，能创造前所未有的社会价值的东西往往是新东西；</p><p>2，有团体意识，能聚集一批人做好一件事；</p><p>3，有企业家精神，不急于享受，敢于把收益再投入到生产中去。</p><h1 id="五，关于自己的SWOT"><a href="#五，关于自己的SWOT" class="headerlink" title="五，关于自己的SWOT"></a>五，关于自己的SWOT</h1><p>S：思想独立，行事果断，乐于接受新事物和思想，习惯听别人的观点，善用总结、类比、举例<br>W：喜欢自己闷头搞事情，记忆力不好，不喜欢说话，有时候干重复的事情会毛躁<br>O：敢另辟蹊径，有狠劲胆子大，成长环境非常多元，愿意学新东西<br>T：无资本，无背景<br>　　目前看来是这些，这些条件都是动态变化的。任何时代都有靠自己努力而生活得更好的人，也都有生活越过越糟的人。体量是我们无法控制的，但是方向和势头是可以自己掌握的。另外就是，资本和背景会有放大作用，一个牛逼的人有它们会更牛逼，一个傻逼的人拿到它们会更傻逼。</p><h1 id="六，警惕优秀，追求卓越"><a href="#六，警惕优秀，追求卓越" class="headerlink" title="六，警惕优秀，追求卓越"></a>六，警惕优秀，追求卓越</h1><p>　　对我来说，优秀的意义不大。做到优秀的时候，也许别人会夸奖你，但是做到“优秀”是远远不够的，基本上意味着竞争中被干掉了。任何时代，任何组织，用人一定是用组织者熟悉了解的人，这种时候即使你能力强百分之二三十也没有多大意义，同一个体量级别一定是资本雄厚，背景深厚的人取胜。<br>　　优秀一般指横向比较，在某一个维度里，在同一个量级有一定量的优势。而卓越是指的差距拉开数量级。<br>　　优秀的特质就不说了，相比较于优秀，我理解的卓越有几种：<br>　　第一种叫：敢为人先。在别人意识到一个东西的发展趋势之前提前布局，等别人意识到机会的时候自己已经跑得足够远，让人家追上你的花销大于人家追上你的利润。<br>　　第二张叫：做到极致。看上去很厉害和真的很厉害隔了一万个小时的训练时间和无数个小细节。有些人的成功是他的“套路”你全都知道，但是你无法模仿。<br>　　第三种叫：跨界融合。能把一些看上去不相干的东西合在一起发现新的机会，用已有之工具完成未有之事。<br>　　综上，如果一件事情，用掉自己的所有力气，还只能到达“优秀”的水平，就需要考虑一下，是不是该放弃了。</p><h1 id="七，ACM"><a href="#七，ACM" class="headerlink" title="七，ACM"></a>七，ACM</h1><p>　　从写下hello world到现在，八年整了，花了很多的时间在计算机上。中途有大概一年的时间想放弃，其他的时间都在努力的学习。<br>　　四年前，决定参加acm，从入队第一天开始，就觉得愿景是参加world final。中途绕了很多弯路，很长的时间打不出成绩来，盲目的海刷也干过，还有一段时间沉溺于游戏。虽说这是号称“世界上最聪明的人的竞赛”，但我的感触却与slogan相反。这个世界上从来就不缺乏聪明人，缺乏的是基础扎实的人。<br>　　感谢两位靠谱的队友！最终很神奇的进到ＷＦ，达成目标！<br>　　花时间是一方面，更多的是收获。也主导了一些事情，参与组织两次校赛，参与对学弟学妹的培训，和好基友们四处腐败，组织研究生上机复试，最后还有给力的泰国普吉岛收官之行。</p><h1 id="八，团队协作-amp-管理"><a href="#八，团队协作-amp-管理" class="headerlink" title="八，团队协作&amp;管理"></a>八，团队协作&amp;管理</h1><p>　　进WF的时候对团队协作有了一个更加深刻的理解。三个人的团队，在时间和空间有限的前提下，如果每个人都尽自己的全力去做事情，可能每个人都能发挥七成的力气。但是某些情况下，适当的克制自己的输出，可能会有8+8+6甚至9+9+5的效果。当三个人都能这么想，并且能够控制自己力度的时候，团队的灵活性和战斗力都会大大加强。<br>　　也一直持续关注it企业如何管理的深度报道和书籍。管理最重要的是懂行，制人需先自制，自己做不好的事情很难要求别人做好。it尤其是技术团队的管理和传统行业太不一样了，除了重视人才、文化氛围培养方面，其他的方法和规律基本失效。一个团队每个人都在干不同且不重复的事情，衡量价值不能去数工程师代码行数、数美工画的图数、或是产品经理的报告字数，衡量准则基本只能靠经验。一个活给谁干，要干多久，判断基本也只能靠经验。可是光有经验也不够，每一家公司的业务逻辑和处理方式不一样，也许在某家成功运用的好方法，换个地方却成了催命符。<br>　　互联网表层的东西太容易模仿了，可是一个好的互联网产品，一定是基于迭代的，它的好是被用户反馈撑起来的，光看呈现出来的东西，很难理解内在的原理。就如同一个生态系统的演替，演替可以分成若干阶段，每个阶段出现的植物种类是相对确定的，但为什么就是某种植物却和演变过程中的很多因素相关。管理方法必须能支撑这整套流程，它比这套流程有更大的不确定性。<br>　　今年还接触到一个新词：敏捷开发。接下来的一年好好研究一下。</p><h1 id="九，本科总结"><a href="#九，本科总结" class="headerlink" title="九，本科总结"></a>九，本科总结</h1><p>　　到了大二就不太去上课了，去了的基本上是选修。有些科，明明是同一套内涵的东西，换一套符号，一门拆成三四门，学完除了认识一套新符号外感觉没什么收获，但不学就等着挂吧。还有若干门必选的专业选修，能把灵活多样的计算机教成这样也是不容易…最后用了折中的方案，每门课花一个通宵，从入门到及格。在不作弊的前提下，奇迹般的通过了所有的课程。<br>　　学校发的很多专业课课本有点过时了。不是说基础不重要，没有扎实的功底很难把功能做好，功能没做好就去谈设计和架构纯属扯淡。学校发的课本很多理论都是基于设备能力不行的，每一点资源都得精打细算，现在很多设计的出发点已经变了，更多要考虑的是容错和开发成本。对大部分中小企业而言，多耗掉一个不错的开发者一年成本30w以上，但是用这个钱买10台服务器外加运行的电费都够了…敏捷开发框架，分布式计算框架等架构级的选择和设计远比边边角角的效率优化重要。另外，计算机的知识更新太快了，技术每年都在变。学道不学术，掌握学知识的能力，问题经常在变，需求经常在变，理念经常在变，技术经常在变，解决方案也经常在变，但得到解决方案的方法是基本固定的。<br>　　毕业半年，再来回看这个问题，一个印象非常深刻的词叫“最佳实践”，计算机学科在冯诺依曼架构下，有很多经典的问题是有一个得到大量验证的最佳实践的。归结一下是两门课：操作系统+计算机网络，如果有机会重新来过，我会把这两门课刷到90+。至于其他课程我还是会坚持我原来的做法，课堂放弃，课程凑合，程度学到自己接下来几年都能有及格水平就好。</p><h1 id="十，专业vs跨界"><a href="#十，专业vs跨界" class="headerlink" title="十，专业vs跨界"></a>十，专业vs跨界</h1><p>　　专业知识需要深钻，更需要跨界。很多产品经理是学生物、经管、化工出身的，很多数据挖掘工程师是学通信、数学、物理的，很多做电商的人是学社会学出身的，演替、关联分析、统计数据、博弈、社会心理这些东西在计算机学科是奇奇怪怪的东西，放到其他专业却可能是常识。<br>　　这些积累不能等要用了再学，因为快速学习永远只能学到方法，理解思路和原理需要很长的时间和灵光一现。<br>　　特别提下几年前的王兴和雷军，可以看看他们几年前写的文章，他们的成功几乎是注定的，只是个时间问题。比如好大夫网ceo去找雷军要投资的时候，雷军第一句话是“你应该去xx地方xx医院问一下，原来我在xx看到过介绍，他那有一个做医导的做了二十年，回来我再决定投不投你们”，吓得那ceo不敢说话…雷总靠着金山上市那些钱投出一个雷军系和小米生态，光靠“趴风口上”是办不到的，还得靠全面的跨界的知识，得靠一眼看透问题本质的能力。<br>　　王兴就更不用说了，跨界很多次，产品次次火爆，他自己也在反复提跨界这个词。</p><h1 id="十一，对互联网的看法"><a href="#十一，对互联网的看法" class="headerlink" title="十一，对互联网的看法"></a>十一，对互联网的看法</h1><p>　　互联网本质不是一个行业，比如bat，说到底是用互联网工具的广告公司、集贸市场、通信公司。它是用技术的手段去中心化和去中间流程。去中心化是说逻辑关系上去除层级，也可以理解成每个点都是中心，网络协议从制定第一天开始就没有中心节点，一级级的架构下信息会存在大量的信息不透明和权限问题。去中心化就是去除这种层级，社交网络、搜索引擎等等都是顺着去中心化这条路走的。去中间流程直接用例子说，京东天猫为什么能低价…？传统的销售模式是生产方-经销商-代理商-用户，电商可以做到生产方-电商-用户，用技术手段和机器砍掉或优化环节，降低环节成本。具体行业有不同的行规，但大体上互联网能改变传统行业的原因就在此，将来那些信息不透明的或者中间流程过多的行业都会被逐渐颠覆，还有很多没被改变的行业，还有很多没被大家发现的机会。<br>　　IT行业大概每隔五年左右成熟的技术架构质变一次，商业化一些全新的东西，这些新东西往往都是小公司做出来的。未来具体啥样现在谁又能说得准呢…还有些跟政策相关的行业就不说了，跟政策相关的行业往往是资源型行业，反正也没年轻人啥事。总的来说看好可穿戴设备的发展，未来“手机”的形态可能变成类似于Google Glass的东西，可以把信息投射到眼镜里，看到实时的消息和服务。<br>　　从学校毕业后，还得工作两三年，手脚才能解放出来。迎面而来的第一波浪潮是赶不上了，但可以在这一波浪潮中做好迎接下一波浪潮的准备。还是希望做一些别人没有做过的有价值的事。哪天灵光一现了希望自己有胆子和耐性去试，经验是在实战中获得的，有产品意识、技术水平不算什么，有商业头脑也不算什么，两者都会就难了。互联网的特性决定，同一件事最后能做成的往往只有那少数几个人，没有果决强悍的执行力，没有全面细致深入的知识，那不过又多了个炮灰。<br>　　唐岩做陌陌前先当了十年的编辑，马云做阿里前也先做了几年信息发布平台，李彦宏先在硅谷做了几年的工程师，王兴做美团前先后做挂五六个项目，张小龙做了很多年的空间阅读内容，小马哥在润训搬砖搬了好几年。中国的IT圈能把一个项目做到大众化的人，在此之前基本上都有10年左右的积累和打拼，几乎没有反例。</p><h1 id="十二，年轻"><a href="#十二，年轻" class="headerlink" title="十二，年轻"></a>十二，年轻</h1><p>　　今年22岁，即将23，很好的年龄啊，有最多可能性的年龄。扎克伯格23已经在大学念书期间先后写过12个项目，开始创立FB。比尔盖茨23已经把操作系统卖出去了。乔布斯23早已经创立苹果。雷军23已经成为创业圈知名人物。刘强东23已经靠卖自己写的urp软件账上趴了二十万，并且找到了女朋友。马云23才刚经历完三次高考。马化腾23还是个刚毕业开始搬砖的大学生。史玉柱23还在数学系推公式。俞敏洪23还在整天被人欺负。23岁，李鸿章刚进京不久，写下“一万年来谁著史，三千里外欲封侯”明志。23岁，袁世凯已经投笔从戎，书下“大丈夫当效命疆场，安内攘外。”等等等等…<br>　　23岁，已经有一定的能力去做自己想做的事情。23岁，一切未定，各种试错都有改变的可能。23岁，思维最为天马行空。23岁，书生意气正浓。<br>　　现在90后已经逐步展露头角了，也看到好多质疑。在我看来，90后才是中国最有希望做出巨大改变的一代，90后是真正了解自己的一代人。一把媒体喜欢说90后喜欢吹牛，做事不扎实，真是太片面了，做事最踏实的这部分人大多还在学校里读书。很多行业的核心工艺靠“化缘”，这种问题要到90后成为社会中坚才会逐步解决。<br>　　90后是思维限制非常少的一代人，手机碎个屏，90后敢自己换屏的人绝对比60，70，80多多了。很多跨越式的工作都得靠这些肯折腾的人来完成。至于说90后眼高手低的，挺对的，这个年龄动手能力再强也不过是小孩子过家家，但是，眼都不高手更不可能高。眼界高不意味着能力强，但是眼高的人将来遇到问题时，会关注更多细节。</p><h1 id="十三，校招-2015"><a href="#十三，校招-2015" class="headerlink" title="十三，校招@2015"></a>十三，校招@2015</h1><p>　　这件事其实应该去年写总结的，不过后来一忙就忘了。大部分公司是自己一个个环节面试的，没有去麻烦之前开放日之类的活动认识的大佬，免得不好意思拒offer。<br>　　offer情况：领英，腾讯，微软，小米，今日头条，拉勾，豆瓣，微店，宜信大数据，Nice等。<br>　　岗位是以后端研发为主，也投过搜索工程师，算法工程师，全栈工程师，运维架构工程师。基本上是面试前两天快速的学学就上去面了，效果还行，很多好公司都是几乎不招本科生的，但最后开出了special。<br>　　因为投的岗位乱七八糟，所以准备面试的时候还是看了很多东西的，那段时间感觉成长非常大。面试的过程当中也认识了不少小伙伴，很多很强也很有意思的人。 不过也有挂了的公司：美团、滴滴、阿里，还都是一面就跪了，至今原因不明。<br>　　最终还是决定去LinkedIn，一家有深厚积淀，但是在中国还很年轻的公司。这个时代，工作不再是铁饭碗，对于当前来说，最重要的是毕业几年如何有最快的成长速度，养成一个好的职业素养，权当读研。公司整体非常敏捷，目前也没有太多的技术债，因此可以比较和谐的当dev。<br>　　之后的一年大约帮近20人改过简历，讨论一些面试的小技巧之类的。整体反馈还是不错的，回长沙开个小酒吧的plan B后面还可以加一个plan C：不当程序员了做面试指导师也是不错的。</p><h1 id="十四，看公司看什么"><a href="#十四，看公司看什么" class="headerlink" title="十四，看公司看什么"></a>十四，看公司看什么</h1><p>　　看本质。产品驱动，技术驱动，运营驱动，战略驱动。有一点就可以跑赢GDP，有两点可以成独角兽，有三点可以成平台，四点都有谓之生态。<br>　　看人。看一家公司的水平，基本上取决于员工号刚好处于四分之一的员工。比如百人的公司，看二十五号员工的水平就能看出这家公司的水平。<br>　　看行业。技术发展有一定的规律。科达公司一直到倒闭，胶卷的质量一直是全球最好的，但是有了数码相机人们不再需要胶卷。<br>　　看文化和愿景。只有有了文化和愿景，一家公司的员工才会紧密结合到一起，遇到困难了才不会退缩。<br>　　看技术实力。想举一个例子：万达。万达是所有地产公司里IT化做得最好的公司，也是商业地产领域内部流程搭建最完善的公司。我对技术的理解是：通过通过制度和工具来办事，而不是堆人。<br>　　至于公司大小什么的，绝不是关键。大公司有雷利风行的部队，小公司也有拖拖拉拉的组。</p><h1 id="十五，第一个五年计划（2017-2021）"><a href="#十五，第一个五年计划（2017-2021）" class="headerlink" title="十五，第一个五年计划（2017-2021）"></a>十五，第一个五年计划（2017-2021）</h1><p>　　只有五个字：年收入百万。<br>　　首先，我想引入一个“当量”的概念，就是一个人从应届毕业生平均水平成长到某一个状态所需要的力气是相对固定的，我想把这种力气叫做“当量”。一个能在BAT这种巨无霸公司当高级总监的人，放在大型公司可能掌管一个部门，放到中型公司可能当CXO，放到小型公司当CEO，放到公务员体系，可能是当一个实权部门的副主任，或者是一个其他部门的主任。但他的当量是相对固定的。<br>　　IT行业是一个发展很快的行业，因此最合适的量化指标就是package，从现在的位置出发。要达到这个level，每年薪酬要成长30%，知识和经验增长要有30%，那么尝试的新事物要超过30%……换句话说，干活的时候，三件事当中至少应该有一件是有挑战的，不可替代的……低于这个比例的时候就应该和leader沟通或者换岗了……<br>　　另外，为了达到这样一个计划，至少前四年不应该考虑赚钱的事情，要充分的积累各种知识，办事的方法，对行业和产品的洞察力。某种程度上来说，工资与当前实力一定是不匹配的，只有下一份工作的package能体现现在的实力。<br>　　在我理解，打工和创业二者没有明确的界限。打工的过程，是利用别人的平台创业，创业是开公司为股东打工，真正能体现自己价值的还是“当量”。所以，工作的时候一定要充分发挥平台的优势。</p><h1 id="十六，技术路线"><a href="#十六，技术路线" class="headerlink" title="十六，技术路线"></a>十六，技术路线</h1><p>　　接下来的几年，软件工程的整体发展趋势是工程师变为三种大类：全栈工程师，架构工程师，数据工程师。由于各种开源工具的兴起，现在开发一个东西的效率越来越高，面向用户的大前端工程会越来越全栈化，除了数据持久，剩下的工作都在“大前端”完成。由于网络的发展，服务端会越来越重，对架构和SRE的要求会越来越高，运维研发、后台研发、SRE会逐渐融合为一个工种“架构工程师”。还有一个是数据类，这个的重要性也会越来越突出。而其他的岗位，会逐步的像这三种工种中的某一种靠拢，或者消失。<br>列一个长期发展纲要：</p><ul><li>0，腾讯有一种特种部队：T4工程师（LinkedIn的职级内涵我到现在也没闹明白，因此用鹅厂的体系来衡量，本质是一样的。具体的要求是T4的技术专家一方面在自己的技术领域有着开创性的贡献，另一方面大多主导过公司级的重点技术项目，再者为公司培养了一批T3或者以上的技术骨干。）我希望十年之内达到这样的一个当量。</li><li>1，拥有快速demo的能力。喜欢从零到一的感觉和情节，因此在找工作的时候非常看重岗位是否能提高这方面的能力。可以肯定，接下来几年的工作会有非常多的需要验证的场景，与其详细规划画唯美大饼，不如快速开发精巧小demo。</li><li>2，有一套完整的栈型。甩掉数据挖掘，以后十有八九不会搞了。其他的方面，我希望自己成为一个全栈工程师，在数十万日活量级（意味着单机搞不定，但是又不需要太精细的集群控制），每个问题学习并熟悉一个开源技术套件：JS前端，业务后端，中间件技术，缓存系统，消息队列，实时数据存储，对象存储，日志处理，监控告警，持续集成，自动化测试，搜索系统。啥叫熟悉？我的理解是，给一个相对合理的时间，自己一个人也能把事情干完。</li><li>3，熟悉“最佳实践”。这四个字我不知道如何解释最为清楚，软件工程发展30多年，现代计算机的很多问题其实是在体系结构学科里有大量的研究和实践的，大师们总结出来的精粹，这一部分掌握了，2就相当于完成一半了。越是接近上层的东西变化越快，而“最佳实践”这样的抽象，近乎三十年没有变过。</li><li>4，主导敏捷开发。之前参加过一个敏捷开发的培训，收益良多，总的来说就是把小步快跑的理念和严格的自动化引入到日常开发来，提升开发的节奏。</li><li>5，杜绝奇技淫巧。竞赛选手普遍的毛病，为了使代码看上去牛逼或者有一丁点的效率提升而放弃可读性，学生时代搞搞就行了，工作之后要杜绝。</li><li>6，学最经典的工具。每一个栈位充分了解一个最经典的框架或者类库或者模式的源码和设计思路，比如react，django，requests，redis，kafka，Travis CI等等，任何一个栈位要解决的问题都是相似的，只是解决的问题不同，设计中的取舍也不同。以学到自己能造一个小轮子为界限，在经典中去体会trade off。</li><li>7，价值导向。少搞花活，尽可能用最简单的方式去完成同样的事情。越是简单的，接近本质的方案越是可靠。<br>　　真正厉害的工程师，不一定要自己写代码，在讨论技术细节的时候，有一个真正厉害的工程师在场，即使他不说话，大家也会觉得安心。<br>　　总的来说，成长注重三个点：注重经典，注重设计，注重价值。</li></ul><h1 id="十七，红海vs蓝海"><a href="#十七，红海vs蓝海" class="headerlink" title="十七，红海vs蓝海"></a>十七，红海vs蓝海</h1><p>　　我还记得我进大学之前的愿景：做蓝海精英。现在愿景稍微调整一下：做在红海中发现蓝海的人。<br>　　如果说一家企业或者一个人很容易地进入到了一片蓝海，那么十有八九这不是一个好的生意或者事情，一般来说很快就会被资本更加雄厚的人跟进，杀成一片红海。某种意义上来说，蓝海并不存在。<br>　　如何在红海中发现蓝海？我对此的理解是乔布斯最喜欢在发布会上说的一句话“last one more thing”，每完成一件别人都能做的事情之后再加上一小件，别人想不到的事。积少成多，聚沙成塔，壁垒终将会形成。</p><h1 id="十八，重量vs轻量"><a href="#十八，重量vs轻量" class="headerlink" title="十八，重量vs轻量"></a>十八，重量vs轻量</h1><p>　　轻量意味着快和灵活，重量意味着稳定和简单。两种截然不同的路径，资源一定的情况下，办事的时候“多快好省”（多元发展，快速发展，高质量发展，节省资源发展）一般都只能侧重两个点。<br>　　淘宝能够到达如此大的体量，归结于它的轻量，它要是重量发展早就别ebay打蒙圈了。而京东能在众多B2C商城中崛起，优势在于它的重量，要是它轻量早就被淘宝干翻了。<br>　　希望自己能在为人处世方面轻量一些，在职业发展方面能重量一些。想要高速前进必须保持轻量，量越轻改动成本就越低，犯错的可能性也会小一些，方方面面带来的的阻力也会越小。想要形成壁垒就最好重量多元发展，重量式发展的缺点就是慢，优势就在于一旦到了某个体量，人家难以复制。</p><h1 id="十九，2015-amp-2016两年回顾"><a href="#十九，2015-amp-2016两年回顾" class="headerlink" title="十九，2015&amp;2016两年回顾"></a>十九，2015&amp;2016两年回顾</h1><p>　　2016年的寒假实在是太忙了，又加上是在外地玩耍过的年，所以没有写文章版的总结。<br>　　不少方面过得真是乱糟糟的，对眼前的这个自己特别陌生，好多方面的变化都不太正常，“兴一利必生一弊”是常态，但我越来越相信，生活是可以靠自己去改变的。如同那小马过河，不自己下水淌一淌，永远不知道水对自己有多深。汉武帝打的第一仗叫“马邑之围”，史学家对它的评价基本上是差评。从战术上看、数据上看，这是彻底的失败，但从战略上看，这是汉朝历史上第一次倾举国之力的大规模军事调度，没有它绝对不会有后续的千里奔袭，更不可能后来的直灭匈奴王庭。<br>　　之前几年所有的规划里排第零条的：经济独立，直到今年这个目标才彻底达成。</p><h1 id="2015年初的时候给自己定的量化可量化目标："><a href="#2015年初的时候给自己定的量化可量化目标：" class="headerlink" title="2015年初的时候给自己定的量化可量化目标："></a>2015年初的时候给自己定的量化可量化目标：</h1><p>1、进acm wf。</p><p>2、40 books，5-10本矛盾文学奖。</p><p>3、实习。</p><p>4、开源节流，继续记账。</p><p>5、至少请经常联系的人吃一顿饭。</p><p>6、校招季拿5-10个大公司offer。</p><h1 id="2016年初的时候给自己定的量化可量化目标："><a href="#2016年初的时候给自己定的量化可量化目标：" class="headerlink" title="2016年初的时候给自己定的量化可量化目标："></a>2016年初的时候给自己定的量化可量化目标：</h1><p>1、wf拿到排名。</p><p>2、40 books，5-10本矛盾文学奖。</p><p>3、四处玩耍一个月。</p><p>4、修OJ，完整熟悉一个开发框架。</p><p>5、至少请经常联系的人吃一顿饭。</p><p>6、找妹子。</p><h1 id="15年的："><a href="#15年的：" class="headerlink" title="15年的："></a>15年的：</h1><p>1、3、5、6完成<br>开源节流勉强算是完成，记账这件事坚持了两个多月，后来换手机就GG了。</p><p>2这一条，确实事情多了很多，看书的时间少了，把两年加起来应该五六十本吧，所以算是完成一半。还是大一大二的时间段读的书多。</p><p>16年的：<br>2同上；6没完成，不解释；其他的目标都完成了。</p><p>　　做得好的事情过了，做得不好的事情也过了。稍借用下某段文章里的一段话：“他做的每件事都是他喜欢过的，付出过感情的，摆在那里，偶尔青烟缭绕，偶尔反思当年什么没做好。”对未来感极强的人来说，它们存在的积极意义，是让自己能抓住下一次机会，而不是时时忏悔自己的错失。</p><h1 id="二十，小步快跑，持续改进"><a href="#二十，小步快跑，持续改进" class="headerlink" title="二十，小步快跑，持续改进"></a>二十，小步快跑，持续改进</h1><p>　　2017展望，希望自己稍微改变一些做事情的风格。把步子放得更加小一点，迈步的频率更加快一点，保持主见的同时也学会更加广泛的听取他人意见。<br>　　写写可量化目标：<br>1.技术方面。每个季度学习一个自己不熟悉的东西，以能自己搭架子和给“应届生”水平培训为标准。每个月至少写一篇技术相关的文章。</p><p>2.40 books including 5本矛盾文学奖。这个目标和上年一样，工作之后时间相对规律，理论上读书的时间会更多一些。</p><p>3.去两个地方旅行。今年可以稍微去远一点了。</p><p>4.找妹子。在公司里我几乎是最小的，太惨了，得开发新的妹源。</p><h1 id="二十一，保持初心"><a href="#二十一，保持初心" class="headerlink" title="二十一，保持初心"></a>二十一，保持初心</h1><p>　　越成长越希望坦然面对自己。我原本就是个家庭教育基本为零的街边小混混，不小心在学校里多呆了几年，认识了一大帮牛逼的同学和一大帮好哥们。以我的成长环境而言，正常的人生轨迹就是在小县城里开个小店子做点小生意，完事了。自己硬要跑出来，每一件事都是自己选择的，酸甜苦辣各中滋味，自己知晓。<br>　　我在乎钱么？不那么在乎，穷了很久好像也没什么事情是过不去的。我在乎名声么？好像也不那么在乎，绝大多数时候都保持沉默，他人爱说啥爱咋想影响不到自己。到底在乎什么？想来想去只有两条，至少要让自己和自己身边的人的生活变得更好，至少对得起几年前那个决绝而坚定的自己。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">船</span><br><span class="line">他往我这岸漂来</span><br><span class="line">身上满载的是风采</span><br><span class="line">不见他手中的舵</span><br><span class="line">就像他的来只为我而来</span><br><span class="line">我跳上他的船</span><br><span class="line">开始了没有忽高忽低</span><br><span class="line">却温暖的精彩</span><br><span class="line">那原来都是他把春天</span><br><span class="line">藏在从未打开的口袋</span><br><span class="line">我爱上他的爱</span><br><span class="line">原以为失去拥抱的心</span><br><span class="line">终究不能慷慨</span><br><span class="line">那原来只是冬天的冰冷</span><br><span class="line">借住在我心里的残骸</span><br></pre></td></tr></table></figure><p>　　就写这么多吧。<br>　　2016年最后一天@帝都朝阳</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;你别无选择——这就是命运的题旨所在。正如一个农民春种夏耘，到头一场灾害颗粒无收，他也不会为此而将春种夏耘而不管秋天的收成如何。 　　　　　　—路遥&lt;/p&gt;</summary>
    
    
    
    
    <category term="From Qzone" scheme="https://wangzitian0.github.io/tags/From-Qzone/"/>
    
  </entry>
  
  <entry>
    <title>CSS样式笔记</title>
    <link href="https://wangzitian0.github.io/2016/09/20/CSS-style-notes/"/>
    <id>https://wangzitian0.github.io/2016/09/20/CSS-style-notes/</id>
    <published>2016-09-20T11:06:00.000Z</published>
    <updated>2020-09-30T04:59:07.877Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下近期写 css 用到的一些属性。然后把相关的东西仔细查了一下。</p><a id="more"></a><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><h2 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a>基本常识</h2><h3 id="选择器大小写不敏感"><a href="#选择器大小写不敏感" class="headerlink" title="选择器大小写不敏感"></a>选择器大小写不敏感</h3><p>选择器语法不是大小写敏感的，a:hover等价于a:HOVER，但标签名和属性名以及属性值是大小写敏感的（取决于HTML，必须保持一致）</p><h3 id="选择器的分类"><a href="#选择器的分类" class="headerlink" title="选择器的分类"></a>选择器的分类</h3><p>type selector——类型选择器（标记选择器）<br>universal selector——通配选择器<br>attribute selector——属性选择器<br>class selector——类选择器<br>ID selector——ID选择器<br>pseudo-class——伪类</p><h3 id="伪类-amp-amp-伪元素"><a href="#伪类-amp-amp-伪元素" class="headerlink" title="伪类&amp;&amp;伪元素"></a>伪类&amp;&amp;伪元素</h3><p>形式上，伪类有一个冒号，而伪元素有两个冒号。</p><p>意义上，伪类相当于给现有元素添加了class属性值，而伪元素相当于创建了一个新的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p:first-child匹配p的第一个子元素，相当给第一个子元素设置了匿名class；</span><br><span class="line">p::first-line匹配段落第一行内容，相当于创建了一个span）</span><br><span class="line">特别的，伪类要遵循LVHA爱恨原则；</span><br><span class="line">before, after不是伪类而是伪元素（最容易混淆，原因是浏览器兼容问题——某些浏览器不支持双冒号）</span><br></pre></td></tr></table></figure><h3 id="选择器特殊性计算"><a href="#选择器特殊性计算" class="headerlink" title="选择器特殊性计算"></a>选择器特殊性计算</h3><p>特殊性高的样式会覆盖特殊性低的样式，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#cnblogspost_body &gt; p          &#123;&#x2F;*style1*&#x2F;&#125;</span><br><span class="line">p                              &#123;&#x2F;*style2*&#x2F;&#125;</span><br><span class="line">&#123;&#x2F;*共存时，表现出来的是特殊性更高的style1，*&#x2F;&#125;</span><br></pre></td></tr></table></figure><p>特殊性的计算规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; ID选择器的个数</span><br><span class="line">b &#x3D; （类选择器 + 属性选择器 + 伪类）的个数</span><br><span class="line">c &#x3D; （标记选择器 + 伪元素）的个数</span><br></pre></td></tr></table></figure><p>P.S.1.忽略通配选择器</p><p>P.S.2.取反选择器不算数（取反选择器本身不计入伪类的个数，但左右的都算），例如#s12:not(FOO) /* a=1 b=0 c=1 -&gt; specificity = 101 */</p><p>P.S.3.重复出现相同的简单选择器都算有效计数</p><h2 id="常用选择器"><a href="#常用选择器" class="headerlink" title="常用选择器"></a>常用选择器</h2><table><thead><tr><th align="left">选择器</th><th align="left">例子</th><th align="left">例子描述</th><th align="left">CSS</th></tr></thead><tbody><tr><td align="left">.class</td><td align="left">.intro</td><td align="left">选择 class=”intro” 的所有元素。</td><td align="left">1</td></tr><tr><td align="left">#id</td><td align="left">#firstname</td><td align="left">选择 id=”firstname” 的所有元素。</td><td align="left">1</td></tr><tr><td align="left">*</td><td align="left">*</td><td align="left">选择所有元素。</td><td align="left">2</td></tr><tr><td align="left">element</td><td align="left">p</td><td align="left">选择所有 <code>&lt;p&gt;</code> 元素。</td><td align="left">1</td></tr><tr><td align="left">element,element</td><td align="left">div,p</td><td align="left">选择所有 <code>&lt;div&gt;</code> 元素和所有 <code>&lt;p&gt;</code> 元素。</td><td align="left">1</td></tr><tr><td align="left">element element</td><td align="left">div p</td><td align="left">选择 <code>&lt;div&gt;</code> 元素内部的所有 <code>&lt;p&gt;</code> 元素。</td><td align="left">1</td></tr><tr><td align="left">element&gt;element</td><td align="left">div&gt;p</td><td align="left">选择父元素为 <code>&lt;div&gt;</code> 元素的所有 <code>&lt;p&gt;</code> 元素。</td><td align="left">2</td></tr><tr><td align="left">element+element</td><td align="left">div+p</td><td align="left">选择紧接在 <code>&lt;div&gt;</code> 元素之后的所有 <code>&lt;p&gt;</code> 元素。</td><td align="left">2</td></tr><tr><td align="left">[attribute]</td><td align="left">[target]</td><td align="left">选择带有 target 属性所有元素。</td><td align="left">2</td></tr><tr><td align="left">[attribute=value]</td><td align="left">[target=_blank]</td><td align="left">选择 target=”_blank” 的所有元素。</td><td align="left">2</td></tr><tr><td align="left">[attribute~=value]</td><td align="left">[title~=flower]</td><td align="left">选择 title 属性包含单词 “flower” 的所有元素。</td><td align="left">2</td></tr><tr><td align="left">[attribute&#124;=value]</td><td align="left">[lang&#124;=en]</td><td align="left">选择 lang 属性值以 “en” 开头的所有元素。</td><td align="left">2</td></tr><tr><td align="left">:link</td><td align="left">a:link</td><td align="left">选择所有未被访问的链接。</td><td align="left">1</td></tr><tr><td align="left">:visited</td><td align="left">a:visited</td><td align="left">选择所有已被访问的链接。</td><td align="left">1</td></tr><tr><td align="left">:active</td><td align="left">a:active</td><td align="left">选择活动链接。</td><td align="left">1</td></tr><tr><td align="left">:hover</td><td align="left">a:hover</td><td align="left">选择鼠标指针位于其上的链接。</td><td align="left">1</td></tr><tr><td align="left">:focus</td><td align="left">input:focus</td><td align="left">选择获得焦点的 input 元素。</td><td align="left">2</td></tr><tr><td align="left">:first-letter</td><td align="left">p:first-letter</td><td align="left">选择每个 <code>&lt;p&gt;</code> 元素的首字母。</td><td align="left">1</td></tr><tr><td align="left">:first-line</td><td align="left">p:first-line</td><td align="left">选择每个 <code>&lt;p&gt;</code> 元素的首行。</td><td align="left">1</td></tr><tr><td align="left">:first-child</td><td align="left">p:first-child</td><td align="left">选择属于父元素的第一个子元素的每个 <code>&lt;p&gt;</code> 元素。</td><td align="left">2</td></tr><tr><td align="left">:before</td><td align="left">p:before</td><td align="left">在每个 <code>&lt;p&gt;</code> 元素的内容之前插入内容。</td><td align="left">2</td></tr><tr><td align="left">:after</td><td align="left">p:after</td><td align="left">在每个 <code>&lt;p&gt;</code> 元素的内容之后插入内容。</td><td align="left">2</td></tr><tr><td align="left">:lang(language)</td><td align="left">p:lang(it)</td><td align="left">选择带有以 “it” 开头的 lang 属性值的每个 <code>&lt;p&gt;</code> 元素。</td><td align="left">2</td></tr><tr><td align="left">element1~element2</td><td align="left">p~ul</td><td align="left">选择前面有 <code>&lt;p&gt;</code> 元素的每个 <ul> 元素。</td><td align="left">3</td></tr><tr><td align="left">[attribute^=value]</td><td align="left">a[src^=”https”]</td><td align="left">选择其 src 属性值以 “https” 开头的每个 <code>&lt;a&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">[attribute$=value]</td><td align="left">a[src$=”.pdf”]</td><td align="left">选择其 src 属性以 “.pdf” 结尾的所有 <code>&lt;a&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">[attribute*=value]</td><td align="left">a[src*=”abc”]</td><td align="left">选择其 src 属性中包含 “abc” 子串的每个 <code>&lt;a&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">:first-of-type</td><td align="left">p:first-of-type</td><td align="left">选择属于其父元素的首个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">:last-of-type</td><td align="left">p:last-of-type</td><td align="left">选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">:only-of-type</td><td align="left">p:only-of-type</td><td align="left">选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">:only-child</td><td align="left">p:only-child</td><td align="left">选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">:nth-child(n)</td><td align="left">p:nth-child(2)</td><td align="left">选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">:nth-last-child(n)</td><td align="left">p:nth-last-child(2)</td><td align="left">同上，从最后一个子元素开始计数。</td><td align="left">3</td></tr><tr><td align="left">:nth-of-type(n)</td><td align="left">p:nth-of-type(2)</td><td align="left">选择属于其父元素第二个 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">:nth-last-of-type(n)</td><td align="left">p:nth-last-of-type(2)</td><td align="left">同上，但是从最后一个子元素开始计数。</td><td align="left">3</td></tr><tr><td align="left">:last-child</td><td align="left">p:last-child</td><td align="left">选择属于其父元素最后一个子元素每个 <code>&lt;p&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">:root</td><td align="left">:root</td><td align="left">选择文档的根元素。</td><td align="left">3</td></tr><tr><td align="left">:empty</td><td align="left">p:empty</td><td align="left">选择没有子元素的每个 <code>&lt;p&gt;</code> 元素（包括文本节点）。</td><td align="left">3</td></tr><tr><td align="left">:target</td><td align="left">#news:target</td><td align="left">选择当前活动的 #news 元素。</td><td align="left">3</td></tr><tr><td align="left">:enabled</td><td align="left">input:enabled</td><td align="left">选择每个启用的 <code>&lt;input&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">:disabled</td><td align="left">input:disabled</td><td align="left">选择每个禁用的 <code>&lt;input&gt;</code> 元素</td><td align="left">3</td></tr><tr><td align="left">:checked</td><td align="left">input:checked</td><td align="left">选择每个被选中的 <code>&lt;input&gt;</code> 元素。</td><td align="left">3</td></tr><tr><td align="left">:not(selector)</td><td align="left">:not(p)</td><td align="left">选择非 <code>&lt;p&gt;</code> 元素的每个元素。</td><td align="left">3</td></tr><tr><td align="left">::selection</td><td align="left">::selection</td><td align="left">选择被用户选取的元素部分。</td><td align="left">3</td></tr></tbody></table><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h2 id="flex笔记"><a href="#flex笔记" class="headerlink" title="flex笔记"></a>flex笔记</h2><p>现在的浏览器对 flex 的支持非常好，因此如果不能一眼想好怎么用 absolute 和 float 实现的布局都可以使用 flex。</p><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在任何流动的方向上(包括上下左右)都能进行良好的布局</span><br><span class="line">可以以逆序 或者 以任意顺序排列布局</span><br><span class="line">可以线性的沿着主轴一字排开 或者 沿着侧轴换行排列</span><br><span class="line">可以弹性的在任意的容器中伸缩大小（今天重点研究的主题）</span><br><span class="line">可以使子元素们在容器主轴方向上 或者 在容器侧轴方向上 进行对齐</span><br><span class="line">可以动态的 沿着主轴方向 伸缩子级的尺寸，与此同时保证父级侧轴方向上的尺寸</span><br></pre></td></tr></table></figure><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</li><li>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。<ul><li>主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；</li><li>交叉轴的开始位置叫做cross start，结束位置叫做cross end。</li></ul></li><li>项目默认沿主轴排列。</li><li>单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。<br>阮老师的两篇文章：</li></ul><p>这一篇可以当字典用 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局教程</a></p><p>这一篇可以辅助理解 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html">Flex 布局教程</a></p><h3 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">主轴的方向</span><br><span class="line">flex-direction: row | row-reverse | column | column-reverse;</span><br><span class="line">如何换行</span><br><span class="line">flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">主轴对齐方式</span><br><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">交叉轴如何对齐</span><br><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">多根轴线的对齐方式</span><br><span class="line">align-content</span><br><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line"></span><br><span class="line">flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。</span><br><span class="line">存在剩余空间，放大flex-grow倍，默认为0，即如果存在剩余空间，也不放大。</span><br><span class="line">空间不足，缩小flex-shrink倍，默认为1，即如果空间不足，该项目将缩小。</span><br><span class="line">分配多余空间之前项目占据的主轴空间flex-basis。默认值为auto，即项目的本来大小。</span><br><span class="line">flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]</span><br></pre></td></tr></table></figure><h1 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h1><h2 id="常用常查的"><a href="#常用常查的" class="headerlink" title="常用常查的"></a>常用常查的</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">border-radius: 30px;</span><br><span class="line">圆角</span><br><span class="line">box-shadow: 3px 3px 4px #ffffff; </span><br><span class="line">盒状阴影|  x轴偏移值、y轴偏移值、阴影的模糊度、以及阴影颜色。</span><br><span class="line">background: linear-gradient(to bottom, blue, white);</span><br><span class="line">background: linear-gradient(&lt;angle&gt;, blue, white 80%, orange);</span><br><span class="line">线性渐变</span><br><span class="line">background: linear-gradient(to right, rgba(255,255,255,0), rgba(255,255,255,1)), url(http:&#x2F;&#x2F;foo.com&#x2F;image.jpg);</span><br><span class="line">图片线性渐变透明 | 0为透明，1为不透</span><br><span class="line">background: repeating-linear-gradient(-45deg, red, red 5px, white 5px, white 10px);</span><br><span class="line">重复的线性渐变</span><br><span class="line"></span><br><span class="line">background: radial-gradient(red 5%, yellow 25%, #1E90FF 50%);</span><br><span class="line">径向渐变</span><br><span class="line">background: radial-gradient(ellipse closest-side, red, yellow 10%, #1E90FF 50%, white);</span><br><span class="line">椭圆的渐变</span><br><span class="line">background: repeating-radial-gradient(black, black 5px, white 5px, white 10px);</span><br><span class="line">重复的径向渐变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">background-color: rgba(180, 180, 144, 0.6); </span><br><span class="line">opacity:0.5;</span><br><span class="line">透明度</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="http://www.daqianduan.com/2959.html">旋转拉伸</a></p><p>可以实现立体效果，远近效果，3D房间效果等等</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="compass"><a href="#compass" class="headerlink" title="compass"></a>compass</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;compass&#x2F;css3&quot;;</span><br><span class="line">.rounded &#123;</span><br><span class="line">    @include border-radius(5px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成如下代码，帮助做好适配工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.rounded &#123;</span><br><span class="line">    -moz-border-radius: 5px;</span><br><span class="line">    -webkit-border-radius: 5px;</span><br><span class="line">    -o-border-radius: 5px;</span><br><span class="line">    -ms-border-radius: 5px;</span><br><span class="line">    -khtml-border-radius: 5px;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更加具体的介绍可以看这个链接： <a href="https://ruby-china.org/topics/4396">SASS 和 Compass 指南</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下近期写 css 用到的一些属性。然后把相关的东西仔细查了一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTML" scheme="https://wangzitian0.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Golang 笔记</title>
    <link href="https://wangzitian0.github.io/2016/09/04/Golang-notes/"/>
    <id>https://wangzitian0.github.io/2016/09/04/Golang-notes/</id>
    <published>2016-09-04T12:50:00.000Z</published>
    <updated>2020-09-30T04:59:07.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><p>golang 的一些杂七杂八的笔记</p><a id="more"></a><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以执行一句话之后根据结果作条件判断</span><br><span class="line">if num :&#x3D; 9; num &lt; 0 &#123;</span><br><span class="line">fmt.Println(num, &quot;is negative&quot;)</span><br><span class="line">&#125; else if num &lt; 10 &#123;</span><br><span class="line">fmt.Println(num, &quot;has 1 digit&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(num, &quot;has multiple digits&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优美的常量"><a href="#优美的常量" class="headerlink" title="优美的常量"></a>优美的常量</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    CategoryBooks    &#x3D; 0</span><br><span class="line">    CategoryHealth   &#x3D; 1</span><br><span class="line">    CategoryClothing &#x3D; 2</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;自增长</span><br><span class="line">const (</span><br><span class="line">    CategoryBooks &#x3D; iota &#x2F;&#x2F; 0</span><br><span class="line">    CategoryHealth       &#x2F;&#x2F; 1</span><br><span class="line">    CategoryClothing     &#x2F;&#x2F; 2</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="hint"><a href="#hint" class="headerlink" title="hint"></a>hint</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">    _           &#x3D; iota </span><br><span class="line">    &#x2F;&#x2F; ignore first value by assigning to blank identifier</span><br><span class="line">    KB ByteSize &#x3D; 1 &lt;&lt; (10 * iota) &#x2F;&#x2F; 1 &lt;&lt; (10*1)</span><br><span class="line">    MB                                   &#x2F;&#x2F; 1 &lt;&lt; (10*2)</span><br><span class="line">    GB                                   &#x2F;&#x2F; 1 &lt;&lt; (10*3)</span><br><span class="line">    TB                                   &#x2F;&#x2F; 1 &lt;&lt; (10*4)</span><br><span class="line">    PB                                   &#x2F;&#x2F; 1 &lt;&lt; (10*5)</span><br><span class="line">    EB                                   &#x2F;&#x2F; 1 &lt;&lt; (10*6)</span><br><span class="line">    ZB                                   &#x2F;&#x2F; 1 &lt;&lt; (10*7)</span><br><span class="line">    YB                                   &#x2F;&#x2F; 1 &lt;&lt; (10*8)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;每一行的 iota 值是相等的</span><br><span class="line">const (</span><br><span class="line">    Apple, Banana &#x3D; iota + 1, iota + 2</span><br><span class="line">    Cherimoya, Durian</span><br><span class="line">    Elderberry, Fig</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F;另外，如果一个函数以 int 作为它的参数而不是 Datatype，如果你给它传递一个 Datatype，它将在编译器期出现问题</span><br><span class="line">&#x2F;&#x2F;cannot use i (type int) as type Datatype in argument to balabala</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">func Info(o interface&#123;&#125;) &#123;</span><br><span class="line">    t :&#x3D; reflect.TypeOf(o)         &#x2F;&#x2F;获取接口的类型</span><br><span class="line">    fmt.Println(&quot;Type:&quot;, t.Name()) &#x2F;&#x2F;t.Name() 获取接口的名称</span><br><span class="line"></span><br><span class="line">    if t.Kind() !&#x3D; refelct.Struct &#123; &#x2F;&#x2F;通过Kind()来判断反射出的类型是否为需要的类型</span><br><span class="line">        fmt.Println(&quot;err: type invalid!&quot;)        </span><br><span class="line">        return</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    v :&#x3D; reflect.ValueOf(o) &#x2F;&#x2F;获取接口的值类型</span><br><span class="line">    fmt.Println(&quot;Fields:&quot;)</span><br><span class="line"></span><br><span class="line">    for i :&#x3D; 0; i &lt; t.NumField(); i++ &#123; &#x2F;&#x2F;NumField取出这个接口所有的字段数量</span><br><span class="line">    f :&#x3D; t.Field(i)                                   &#x2F;&#x2F;取得结构体的第i个字段</span><br><span class="line">    val :&#x3D; v.Field(i).Interface()                     &#x2F;&#x2F;取得字段的值</span><br><span class="line">    fmt.Printf(&quot;%6s: %v &#x3D; %v\n&quot;, f.Name, f.Type, val) &#x2F;&#x2F;第i个字段的名称,类型,值</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for i :&#x3D; 0; i &lt; t.NumMethod(); i++&#123;</span><br><span class="line">        m :&#x3D; t.Method(i)</span><br><span class="line">        fmt.Printf(&quot;%6s: %v\n&quot;, m.Name,m.Type) &#x2F;&#x2F;获取方法的名称和类型       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="通过反射改对象"><a href="#通过反射改对象" class="headerlink" title="通过反射改对象"></a>通过反射改对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func SetInfo(o interface&#123;&#125;) &#123;</span><br><span class="line">        v :&#x3D; reflect.ValueOf(o)</span><br><span class="line"></span><br><span class="line">        if v.Kind() &#x3D;&#x3D; reflect.Ptr &amp;&amp; !v.Elem().CanSet() &#123; &#x2F;&#x2F;判断是否为指针类型 元素是否可以修改</span><br><span class="line">            fmt.Println(&quot;cannot set&quot;)</span><br><span class="line">                return</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            v &#x3D; v.Elem() &#x2F;&#x2F;实际取得的对象</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;判断字段是否存在</span><br><span class="line">        f :&#x3D; v.FieldByName(&quot;Name&quot;)</span><br><span class="line">        if !f.IsValid() &#123;</span><br><span class="line">            fmt.Println(&quot;wuxiao&quot;)</span><br><span class="line">                return</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;设置字段</span><br><span class="line">        if f :&#x3D; v.FieldByName(&quot;Name&quot;); f.Kind() &#x3D;&#x3D; reflect.String &#123;</span><br><span class="line">            f.SetString(&quot;BY&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射动态调用"><a href="#反射动态调用" class="headerlink" title="反射动态调用"></a>反射动态调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;u 是一个 interface&#123;&#125;</span><br><span class="line">v :&#x3D; reflect.ValueOf(u)</span><br><span class="line">...</span><br><span class="line">make sure v is a reflect.Struct </span><br><span class="line">mv :&#x3D; v.MethodByName(&quot;Hello&quot;) &#x2F;&#x2F;获取对应的方法</span><br><span class="line">...</span><br><span class="line">make sure mv is exsit</span><br><span class="line">res :&#x3D; mv.Call(args)</span><br></pre></td></tr></table></figure><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><h4 id="json-to-struct"><a href="#json-to-struct" class="headerlink" title="json to struct"></a>json to struct</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果在我们不知道他的结构的情况下，我们把他解析到interface&#123;&#125;里面</span><br><span class="line"></span><br><span class="line">b :&#x3D; []byte(&#96;&#123;&quot;Name&quot;:&quot;Wednesday&quot;,&quot;Age&quot;:6,&quot;Parents&quot;:[&quot;Gomez&quot;,&quot;Morticia&quot;]&#125;&#96;)</span><br><span class="line">var f interface&#123;&#125;</span><br><span class="line">err :&#x3D; json.Unmarshal(b, &amp;f)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;结果如下</span><br><span class="line">f &#x3D; map[string]interface&#123;&#125;&#123;</span><br><span class="line">&quot;Name&quot;: &quot;Wednesday&quot;,</span><br><span class="line">&quot;Age&quot;:  6,</span><br><span class="line">&quot;Parents&quot;: []interface&#123;&#125;&#123;</span><br><span class="line">&quot;Gomez&quot;,</span><br><span class="line">&quot;Morticia&quot;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">m :&#x3D; f.(map[string]interface&#123;&#125;)</span><br><span class="line"></span><br><span class="line">for k, v :&#x3D; range m &#123;</span><br><span class="line">switch vv :&#x3D; v.(type) &#123;</span><br><span class="line">        &#x2F;&#x2F; balabala</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="struct-to-json"><a href="#struct-to-json" class="headerlink" title="struct to json"></a>struct to json</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var s Serverslice</span><br><span class="line">s.Servers &#x3D; append(s.Servers, Server&#123;ServerName: &quot;Shanghai_VPN&quot;, ServerIP: &quot;127.0.0.1&quot;&#125;)</span><br><span class="line">s.Servers &#x3D; append(s.Servers, Server&#123;ServerName: &quot;Beijing_VPN&quot;, ServerIP: &quot;127.0.0.2&quot;&#125;)</span><br><span class="line">b, err :&#x3D; json.Marshal(s)</span><br><span class="line">   &#x2F;&#x2F;  assert(balabala)</span><br><span class="line">fmt.Println(string(b))</span><br></pre></td></tr></table></figure><h4 id="auto-marshal-amp-unmarshal"><a href="#auto-marshal-amp-unmarshal" class="headerlink" title="auto marshal &amp; unmarshal"></a>auto marshal &amp; unmarshal</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">type Server struct &#123;</span><br><span class="line">&#x2F;&#x2F; ID 不会导出到JSON中</span><br><span class="line">ID int &#96;json:&quot;-&quot;&#96;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ServerName2 的值会进行二次JSON编码</span><br><span class="line">ServerName  string &#96;json:&quot;serverName&quot;&#96;</span><br><span class="line">ServerName2 string &#96;json:&quot;serverName2,string&quot;&#96;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果 ServerIP 为空，则不输出到JSON串中</span><br><span class="line">ServerIP   string &#96;json:&quot;serverIP,omitempty&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s :&#x3D; Server &#123;</span><br><span class="line">ID:         3,</span><br><span class="line">ServerName:  &#96;Go &quot;1.0&quot; &#96;,</span><br><span class="line">ServerName2: &#96;Go &quot;1.0&quot; &#96;,</span><br><span class="line">ServerIP:   &#96;&#96;,</span><br><span class="line">&#125;</span><br><span class="line">b, _ :&#x3D; json.Marshal(s)</span><br><span class="line">os.Stdout.Write(b)</span><br></pre></td></tr></table></figure><h3 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h3><p>s:=”Go编程” fmt.Println(len(s)) 输出结果应该是8因为中文字符是用3个字节存的。</p><p>len(string(rune(‘编’)))的结果是3</p><p>如果想要获得我们想要的情况的话，需要先转换为rune切片再使用内置的len函数</p><p>fmt.Println(len([]rune(s)))</p><p>所以用string存储unicode的话，如果有中文，按下标是访问不到的，因为你只能得到一个byte。 要想访问中文的话，还是要用rune切片，这样就能按下表访问。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基本语句&quot;&gt;&lt;a href=&quot;#基本语句&quot; class=&quot;headerlink&quot; title=&quot;基本语句&quot;&gt;&lt;/a&gt;基本语句&lt;/h2&gt;&lt;p&gt;golang 的一些杂七杂八的笔记&lt;/p&gt;</summary>
    
    
    
    
    <category term="Language" scheme="https://wangzitian0.github.io/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript教程&amp;笔记</title>
    <link href="https://wangzitian0.github.io/2016/07/26/JavaScript-notes/"/>
    <id>https://wangzitian0.github.io/2016/07/26/JavaScript-notes/</id>
    <published>2016-07-26T09:19:00.000Z</published>
    <updated>2020-09-30T04:59:07.879Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过不少的python和c＋＋代码，近期开始正式的学习javascript，做了一些笔记。重点记录和c＋＋不同的部分</p><a id="more"></a><h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript标准。最新版ECMAScript 6标准（简称ES6）已经在2015年6月正式发布了，所以，讲到JavaScript的版本，实际上就是说它实现了ECMAScript标准的哪个版本。</p><h2 id="开始编程"><a href="#开始编程" class="headerlink" title="开始编程"></a>开始编程</h2><ul><li>JavaScript代码可以直接嵌在网页的任何地方，不过通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中.</li><li>把JavaScript代码放到一个单独的.js文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件.</li><li>JavaScript引擎有一个在行末自动添加分号的机制,可能让你栽到大坑.</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p>NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示.</p></li><li><p>Infinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity.</p></li><li><p>%是求余运算.</p></li><li><p>字符串单双引号都可以<code>&#39;abc&#39;，&quot;xyz&quot;</code></p></li><li><p>与或非和c++, java 一样</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3></li><li><p>两种比较运算符</p></li><li><p>由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较.(<code>&quot;==&quot; 只要求值相等; &quot;===&quot; 要求值和类型都相</code>)</p><blockquote><p>第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；<br>第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。</p></blockquote></li><li><p>NaN这个特殊的Number与所有其他值都不相等，包括它自己<br><code>NaN === NaN; // false</code></p></li><li><p>唯一能判断NaN的方法是通过isNaN()函数<br><code>isNaN(NaN); // true</code></p></li></ul><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><ul><li><p>null表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。</p><blockquote><p>在其他语言中，也有类似JavaScript的null的表示，例如Java也用null，Swift用nil，Python用None表示。</p></blockquote></li><li><p>和null类似的undefined，它表示“未定义”。</p><blockquote><p>JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。</p></blockquote></li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>变量名是大小写英文、数字、$和_的组合，且不能用数字开头。</li><li>如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量<blockquote><p>ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。启用strict模式的方法是在JavaScript代码的第一行写上：<br><code>&#39;use strict&#39;;</code></p></blockquote></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>直接给Array的length赋一个新的值会导致Array大小的变化</li><li>如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化<br><code>var arr = [1, 2, 3]; arr[5] = &#39;x&#39;; arr; // arr变为[1, 2, 3, undefined, undefined, &#39;x&#39;]</code></li></ul><h3 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a>标准函数</h3><p><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449921138898cdeb7fc2214dc08c6c67827758cd2f000">参考这个链接</a></p><ul><li><code>arr.indexOf(p);</code> // 返回元素p在数组中的索引，返回[-1,n-1],没有找到返回-1</li><li><code>arr.slice(s, t);</code>//返回subsequece，前闭后开，t可以省略</li><li><code>arr.push(p0, p1);arr.pop()</code>//类似于栈。空数组继续pop不会报错，而是返回undefined</li><li><code>arr.unshift(&#39;A&#39;, &#39;B&#39;); arr.shift();</code>//同上，但是在下标靠近0的一侧。</li><li><code>arr.sort(cmp);arr.reverse()</code>//排序函数，倒置函数，cmp可以是三目函数。</li><li><code>arr.splice(s, l, p0, p1, p2);</code>//从数组第s个位置开始删除l个元素，并插入p1 p2 …</li><li><code>arr.concat([p0, p1, p2...])</code>//连接两个数组</li><li><code>arr.join(&#39;-&#39;);</code> //将数组用分隔符连接 ‘A-B-C-1-2-3’</li></ul><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li><code>xiaohong[&#39;middle-school&#39;]; xiaohong.name; </code>//middle-school不是一个有效的变量，就需要用’’括起来</li><li>访问不存在的属性不报错，而是返回undefined.</li><li><code>xiaoming.age = 18; </code>// 新增一个age属性</li><li><code>delete xiaoming.age;</code> // 删除age属性,删除一个不存在的school属性也不会报错</li><li><code>&#39;name&#39; in xiaoming;</code> 检测是否拥有某一属性，可以用in操作。但是这个属性可能是继承得到的。</li><li><code>xiaoming.hasOwnProperty(&#39;name&#39;);</code> //可以用hasOwnProperty()方法严格判断是非拥有属性</li></ul><h2 id="判断-amp-循环"><a href="#判断-amp-循环" class="headerlink" title="判断&amp;循环"></a>判断&amp;循环</h2><ul><li><code>for (var i=1; i&lt;=10000; i++) &#123;&#125;</code></li><li><code>for (i=0; i&lt;arr.length; i++) &#123;&#125;</code></li><li><code>for (;;) &#123;&#125;</code>//equal while(true)</li><li><code>for (var key in object) &#123;if (o.hasOwnProperty(key)) &#123; &#125;&#125;</code>// iterator object</li><li><code>for (var key in list)&#123;&#125;</code>// iterator list</li><li><code>while()&#123;&#125; do&#123;&#125;while()</code>//same with c++/java</li></ul><h2 id="Map和Set"><a href="#Map和Set" class="headerlink" title="Map和Set"></a>Map和Set</h2><h3 id="define"><a href="#define" class="headerlink" title="define"></a>define</h3><ul><li><p><code>var m = new Map([[&#39;Michael&#39;, 95], [&#39;Bob&#39;, 75], [&#39;Tracy&#39;, 85]]);</code></p></li><li><p><code>var s = new Set([1, 2, 3, 3, &#39;3&#39;]);</code></p></li><li><p>var m = new Map();</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3></li><li><p><code>m.set(&#39;Adam&#39;, 67);</code></p></li><li><p><code>m.has(&#39;Adam&#39;);</code> // 是否存在key ‘Adam’: true</p></li><li><p><code>m.get(&#39;Adam&#39;);</code> // 67,maybe undefined</p></li><li><p><code>m.delete(&#39;Adam&#39;);</code> // 删除key ‘Adam’</p></li><li><p><code>a.forEach(function (element, index, array) &#123;&#125;);</code>// element: 指向当前元素的值, index: 指向当前索, array: 指向Array对象本身</p></li><li><p><code>m.forEach(function (value, key, map) &#123;&#125;);</code>//v k map, 和set一样，set的kv同时返回v</p></li><li><p><code>for (var x of a) &#123;&#125;</code>// ES6</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><ul><li><code>var abs = function (x) &#123;&#125;;</code>//需要在函数体末尾加一个<code>;</code>表示赋值语句结束.</li><li><code>function abs(x) &#123;&#125;</code></li><li>如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined.</li><li>允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数</li><li>传入的参数比定义的少,参数x将收到undefined</li></ul><h3 id="arguments-amp-rest"><a href="#arguments-amp-rest" class="headerlink" title="arguments &amp; rest"></a>arguments &amp; rest</h3><ul><li>只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array</li><li><code>arguments.length === 2</code>//arguments最常用于判断传入参数的个数。</li><li><code>function foo(a, b, ...rest)</code>//ES6</li><li></li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul><li>JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行.</li><li>函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部. so 在函数内部首先申明所有变量.</li><li>顶层函数的定义也被视为一个全局变量，并绑定到window对象</li><li><code>for (let i=0; i&lt;100; i++)&#123;&#125;</code> //ES6, let替代var可以申明一个块级作用域的变</li><li><code>const PI = 3.14;</code> 通常用全部大写的变量来表示“这是一个常量，不要修改它的值,ES6标准引入了新的关键字const来定义常量.</li><li>在一个方法内部，this是一个特殊变量，它始终指向当前对象</li><li>单独调用方法函数，此时，该函数的this指向全局对象，也就是window</li><li><code>var fn = xiaoming.age; fn();</code>// 先拿到xiaoming的age函数,retuen NaN,要保证this指向正确，必须用obj.xxx()的形式调用</li><li><code>Math.max.apply(null, [3, 5, 4]);</code> // 5,函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</li><li><code>Math.max.call(null, 3, 5, 4);</code>// 5, same with apply()<blockquote><p>装饰器<br><code>var count = 0; var oldParseInt = parseInt; // 保存原函数 window.parseInt = function () &#123;  count += 1;  return oldParseInt.apply(null, arguments); // 调用原函数 &#125;;</code></p></blockquote></li></ul><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><ul><li><code>function add(x, y, f) &#123;return f(x) + f(y);&#125;</code>//一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数</li><li><code>arr.map(String);</code>//把f(x)作用在Array的每一个元素并把结果生成一个新的Array</li><li><code>arr.reduce(function (x, y) &#123;return x + y;&#125;);</code>//把结果继续和序列的下一个元素做累积计算</li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li>除了可以接受函数作为参数外，还可以把函数作为结果值返回。</li><li>相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”.换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。</li><li>当我们调用lazy_func()时，每次调用都会返回一个新的函数，即使传入相同的参数</li><li>当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来不容易。</li><li>返回函数不要引用任何循环变量，或者后续会发生变化的变量。再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变.</li><li><code>(function (x) &#123; return x * x &#125;) (3);</code>//创建一个匿名函数并立刻执行</li><li><code>x =&gt; (&#123; foo: x &#125;)</code>//返回一个对象. 参数不是一个，需要用括号()括起来.</li><li><code>var that = this;</code>//hack function scope changed</li><li>generator由function<em>定义（注意多出的</em>号），并且，除了return语句，还可以用<code>yield</code>返回多次。返回一个对象<code>&#123;value: x, done: true/false&#125;</code></li></ul><h2 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h2><h3 id="Base"><a href="#Base" class="headerlink" title="Base"></a>Base</h3><ul><li>在JavaScript的世界里，一切都是对象。</li><li>number、string、boolean、function和undefined有别于其他类型。特别注意null的类型是object，Array的类型也是object，如果我们用typeof将无法区分出null、Array和通常意义上的object——{}。</li><li>new String(‘str’) === ‘str’; // false,闲的蛋疼也不要使用包装对象！尤其是针对string类型！！！<blockquote><p>总结一下，有这么几条规则需要遵守：</p></blockquote></li><li>不要使用new Number()、new Boolean()、new String()创建包装对象；</li><li>用parseInt()或parseFloat()来转换任意类型到number；<br>用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；</li><li>通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；</li><li>typeof操作符可以判断出number、boolean、string、function和undefined；</li><li>判断Array要使用Array.isArray(arr)；</li><li>判断null请使用myVar === null；</li><li>判断某个全局变量是否存在用typeof window.myVar === ‘undefined’.</li><li><code>(123).toString();</code> // ‘123’</li><li><code>var b2 = Boolean(&#39;false&#39;);</code> // true!</li><li><code>var s = String(123.45);</code> // ‘123.45’</li><li><code>var n = Number(&#39;123&#39;);</code> // 123，相当于parseInt()或parseFloat()</li></ul><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><ul><li><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499525761186acdd5ac3a44f8a50cc0ed8606139b000">日期时间入门</a></li><li><a href="http://www.w3school.com.cn/jsref/jsref_obj_date.asp">日期时间参考文档</a></li></ul><p>##Reg Exp</p><ul><li><p><code>var re2 = new RegExp(&#39;ABC\\-001&#39;);</code></p></li><li><p><code>var re1 = /ABC\-001/;</code></p></li><li><p><code>var re = /^\d&#123;3&#125;\-\d&#123;3,8&#125;$/; re.test(&#39;010-12345&#39;); // true re.test(&#39;010-1234x&#39;); // false</code></p></li><li><p><code>&#39;a,b, c  d&#39;.split(/[\s\,]+/);</code> // [‘a’, ‘b’, ‘c’, ‘d’]</p></li><li><p><code>var re = /^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/; re.exec(&#39;010-12345&#39;); // [&#39;010-12345&#39;, &#39;010&#39;, &#39;12345&#39;] re.exec(&#39;010 12345&#39;); // null</code>exec()方法在匹配成功后，会返回一个Array，表示匹配成功的子串,失败时返回null。</p></li><li><p><code>var re = /^(\d+)(0*)$/;re.exec(&#39;102300&#39;); // [&#39;102300&#39;, &#39;102300&#39;, &#39;&#39;]</code></p></li></ul><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><ul><li><p><code>xiaoming.__proto__ = Student;</code>//xiaoming有自己的name属性，但并没有定义run()方法。不过，由于小明是从Student继承而来，只要Student有run()方法，xiaoming也可以调用</p></li><li><p><code>var s = Object.create(Student);</code>//Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建xiaoming</p></li><li><p>`function Student(name) {<br> this.name = name;<br> this.hello = function () {</p><pre><code> alert(&#39;Hello, &#39; + this.name + &#39;!&#39;);</code></pre><p> }<br>}<br>var xiaoming = new Student(‘小明’);<br>`//果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;</p></li><li><p><code>xiaoming.constructor === Student.prototype.constructor; // true Student.prototype.constructor === Student; // true </code>//用new Student()创建的对象还从原型上获得了一个constructor属性，它指向函数Student本身.</p></li><li><p><code>Student.prototype.hello = function () &#123;&#125;;</code>//如果我们通过new Student()创建了很多对象，这些对象的hello函数实际上只需要共享同一个函数就可以了，这样可以节省很多内存。</p></li><li><p><code>function inherits(Child, Parent) &#123;  var F = function () &#123;&#125;;  F.prototype = Parent.prototype;  Child.prototype = new F();  Child.prototype.constructor = Child; &#125;</code></p></li><li><p>`class PrimaryStudent extends Student {<br> constructor(name, grade) {</p><pre><code> super(name); // 记得用super调用父类的构造方法! this.grade = grade;</code></pre><p> }<br> myGrade() {</p><pre><code> alert(&#39;I am at grade &#39; + this.grade);</code></pre><p> }<br>}`</p></li></ul><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><ul><li><p><code>alert(&#39;window inner size: &#39; + window.innerWidth + &#39; x &#39; + window.innerHeight);</code>// 可以调整浏览器窗口大小试试</p></li><li><p>充分利用JavaScript对不存在属性返回undefined的特性，直接用短路运算符||计算：<br><code>var width = window.innerWidth || document.body.clientWidth;</code></p></li><li><p><code>alert(&#39;Screen size = &#39; + screen.width + &#39; x &#39; + screen.height);</code>//屏幕的信息</p></li><li><p><code>http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP</code>可以用location.href获取。要获得URL各个部分的值，可以这么写：<br><code>location.protocol; // &#39;http&#39; location.host; // &#39;www.example.com&#39; location.port; // &#39;8080&#39; location.pathname; // &#39;/path/index.html&#39; location.search; // &#39;?a=1&amp;b=2&#39; location.hash; // &#39;TOP&#39;</code></p></li></ul><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="http://www.w3school.com.cn/jsref/dom_obj_window.asp">浏览器对象模型</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_navigator.asp">浏览器的信息</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_screen.asp">显示屏幕的信息</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_history.asp">History 对象</a><br><a href="http://www.w3school.com.cn/jsref/dom_obj_location.asp">当前 URL </a></p><h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p><a href="http://www.w3school.com.cn/jsref/dom_obj_document.asp">Document</a></p><h3 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h3><ul><li>服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前写过不少的python和c＋＋代码，近期开始正式的学习javascript，做了一些笔记。重点记录和c＋＋不同的部分&lt;/p&gt;</summary>
    
    
    
    
    <category term="Language" scheme="https://wangzitian0.github.io/tags/Language/"/>
    
    <category term="JavaScript" scheme="https://wangzitian0.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的写HTML</title>
    <link href="https://wangzitian0.github.io/2016/06/26/How-to-write-HTML-correctly/"/>
    <id>https://wangzitian0.github.io/2016/06/26/How-to-write-HTML-correctly/</id>
    <published>2016-06-26T03:17:00.000Z</published>
    <updated>2020-09-30T04:59:07.879Z</updated>
    
    <content type="html"><![CDATA[<p>项目源自 github 的项目 <a href="https://github.com/bendc/frontend-guidelines/blob/master/README.md">frontend-guidelines</a>，对它做了一个翻译。</p><a id="more"></a><h2 id="HTML文档"><a href="#HTML文档" class="headerlink" title="HTML文档"></a>HTML文档</h2><h3 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h3><p>HTML5为我们提供了许多用于精确描述内容的语义元素，用来确保你可以从其丰富的词汇中获益。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Blog post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Published: <span class="tag">&lt;<span class="name">span</span>&gt;</span>21st Feb, 2015<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Blog post<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Published: <span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;2015-02-21&quot;</span>&gt;</span>21st Feb, 2015<span class="tag">&lt;/<span class="name">time</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>…<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br></pre></td></tr></table></figure><p>确保你理解了正在使用元素的语义，用错了比不用还糟糕。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">Company</span> <span class="attr">src</span>=<span class="string">logo.png</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">Company</span> <span class="attr">src</span>=<span class="string">logo.png</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="简明"><a href="#简明" class="headerlink" title="简明"></a>简明</h3><p>保持代码简要，不要按照 xhtml 的方法瞎搞。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">en</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">Content-Type</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">stylesheet</span> <span class="attr">href</span>=<span class="string">style.css</span> <span class="attr">type</span>=<span class="string">text/css</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Contact me<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">      Email address:</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">email</span> <span class="attr">placeholder</span>=<span class="string">you@email.com</span> <span class="attr">required</span>=<span class="string">required</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">main.js</span> <span class="attr">type</span>=<span class="string">text/javascript</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">en</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">stylesheet</span> <span class="attr">href</span>=<span class="string">style.css</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Contact me<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    Email address:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">email</span> <span class="attr">placeholder</span>=<span class="string">you@email.com</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">main.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><p>易用性不该忘了，虽然你不需要变成 WCAG [无障碍网页内容指引,Web Content Accessibility Guidelines]专家，但你可以通过一些小改进获得巨大的效益:</p><ul><li>学习使用 <code>alt</code> 元素属性</li><li>确保 link 和 button 用了正确标签 (别有 <code>&lt;div class=button&gt;</code> 这种暴行)</li><li>不依赖于颜色来传达信息</li><li>明确标注表单控件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;Logo&quot;</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;My Company, Inc.&quot;</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>虽然你不一定需要指定语言和字符编码，但是建议你document的基本声明一下（即使 header 里面已经声明了）。</p><p>字符编码推荐 UTF-8。</p><p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">中文编码参考资料</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello, world.<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">en</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello, world.<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>除非找了个牛逼的理由把JS脚本放在正文前面，否则应该避免这种阻塞渲染的做法。</p><p>如果 CSS 非常重，可以把初始化的时候需要的样式隔离，后续需要的样式放到另一个CSS 文件里延时加载。</p><p>两个请求肯定不如一个快，但是更重要的是用户感知的速度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bad --&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">analytics.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello, world.<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- good --&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">utf-8</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello, world.<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">analytics.js</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h2><h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>因为分号是分隔符，所以应该始终以分号结尾。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Box-model"><a href="#Box-model" class="headerlink" title="Box model"></a>Box model</h3><p>理想情况下，整个文档的Box model应该相同。 全局<br><code>* &#123;box-sizing：border-box; &#125;</code>就行，能不改特定元素的默认框模型<br>就不要改。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h3><p>能不改元素的默认行为就不要改，让元素在document里尽可能多地流动。</p><p>例如，删除图像下方的空白区域，不应该更改其默认display：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，能不让元素脱离文档流就不要脱离。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改变位置"><a href="#改变位置" class="headerlink" title="改变位置"></a>改变位置</h3><p>有很多方法可以在CSS中定位元素，但是用下面这些属性/值的时候尽可能严格要求自己。 按优先顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">display: block;</span><br><span class="line">display: flex;</span><br><span class="line">position: relative;</span><br><span class="line">position: sticky;</span><br><span class="line">position: absolute;</span><br><span class="line">position: fixed;</span><br></pre></td></tr></table></figure><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>最小化与DOM紧密耦合的选择器。 选择器超过3个结构伪类、后代或同级组合器时，为要匹配的元素添加一个类。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-of-type</span> <span class="selector-pseudo">:last-child</span> &gt; <span class="selector-tag">p</span> ~ *</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:first-of-type</span> <span class="selector-class">.info</span></span><br></pre></td></tr></table></figure><p>避免重载不必要的选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[src$=svg]</span>, <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-attr">[src$=svg]</span>, <span class="selector-tag">ul</span> &gt; <span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="准确选择"><a href="#准确选择" class="headerlink" title="准确选择"></a>准确选择</h3><p>不要搞得值和选择器难以重构，尽量少用<code>id</code>‘，尽量不用<code>!important</code>.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-class">.bar</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-class">.foo</span><span class="selector-class">.bar</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>覆盖样式会让调试选择器变难，避免这样做。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: visible;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">li</span> + <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>不要重复可以继承的样式声明。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">h1</span>, <span class="selector-tag">div</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h3><p>保持代码精简，使用速记属性，避免用多个不必要的属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">10px</span>);</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语言-1"><a href="#语言-1" class="headerlink" title="语言"></a>语言</h3><p>能用英文的不用数字。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-pseudo">:nth-child(2n</span> + 1) &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">360deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-pseudo">:nth-child(odd)</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">1turn</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浏览器引擎前缀"><a href="#浏览器引擎前缀" class="headerlink" title="浏览器引擎前缀"></a>浏览器引擎前缀</h3><p>积极的去掉过时前缀。如果需要用前缀要房子标准属性之前。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="attribute">-moz-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="attribute">-ms-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">-webkit-transition</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">-ms-transition</span>: <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>transition比animation好。可以使用<code>opacity</code> 和 <code>transform</code>的时候避免使用animation。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: move <span class="number">1s</span> forwards;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> move &#123;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1s</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><p>尽量使用无单位的数字，如果用相对单位<code>rem</code>更好，秒比毫秒好。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: .<span class="number">9em</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">22px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">500ms</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: .<span class="number">9rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">  <span class="attribute">transition</span>: .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>用透明度就用<code>rgba</code>，否则用十六机制数比较好。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">hsl</span>(<span class="number">103</span>, <span class="number">54%</span>, <span class="number">43%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#5a3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><p>CSS 可以复现的不要用http 请求资源来实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">url</span>(white-circle.svg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hacks"><a href="#Hacks" class="headerlink" title="Hacks"></a>Hacks</h3><p>别用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* bad */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  // position: relative;</span><br><span class="line">  <span class="selector-tag">transform</span>: <span class="selector-tag">translateZ</span>(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* good */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="comment">/* position: relative; */</span></span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h3><p>可读性，正确性和表现力比性能重要多了。</p><p>JS 基本上不会成为你的性能瓶颈。</p><p>优化图像压缩，网络访问和DOM回流等功能效果好多了。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad (albeit way faster)</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> len = arr.length;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">  <span class="keyword">var</span> n = arr[i];</span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">2</span> &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  result.push(n * n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = arr.filter(isEven).map(square);</span><br></pre></td></tr></table></figure><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>保持函数的干净。</p><p>理想情况下，所有功能都不会产生副作用、不使用外部数据，并返回新对象、不突变现有的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">target, ...sources</span>) =&gt;</span> <span class="built_in">Object</span>.assign(target, ...sources);</span><br><span class="line">merge(&#123; <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span> &#125;, &#123; <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span> &#125;); <span class="comment">// =&gt; &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">...sources</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, ...sources);</span><br><span class="line">merge(&#123; <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span> &#125;, &#123; <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span> &#125;); <span class="comment">// =&gt; &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;</span></span><br></pre></td></tr></table></figure><h3 id="原生函数"><a href="#原生函数" class="headerlink" title="原生函数"></a>原生函数</h3><p>尽量使用原生函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> toArray = <span class="function"><span class="params">obj</span> =&gt;</span> [].slice.call(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> toArray = (<span class="function">() =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.from ? <span class="built_in">Array</span>.from : <span class="function"><span class="params">obj</span> =&gt;</span> [].slice.call(obj)</span><br><span class="line">)();</span><br></pre></td></tr></table></figure><h3 id="隐式声明"><a href="#隐式声明" class="headerlink" title="隐式声明"></a>隐式声明</h3><p>隐式声明有意义则拥抱，否则避免。不要<a href="http://baike.baidu.com/link?url=nVBWGg3g52vGmkfkmfg1Z4GXxPmQgCimgmsMfOtxfaXESig_C82Vo0zE506x9DgMtUwsKGFPbQyizBWqSTwgqw3oHvNE9NufgVx921ZuSzIWCkwq-Ju4KBWVtAQUqIAm">cargo-cult</a>，不要相信约翰布鲁姆教。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="literal">undefined</span> || x === <span class="literal">null</span>) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (x == <span class="literal">undefined</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>不要使用循环去艹可变对象。使用<code>array.prototype</code> 方法.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (;arr[++i];) &#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// =&gt; 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">arr</span> =&gt;</span></span><br><span class="line">  arr.reduce(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y);</span><br><span class="line"></span><br><span class="line">sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure><p>如果不行，用 <code>array.prototype</code> 很丑 or 很有争议，用递归。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> createDivs = <span class="function"><span class="params">howMany</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (howMany--) &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.insertAdjacentHTML(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;div&gt;&lt;/div&gt;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">createDivs(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> createDivs = <span class="function"><span class="params">howMany</span> =&gt;</span></span><br><span class="line">  [...Array(howMany)].forEach(<span class="function">() =&gt;</span></span><br><span class="line">    <span class="built_in">document</span>.body.insertAdjacentHTML(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;div&gt;&lt;/div&gt;&quot;</span>)</span><br><span class="line">  );</span><br><span class="line">createDivs(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> createDivs = <span class="function"><span class="params">howMany</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!howMany) <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.insertAdjacentHTML(<span class="string">&quot;beforeend&quot;</span>, <span class="string">&quot;&lt;div&gt;&lt;/div&gt;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> createDivs(howMany - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line">createDivs(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>忘掉 <code>arguments</code> 对象。Rest参数比一个 option 对象要好:</p><ol><li>它有名字，能更好的帮助你知道它预期的意义。</li><li>数组比较好用</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">() =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure><h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><p>忘了<code>apply()</code>，用<code>...</code>展开的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greet = <span class="function">(<span class="params">first, last</span>) =&gt;</span> <span class="string">`Hi <span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>`</span>;</span><br><span class="line"><span class="keyword">const</span> person = [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">greet.apply(<span class="literal">null</span>, person);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">greet(...person);</span><br></pre></td></tr></table></figure><h3 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h3><p>有更好习惯的用法时，不要用<code>bind()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">[<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>].forEach(func.bind(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">[<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>].forEach(func, <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  first: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  last: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">const</span> full = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.last&#125;</span>`</span>;</span><br><span class="line">    &#125;.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;full()&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  first: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  last: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">const</span> full = <span class="function">() =&gt;</span> <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.last&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;full()&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>避免不必要的函数嵌套。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">num</span> =&gt;</span> <span class="built_in">String</span>(num));</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="built_in">String</span>);</span><br></pre></td></tr></table></figure><h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><p>避免多层函数嵌套，用composition更好。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">mult2(plus1(<span class="number">5</span>)); <span class="comment">// =&gt; 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> pipeline = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> <span class="function"><span class="params">val</span> =&gt;</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b(a), val);</span><br><span class="line"><span class="keyword">const</span> addThenMult = pipeline(plus1, mult2);</span><br><span class="line">addThenMult(<span class="number">5</span>); <span class="comment">// =&gt; 12</span></span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存昂贵的操作，包括不限于功能测试、大数据结构等等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> contains = <span class="function">(<span class="params">arr, value</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.includes</span><br><span class="line">    ? arr.includes(value)</span><br><span class="line">    : arr.some(<span class="function"><span class="params">el</span> =&gt;</span> el === value);</span><br><span class="line">contains([<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>], <span class="string">&quot;baz&quot;</span>); <span class="comment">// =&gt; false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> contains = (<span class="function">() =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.includes</span><br><span class="line">    ? <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.includes(value)</span><br><span class="line">    : <span class="function">(<span class="params">arr, value</span>) =&gt;</span> arr.some(<span class="function"><span class="params">el</span> =&gt;</span> el === value)</span><br><span class="line">)();</span><br><span class="line">contains([<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>], <span class="string">&quot;baz&quot;</span>); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p><code>const</code> &gt; <code>let</code> &gt; <code>var</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">me.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Ben&quot;</span>).set(<span class="string">&quot;country&quot;</span>, <span class="string">&quot;Belgium&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">me.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Ben&quot;</span>).set(<span class="string">&quot;country&quot;</span>, <span class="string">&quot;Belgium&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">IIFE</a> 比一堆的 if else 和 switch 要好。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> grade;</span><br><span class="line"><span class="keyword">if</span> (result &lt; <span class="number">50</span>)</span><br><span class="line">  grade = <span class="string">&quot;bad&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result &lt; <span class="number">90</span>)</span><br><span class="line">  grade = <span class="string">&quot;good&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  grade = <span class="string">&quot;excellent&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> grade = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">50</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;bad&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">90</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;good&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;excellent&quot;</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h3><p>避免 <code>for...in</code>，尽可能函数式编程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shared = &#123; <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(shared, &#123;</span><br><span class="line">  bar: &#123;</span><br><span class="line">    value: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(prop))</span><br><span class="line">    <span class="built_in">console</span>.log(prop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">prop</span> =&gt;</span> <span class="built_in">console</span>.log(prop));</span><br></pre></td></tr></table></figure><h3 id="对象当字典"><a href="#对象当字典" class="headerlink" title="对象当字典"></a>对象当字典</h3><p>Maps 比 objects 更强大，有疑问的时候用<code>Map</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> me = &#123;</span><br><span class="line">  name: <span class="string">&quot;Ben&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> meSize = <span class="built_in">Object</span>.keys(me).length;</span><br><span class="line">meSize; <span class="comment">// =&gt; 2</span></span><br><span class="line">me.country = <span class="string">&quot;Belgium&quot;</span>;</span><br><span class="line">meSize++;</span><br><span class="line">meSize; <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">me.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Ben&quot;</span>);</span><br><span class="line">me.set(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>);</span><br><span class="line">me.size; <span class="comment">// =&gt; 2</span></span><br><span class="line">me.set(<span class="string">&quot;country&quot;</span>, <span class="string">&quot;Belgium&quot;</span>);</span><br><span class="line">me.size; <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><h3 id="Curry"><a href="#Curry" class="headerlink" title="Curry"></a>Curry</h3><p>咖喱是许多开发人员的强大但外来的范式。<br>不要滥用它，因为适用它的地方很少。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> a + b;</span><br><span class="line">sum(<span class="number">5</span>)(<span class="number">3</span>); <span class="comment">// =&gt; 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line">sum(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// =&gt; 8</span></span><br></pre></td></tr></table></figure><h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>不要使用看似聪明的技巧来模糊你的代码的意图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">foo || doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> (!foo) doSomething();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* IIFE */</span> &#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* IIFE */</span> &#125;());</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> n = ~~<span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="built_in">Math</span>.floor(<span class="number">3.14</span>);</span><br></pre></td></tr></table></figure><h3 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h3><p>别怕造一堆的可复用的小的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">arr[arr.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> first = <span class="function"><span class="params">arr</span> =&gt;</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> last = <span class="function"><span class="params">arr</span> =&gt;</span> first(arr.slice(<span class="number">-1</span>));</span><br><span class="line">last(arr);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> product = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b;</span><br><span class="line"><span class="keyword">const</span> triple = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> product = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b;</span><br><span class="line"><span class="keyword">const</span> triple = product.bind(<span class="literal">null</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>尽量最小化依赖，三方代码是你无法掌控的，不要为了一些容易实现的功能区引用一个完整的大库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">&quot;underscore&quot;</span>);</span><br><span class="line">_.compact([<span class="string">&quot;foo&quot;</span>, <span class="number">0</span>]));</span><br><span class="line">_.unique([<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;foo&quot;</span>]);</span><br><span class="line">_.union([<span class="string">&quot;foo&quot;</span>], [<span class="string">&quot;bar&quot;</span>], [<span class="string">&quot;foo&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> compact = <span class="function"><span class="params">arr</span> =&gt;</span> arr.filter(<span class="function"><span class="params">el</span> =&gt;</span> el);</span><br><span class="line"><span class="keyword">const</span> unique = <span class="function"><span class="params">arr</span> =&gt;</span> [...Set(arr)];</span><br><span class="line"><span class="keyword">const</span> union = <span class="function">(<span class="params">...arr</span>) =&gt;</span> unique([].concat(...arr));</span><br><span class="line"></span><br><span class="line">compact([<span class="string">&quot;foo&quot;</span>, <span class="number">0</span>]);</span><br><span class="line">unique([<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;foo&quot;</span>]);</span><br><span class="line">union([<span class="string">&quot;foo&quot;</span>], [<span class="string">&quot;bar&quot;</span>], [<span class="string">&quot;foo&quot;</span>]);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;项目源自 github 的项目 &lt;a href=&quot;https://github.com/bendc/frontend-guidelines/blob/master/README.md&quot;&gt;frontend-guidelines&lt;/a&gt;，对它做了一个翻译。&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTML" scheme="https://wangzitian0.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>捣鼓 VIM</title>
    <link href="https://wangzitian0.github.io/2016/03/19/Using-VIM/"/>
    <id>https://wangzitian0.github.io/2016/03/19/Using-VIM/</id>
    <published>2016-03-19T03:43:00.000Z</published>
    <updated>2020-09-30T04:59:07.881Z</updated>
    
    <content type="html"><![CDATA[<p>近期花了不少时间弄vim，把几个github上星星数较高的的试了一遍。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">amix&#x2F;vimrc</span><br><span class="line">skwp&#x2F;dotfiles</span><br><span class="line">spf13&#x2F;spf13-vim</span><br></pre></td></tr></table></figure><p>有的冲突还是非常严重的，比如spf13的markdown插件和自动补全neocomplete插件就一直有冲突，看了很久都解决不了，弃疗之。<br>最后选了humiaozuzu/dot-vimrc为原型的版本自己定制，这个版本非常清爽。<br>直接复制源下来，然后拷贝到合适的位置，用vundle自动安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;humiaozuzu&#x2F;dot-vimrc.git</span><br><span class="line">~&#x2F;.vim</span><br><span class="line">ln -s ~&#x2F;.vim&#x2F;vimrc ~&#x2F;.vimrc</span><br></pre></td></tr></table></figure><p>Setup Vundle:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;gmarik&#x2F;vundle.git ~&#x2F;.vim&#x2F;bundle&#x2F;vundle</span><br></pre></td></tr></table></figure><p>Install bundles. Launch vim(ignore the errors and they will disappear after installing needed plugins)and run:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:BundleInstall</span><br></pre></td></tr></table></figure><p>然后是ubuntu记得装一下下面的vim 扩展包（server版本庄vim-nox）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim-gtk</span><br></pre></td></tr></table></figure><p>今天先到这，后续慢慢写使用心得。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近期花了不少时间弄vim，把几个github上星星数较高的的试了一遍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Tools" scheme="https://wangzitian0.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab安装</title>
    <link href="https://wangzitian0.github.io/2016/01/05/Gitlab-install/"/>
    <id>https://wangzitian0.github.io/2016/01/05/Gitlab-install/</id>
    <published>2016-01-05T03:51:00.000Z</published>
    <updated>2020-09-30T04:59:07.878Z</updated>
    
    <content type="html"><![CDATA[<p>需要一个Git私有库，选来选去觉得 gitlab 比较靠谱。后来搜到一个神器，bitnami！</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>gitlab安装方法:<br><a href="https://about.gitlab.com/installation/#ubuntu">官方文档</a><br>看着麻烦，一堆依赖，我就想着有没有什么脚本可以一件安装，然后就去找了一会，找到了 bitnami。它可以像 windows 安装包一样，一键安装包括不限于 wiki, git, LAMP, ERP, Dashboard等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitNami是一个开源项目，该项目产生的开源软件包括安装 Web应用程序和解决方案堆栈，以及虚拟设备。</span><br></pre></td></tr></table></figure><p>换句话说，下个安装包，一键安装。安装的时候会让你自己选择需要服务的端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitnami install</span><br></pre></td></tr></table></figure><p>另外，提供了虚拟机的磁盘映像，直接挂载到 virtualbox 或者 vmware就可以开箱即用。</p><p>具体介绍和安装可以看这个： <a href="https://bitnami.com/stack/gitlab">官方文档</a></p><h2 id="我遇到的问题"><a href="#我遇到的问题" class="headerlink" title="我遇到的问题"></a>我遇到的问题</h2><p>1.安装老是 crash，后来根据错误信息查到，bitnami的 stack 需要内存大于1G，之前是在BUPT ACM 的 EXSi 上面搞，所以大小随便没有报错过。解决方法：改阿里云的 swap area，保证它不小于1g，具体方法在阿里云的帮助文件里面有</p><p>2.gitlab 邮件不正常出来<br>后来查到邮件是两个配置，一个是 bitnami 的系统配置，一个是 gitlab 的系统配置：<br>第一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi &#x2F;opt&#x2F;gitlab-8.1.4-1&#x2F;apps&#x2F;gitlab&#x2F;htdocs&#x2F;config&#x2F;environments&#x2F;production.rb </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config.action_mailer.perform_deliveries &#x3D; true</span><br><span class="line">config.action_mailer.raise_delivery_errors &#x3D; true</span><br><span class="line">config.action_mailer.delivery_method &#x3D; :smtp</span><br><span class="line">config.action_mailer.smtp_settings &#x3D; &#123;</span><br><span class="line">  :address &#x3D;&gt; &quot;smtp.aliyun.com&quot;,</span><br><span class="line">  :port &#x3D;&gt; &quot;25&quot;,</span><br><span class="line">  :domain &#x3D;&gt; &quot;aliyun.com&quot;,</span><br><span class="line">  :authentication &#x3D;&gt; :login,</span><br><span class="line">  :user_name &#x3D;&gt; &quot;wangzitian0@aliyun.com&quot;,</span><br><span class="line">  :password &#x3D;&gt; &quot;*******&quot;,</span><br><span class="line">  :enable_starttls_auto &#x3D;&gt; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi &#x2F;opt&#x2F;gitlab-8.1.4-1&#x2F;apps&#x2F;gitlab&#x2F;htdocs&#x2F;config&#x2F;gitlab.yml </span><br></pre></td></tr></table></figure><p>另外，调试过程中发现一个问题，邮箱有一个限制，大致是smtp 协议里的发件人和调用 api 的时候给的发件人必须一样。把email部分的收发人改为配置里面一样的即可。<br>查了下原因，大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用过outlook的都知道，配置自己的邮件地址和名字为jobs@apple.com（乔布斯），</span><br><span class="line">那么对方就会显示发件人是乔布斯，他回信会回到jobs@apple.com，你收不到而已，</span><br><span class="line">这是因为smtp（邮件协议）并不认证发件人信息，那些发件认证只是确定你在服务器有发邮件权限，</span><br><span class="line">并不认证发件人是否是本人。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;需要一个Git私有库，选来选去觉得 gitlab 比较靠谱。后来搜到一个神器，bitnami！&lt;/p&gt;</summary>
    
    
    
    
    <category term="Tools" scheme="https://wangzitian0.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Python教程&amp;笔记</title>
    <link href="https://wangzitian0.github.io/2014/11/22/Python-notes/"/>
    <id>https://wangzitian0.github.io/2014/11/22/Python-notes/</id>
    <published>2014-11-22T08:46:00.000Z</published>
    <updated>2020-09-30T04:59:07.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用过的库"><a href="#用过的库" class="headerlink" title="用过的库"></a>用过的库</h2><p>这里把自己用过的，并且质量不错的的库做一个汇总</p><a id="more"></a><ul><li><p>python conf 用法</p><p><a href="http://developer.51cto.com/art/201003/189885.htm">http://developer.51cto.com/art/201003/189885.htm</a></p></li><li><p>python内置函数</p><p><a href="http://python.usyiyi.cn/python_278/library/functions.html">http://python.usyiyi.cn/python_278/library/functions.html</a><br><a href="http://wangwei007.blog.51cto.com/68019/1100587">http://wangwei007.blog.51cto.com/68019/1100587</a></p></li><li><p>python知识扩展</p><p><a href="http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html">http://pycoders-weekly-chinese.readthedocs.org/en/latest/index.html</a></p></li><li><p>something about django</p><p><a href="http://media.revsys.com/images/django-1.4-cheatsheet.pdf">http://media.revsys.com/images/django-1.4-cheatsheet.pdf</a><br><a href="http://www.mercurytide.co.uk/media/resources/django-cheat-sheet-a4.pdf">http://www.mercurytide.co.uk/media/resources/django-cheat-sheet-a4.pdf</a><br><a href="https://github.com/chrisdl/Django-QuerySet-Cheatsheet">https://github.com/chrisdl/Django-QuerySet-Cheatsheet</a></p></li><li><p>django中文文档</p><p><a href="http://python.usyiyi.cn/django/index.html">http://python.usyiyi.cn/django/index.html</a></p></li><li><p>python shell tab</p><p><a href="http://blog.csdn.net/loovejava/article/details/11751461">http://blog.csdn.net/loovejava/article/details/11751461</a></p></li><li><p>生成文档<br>reportlib</p></li><li><p>deploy of uwsgi<br><a href="http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html">http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html</a></p></li></ul><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Python-数字"><a href="#Python-数字" class="headerlink" title="Python 数字"></a>Python 数字</h3><p>Python 支持四种不同的数值类型：</p><ul><li>整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。</li><li>长整型(long integers) - 无限大小的整数，整数最后是一个大写或小写的L。</li><li>浮点型(floating point real values) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</li><li>复数( (complex numbers)) - 复数的虚部以字母J 或 j结尾 。如：2+3i<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">intlongfloatcomplex</span><br><span class="line">1051924361L0.03.14j</span><br><span class="line">100-0x19323L15.2045.j</span><br><span class="line">-7860122L-21.99.322e-36j</span><br><span class="line">0800xDEFABCECBDAECBFBAEl32.3+e18.876j</span><br><span class="line">-0490535633629843L-90.-.6545+0J</span><br><span class="line">-0x260-052318172735L-32.54e1003e+26J</span><br><span class="line">0x69-4721885298529L70.2-E124.53e-7j</span><br><span class="line">长整型也可以使用小写&quot;L&quot;，但是还是建议您使用大写&quot;L&quot;，避免与数字&quot;1&quot;混淆。Python使用&quot;L&quot;来显示长整型。</span><br><span class="line">Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</span><br></pre></td></tr></table></figure></li></ul><h3 id="Python数字类型转换"><a href="#Python数字类型转换" class="headerlink" title="Python数字类型转换"></a>Python数字类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int(x [,base ])         将x转换为一个整数  </span><br><span class="line">long(x [,base ])        将x转换为一个长整数  </span><br><span class="line">float(x )               将x转换到一个浮点数  </span><br><span class="line">complex(real [,imag ])  创建一个复数  </span><br><span class="line">str(x )                 将对象 x 转换为字符串  </span><br><span class="line">repr(x )                将对象 x 转换为表达式字符串  </span><br><span class="line">eval(str )              用来计算在字符串中的有效Python表达式,并返回一个对象  </span><br><span class="line">tuple(s )               将序列 s 转换为一个元组  </span><br><span class="line">list(s )                将序列 s 转换为一个列表  </span><br><span class="line">chr(x )                 将一个整数转换为一个字符  </span><br><span class="line">unichr(x )              将一个整数转换为Unicode字符  </span><br><span class="line">ord(x )                 将一个字符转换为它的整数值  </span><br><span class="line">hex(x )                 将一个整数转换为一个十六进制字符串  </span><br><span class="line">oct(x )                 将一个整数转换为一个八进制字符串  </span><br></pre></td></tr></table></figure><h3 id="Python数学函数"><a href="#Python数学函数" class="headerlink" title="Python数学函数"></a>Python数学函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">函数返回值 ( 描述 )</span><br><span class="line">abs(x)返回数字的绝对值，如abs(-10) 返回 10</span><br><span class="line">ceil(x)返回数字的上入整数，如math.ceil(4.1) 返回 5</span><br><span class="line">cmp(x, y)如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1</span><br><span class="line">exp(x)返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</span><br><span class="line">fabs(x)返回数字的绝对值，如math.fabs(-10) 返回10.0</span><br><span class="line">floor(x)返回数字的下舍整数，如math.floor(4.9)返回 4</span><br><span class="line">log(x)如math.log(math.e)返回1.0,math.log(100,10)返回2.0</span><br><span class="line">log10(x)返回以10为基数的x的对数，如math.log10(100)返回 2.0</span><br><span class="line">max(x1, x2,...)返回给定参数的最大值，参数可以为序列。</span><br><span class="line">min(x1, x2,...)返回给定参数的最小值，参数可以为序列。</span><br><span class="line">modf(x)返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</span><br><span class="line">pow(x, y)x**y 运算后的值。</span><br><span class="line">round(x [,n])返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</span><br><span class="line">sqrt(x)返回数字x的平方根，数字可以为负数，返回类型为实数，如math.sqrt(4)返回 2+0j</span><br></pre></td></tr></table></figure><h3 id="Python随机数函数"><a href="#Python随机数函数" class="headerlink" title="Python随机数函数"></a>Python随机数函数</h3><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。<br>Python包含以下常用随机数函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">函数描述</span><br><span class="line">choice(seq)从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</span><br><span class="line">randrange ([start,] stop [,step])从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1</span><br><span class="line">random()随机生成下一个实数，它在[0,1)范围内。</span><br><span class="line">seed([x])改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</span><br><span class="line">shuffle(lst)将序列的所有元素随机排序</span><br><span class="line">uniform(x, y)随机生成下一个实数，它在[x,y]范围内。</span><br></pre></td></tr></table></figure><h3 id="Python三角函数"><a href="#Python三角函数" class="headerlink" title="Python三角函数"></a>Python三角函数</h3><p>Python包括以下三角函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">函数描述</span><br><span class="line">acos(x)返回x的反余弦弧度值。</span><br><span class="line">asin(x)返回x的反正弦弧度值。</span><br><span class="line">atan(x)返回x的反正切弧度值。</span><br><span class="line">atan2(y, x)返回给定的 X 及 Y 坐标值的反正切值。</span><br><span class="line">cos(x)返回x的弧度的余弦值。</span><br><span class="line">hypot(x, y)返回欧几里德范数 sqrt(x*x + y*y)。</span><br><span class="line">sin(x)返回的x弧度的正弦值。</span><br><span class="line">tan(x)返回x弧度的正切值。</span><br><span class="line">degrees(x)将弧度转换为角度,如degrees(math.pi&#x2F;2) ， 返回90.0</span><br><span class="line">radians(x)将角度转换为弧度</span><br></pre></td></tr></table></figure><h3 id="Python数学常量"><a href="#Python数学常量" class="headerlink" title="Python数学常量"></a>Python数学常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常量描述</span><br><span class="line">pi数学常量 pi（圆周率，一般以π来表示）</span><br><span class="line">e数学常量 e，e即自然常数（自然常数）。</span><br><span class="line">Python 字符串</span><br></pre></td></tr></table></figure><p>Python不支持单字符类型，单字符也在Python也是作为一个字符串使用。</p><h3 id="Python转义字符"><a href="#Python转义字符" class="headerlink" title="Python转义字符"></a>Python转义字符</h3><p>在需要在字符中使用特殊字符时，python用反斜杠()转义字符。如下表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">转义字符描述</span><br><span class="line">\(在行尾时)续行符</span><br><span class="line">\\反斜杠符号</span><br><span class="line">\&#39;单引号</span><br><span class="line">\&quot;双引号</span><br><span class="line">\a响铃</span><br><span class="line">\b退格(Backspace)</span><br><span class="line">\e转义</span><br><span class="line">\000空</span><br><span class="line">\n换行</span><br><span class="line">\v纵向制表符</span><br><span class="line">\t横向制表符</span><br><span class="line">\r回车</span><br><span class="line">\f换页</span><br><span class="line">\oyy八进制数，yy代表的字符，例如：\o12代表换行</span><br><span class="line">\xyy十六进制数，yy代表的字符，例如：\x0a代表换行</span><br><span class="line">\other其它的字符以普通格式输出</span><br></pre></td></tr></table></figure><h3 id="Python字符串运算符"><a href="#Python字符串运算符" class="headerlink" title="Python字符串运算符"></a>Python字符串运算符</h3><p>下表实例变量a值为字符串”Hello”，b变量值为”Python”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">操作符描述实例</span><br><span class="line">+字符串连接a + b 输出结果： HelloPython</span><br><span class="line">*重复输出字符串a*2 输出结果：HelloHello</span><br><span class="line">[]通过索引获取字符串中字符a[1] 输出结果 e</span><br><span class="line">[ : ]截取字符串中的一部分a[1:4] 输出结果ell</span><br><span class="line">in成员运算符 - 如果字符串中包含给定的字符返回 TrueH in a 输出结果 1</span><br><span class="line">not in成员运算符 - 如果字符串中不包含给定的字符返回 TrueM not in a 输出结果 1</span><br><span class="line">r&#x2F;R原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母&quot;r&quot;（可以大小写）以外，与普通字符串有着几乎完全相同的语法。print r&#39;\n&#39; prints \n 和 print R&#39;\n&#39;prints \n</span><br><span class="line">%格式字符串情看一下章节</span><br></pre></td></tr></table></figure><h3 id="Python字符串格式化"><a href="#Python字符串格式化" class="headerlink" title="Python字符串格式化"></a>Python字符串格式化</h3><p>Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。<br>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。<br>如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"></span><br><span class="line">print &quot;My name is %s and weight is %d kg!&quot; % (&#39;Zara&#39;, 21) </span><br><span class="line">以上实例输出结果：</span><br><span class="line">My name is Zara and weight is 21 kg!</span><br></pre></td></tr></table></figure><h3 id="python字符串格式化符号"><a href="#python字符串格式化符号" class="headerlink" title="python字符串格式化符号"></a>python字符串格式化符号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">符号描述</span><br><span class="line">%c 格式化字符及其ASCII码</span><br><span class="line">%s 格式化字符串</span><br><span class="line">%d 格式化整数</span><br><span class="line">%u 格式化无符号整型</span><br><span class="line">%o 格式化无符号八进制数</span><br><span class="line">%x 格式化无符号十六进制数</span><br><span class="line">%X 格式化无符号十六进制数（大写）</span><br><span class="line">%f 格式化浮点数字，可指定小数点后的精度</span><br><span class="line">%e 用科学计数法格式化浮点数</span><br><span class="line">%E 作用同%e，用科学计数法格式化浮点数</span><br><span class="line">%g %f和%e的简写</span><br><span class="line">%G %f 和 %E 的简写</span><br><span class="line">%p 用十六进制数格式化变量的地址</span><br></pre></td></tr></table></figure><p>格式化操作符辅助指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">符号功能</span><br><span class="line">*定义宽度或者小数点精度</span><br><span class="line">-用做左对齐</span><br><span class="line">+在正数前面显示加号( + )</span><br><span class="line">&lt;sp&gt;在正数前面显示空格</span><br><span class="line">#在八进制数前面显示零(&#39;0&#39;)，在十六进制前面显示&#39;0x&#39;或者&#39;0X&#39;(取决于用的是&#39;x&#39;还是&#39;X&#39;)</span><br><span class="line">0显示的数字前面填充&#39;0&#39;而不是默认的空格</span><br><span class="line">%&#39;%%&#39;输出一个单一的&#39;%&#39;</span><br><span class="line">(var)映射变量(字典参数)</span><br><span class="line">m.n.m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</span><br></pre></td></tr></table></figure><h3 id="Python三引号（triple-quotes）"><a href="#Python三引号（triple-quotes）" class="headerlink" title="Python三引号（triple quotes）"></a>Python三引号（triple quotes）</h3><p>python中三引号可以将复杂的字符串进行复制:<br>python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。<br>三引号的语法是一对连续的单引号或者双引号（通常都是成对的用）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &gt;&gt;&gt; hi &#x3D; &#39;&#39;&#39;hi </span><br><span class="line">there&#39;&#39;&#39;</span><br><span class="line">&gt;&gt;&gt; hi   # repr()</span><br><span class="line">&#39;hi\nthere&#39;</span><br><span class="line">&gt;&gt;&gt; print hi  # str()</span><br><span class="line">hi </span><br><span class="line">there  </span><br></pre></td></tr></table></figure><p>三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。<br>一个典型的用例是，当你需要一块HTML或者SQL时，这时用字符串组合，特殊字符串转义将会非常的繁琐。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> errHTML &#x3D; &#39;&#39;&#39;</span><br><span class="line">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</span><br><span class="line">Friends CGI Demo&lt;&#x2F;TITLE&gt;&lt;&#x2F;HEAD&gt;</span><br><span class="line">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;&#x2F;H3&gt;</span><br><span class="line">&lt;B&gt;%s&lt;&#x2F;B&gt;&lt;P&gt;</span><br><span class="line">&lt;FORM&gt;&lt;INPUT TYPE&#x3D;button VALUE&#x3D;Back</span><br><span class="line">ONCLICK&#x3D;&quot;window.history.back()&quot;&gt;&lt;&#x2F;FORM&gt;</span><br><span class="line">&lt;&#x2F;BODY&gt;&lt;&#x2F;HTML&gt;</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">cursor.execute(&#39;&#39;&#39;</span><br><span class="line">CREATE TABLE users (  </span><br><span class="line">login VARCHAR(8), </span><br><span class="line">uid INTEGER,</span><br><span class="line">prid INTEGER)</span><br><span class="line">&#39;&#39;&#39;)</span><br></pre></td></tr></table></figure><h3 id="Unicode-字符串"><a href="#Unicode-字符串" class="headerlink" title="Unicode 字符串"></a>Unicode 字符串</h3><p>Python 中定义一个 Unicode 字符串和定义一个普通字符串一样简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; u&#39;Hello World !&#39;</span><br><span class="line">u&#39;Hello World !&#39;</span><br><span class="line">引号前小写的&quot;u&quot;表示这里创建的是一个 Unicode 字符串。如果你想加入一个特殊字符，可以使用 Python 的 Unicode-Escape 编码。如下例所示：</span><br><span class="line">&gt;&gt;&gt; u&#39;Hello\u0020World !&#39;</span><br><span class="line">u&#39;Hello World !&#39;</span><br><span class="line">被替换的 \u0020 标识表示在给定位置插入编码值为 0x0020 的 Unicode 字符（空格符）。</span><br><span class="line">python的字符串内建函数</span><br><span class="line">字符串方法是从python1.6到2.0慢慢加进来的——它们也被加到了Jython中。</span><br><span class="line">这些方法实现了string模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对Unicode的支持，有一些甚至是专门用于Unicode的。</span><br><span class="line">方法描述</span><br><span class="line">string.capitalize()</span><br><span class="line">把字符串的第一个字符大写</span><br><span class="line">string.center(width)</span><br><span class="line">返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</span><br><span class="line">string.count(str, beg&#x3D;0, end&#x3D;len(string))</span><br><span class="line">返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</span><br><span class="line">string.decode(encoding&#x3D;&#39;UTF-8&#39;, errors&#x3D;&#39;strict&#39;)</span><br><span class="line">以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除 非 errors 指 定 的 是 &#39;ignore&#39; 或 者&#39;replace&#39;</span><br><span class="line">string.encode(encoding&#x3D;&#39;UTF-8&#39;, errors&#x3D;&#39;strict&#39;)</span><br><span class="line">以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是&#39;ignore&#39;或者&#39;replace&#39;</span><br><span class="line">string.endswith(obj, beg&#x3D;0, end&#x3D;len(string))</span><br><span class="line">检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</span><br><span class="line">string.expandtabs(tabsize&#x3D;8)</span><br><span class="line">把字符串 string 中的 tab 符号转为空格，默认的空格数 tabsize 是 8.</span><br><span class="line">string.find(str, beg&#x3D;0, end&#x3D;len(string))</span><br><span class="line">检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</span><br><span class="line">string.index(str, beg&#x3D;0, end&#x3D;len(string))</span><br><span class="line">跟find()方法一样，只不过如果str不在 string中会报一个异常.</span><br><span class="line">string.isalnum()</span><br><span class="line">如果 string 至少有一个字符并且所有字符都是字母或数字则返</span><br><span class="line">回 True,否则返回 False</span><br><span class="line">string.isalpha()</span><br><span class="line">如果 string 至少有一个字符并且所有字符都是字母则返回 True,</span><br><span class="line">否则返回 False</span><br><span class="line">string.isdecimal()</span><br><span class="line">如果 string 只包含十进制数字则返回 True 否则返回 False.</span><br><span class="line">string.isdigit()</span><br><span class="line">如果 string 只包含数字则返回 True 否则返回 False.</span><br><span class="line">string.islower()</span><br><span class="line">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</span><br><span class="line">string.isnumeric()</span><br><span class="line">如果 string 中只包含数字字符，则返回 True，否则返回 False</span><br><span class="line">string.isspace()</span><br><span class="line">如果 string 中只包含空格，则返回 True，否则返回 False.</span><br><span class="line">string.istitle()</span><br><span class="line">如果 string 是标题化的(见 title())则返回 True，否则返回 False</span><br><span class="line">string.isupper()</span><br><span class="line">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</span><br><span class="line">string.join(seq)</span><br><span class="line">Merges (concatenates)以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</span><br><span class="line">string.ljust(width)</span><br><span class="line">返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</span><br><span class="line">string.lower()</span><br><span class="line">转换 string 中所有大写字符为小写.</span><br><span class="line">string.lstrip()</span><br><span class="line">截掉 string 左边的空格</span><br><span class="line">string.maketrans(intab, outtab])</span><br><span class="line">maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</span><br><span class="line">max(str)</span><br><span class="line">返回字符串 str 中最大的字母。</span><br><span class="line">min(str)</span><br><span class="line">返回字符串 str 中最小的字母。</span><br><span class="line">string.partition(str)</span><br><span class="line">有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str &#x3D;&#x3D; string.</span><br><span class="line">string.replace(str1, str2,  num&#x3D;string.count(str1))</span><br><span class="line">把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</span><br><span class="line">string.rfind(str, beg&#x3D;0,end&#x3D;len(string) )</span><br><span class="line">类似于 find()函数，不过是从右边开始查找.</span><br><span class="line">string.rindex( str, beg&#x3D;0,end&#x3D;len(string))</span><br><span class="line">类似于 index()，不过是从右边开始.</span><br><span class="line">string.rjust(width)</span><br><span class="line">返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</span><br><span class="line">string.rpartition(str)</span><br><span class="line">类似于 partition()函数,不过是从右边开始查找.</span><br><span class="line">string.rstrip()</span><br><span class="line">删除 string 字符串末尾的空格.</span><br><span class="line">string.split(str&#x3D;&quot;&quot;, num&#x3D;string.count(str))</span><br><span class="line">以 str 为分隔符切片 string，如果 num有指定值，则仅分隔 num 个子字符串</span><br><span class="line">string.splitlines(num&#x3D;string.count(&#39;\n&#39;))</span><br><span class="line">按照行分隔，返回一个包含各行作为元素的列表，如果 num 指定则仅切片 num 个行.</span><br><span class="line">string.startswith(obj, beg&#x3D;0,end&#x3D;len(string))</span><br><span class="line">检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</span><br><span class="line">string.strip([obj])</span><br><span class="line">在 string 上执行 lstrip()和 rstrip()</span><br><span class="line">string.swapcase()</span><br><span class="line">翻转 string 中的大小写</span><br><span class="line">string.title()</span><br><span class="line">返回&quot;标题化&quot;的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</span><br><span class="line">string.translate(str, del&#x3D;&quot;&quot;)</span><br><span class="line">根据 str 给出的表(包含 256 个字符)转换 string 的字符,</span><br><span class="line">要过滤掉的字符放到 del 参数中</span><br><span class="line">string.upper()</span><br><span class="line">转换 string 中的小写字母为大写</span><br><span class="line">string.zfill(width)</span><br><span class="line">返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</span><br><span class="line">string.isdecimal()</span><br><span class="line">isdecimal()方法检查字符串是否只包含十进制字符。这种方法只存在于unicode对象。</span><br></pre></td></tr></table></figure><h3 id="Python列表脚本操作符"><a href="#Python列表脚本操作符" class="headerlink" title="Python列表脚本操作符"></a>Python列表脚本操作符</h3><p>列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。<br>如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python 表达式结果描述</span><br><span class="line">len([1, 2, 3])3长度</span><br><span class="line">[1, 2, 3] + [4, 5, 6][1, 2, 3, 4, 5, 6]组合</span><br><span class="line">[&#39;Hi!&#39;] * 4[&#39;Hi!&#39;, &#39;Hi!&#39;, &#39;Hi!&#39;, &#39;Hi!&#39;]重复</span><br><span class="line">3 in [1, 2, 3]True元素是否存在于列表中</span><br><span class="line">for x in [1, 2, 3]: print x,1 2 3迭代</span><br></pre></td></tr></table></figure><h3 id="Python列表截取"><a href="#Python列表截取" class="headerlink" title="Python列表截取"></a>Python列表截取</h3><p>Python的列表截取与字符串操作类型，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L &#x3D; [&#39;spam&#39;, &#39;Spam&#39;, &#39;SPAM!&#39;]</span><br><span class="line">操作：</span><br><span class="line">Python 表达式结果描述</span><br><span class="line">L[2]&#39;SPAM!&#39;读取列表中第三个元素</span><br><span class="line">L[-2]&#39;Spam&#39;读取列表中倒数第二个元素</span><br><span class="line">L[1:][&#39;Spam&#39;, &#39;SPAM!&#39;]从第二个元素开始截取列表</span><br></pre></td></tr></table></figure><h3 id="Python列表函数-amp-方法"><a href="#Python列表函数-amp-方法" class="headerlink" title="Python列表函数&amp;方法"></a>Python列表函数&amp;方法</h3><p>Python包含以下函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">序号函数</span><br><span class="line">1cmp(list1, list2)</span><br><span class="line">比较两个列表的元素</span><br><span class="line">2len(list)</span><br><span class="line">列表元素个数</span><br><span class="line">3max(list)</span><br><span class="line">返回列表元素最大值</span><br><span class="line">4min(list)</span><br><span class="line">返回列表元素最小值</span><br><span class="line">5list(seq)</span><br></pre></td></tr></table></figure><h3 id="将元组转换为列表"><a href="#将元组转换为列表" class="headerlink" title="将元组转换为列表"></a>将元组转换为列表</h3><p>Python包含以下方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">序号方法</span><br><span class="line">1list.append(obj)</span><br><span class="line">在列表末尾添加新的对象</span><br><span class="line">2list.count(obj)</span><br><span class="line">统计某个元素在列表中出现的次数</span><br><span class="line">3list.extend(seq)</span><br><span class="line">在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</span><br><span class="line">4list.index(obj)</span><br><span class="line">从列表中找出某个值第一个匹配项的索引位置</span><br><span class="line">5list.insert(index, obj)</span><br><span class="line">将对象插入列表</span><br><span class="line">6list.pop(obj&#x3D;list[-1])</span><br><span class="line">移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</span><br><span class="line">7list.remove(obj)</span><br><span class="line">移除列表中某个值的第一个匹配项</span><br><span class="line">8list.reverse()</span><br><span class="line">反向列表中元素</span><br><span class="line">9list.sort([func])</span><br><span class="line">对原列表进行排序</span><br><span class="line">Python 字典(Dictionary)</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是另一种可变容器模型，且可存储任意类型对象，如其他容器模型。<br>字典由键和对应值成对组成。字典也被称作关联数组或哈希表。<br>基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict &#x3D; &#123;&#39;Alice&#39;: &#39;2341&#39;, &#39;Beth&#39;: &#39;9102&#39;, &#39;Cecil&#39;: &#39;3258&#39;&#125;</span><br><span class="line">也可如此创建字典：</span><br><span class="line">dict1 &#x3D; &#123; &#39;abc&#39;: 456 &#125;;</span><br><span class="line">dict2 &#x3D; &#123; &#39;abc&#39;: 123, 98.6: 37 &#125;;</span><br></pre></td></tr></table></figure><p>每个键与值用冒号隔开（:），每对用逗号，每对用逗号分割，整体放在花括号中（{}）。<br>键必须独一无二，但值则不必。</p><h4 id="访问字典里的值"><a href="#访问字典里的值" class="headerlink" title="访问字典里的值"></a>访问字典里的值</h4><p>把相应的键放入熟悉的方括弧，如下实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"> </span><br><span class="line">dict &#x3D; &#123;&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125;;</span><br><span class="line"> </span><br><span class="line">print &quot;dict[&#39;Name&#39;]: &quot;, dict[&#39;Name&#39;];</span><br><span class="line">print &quot;dict[&#39;Age&#39;]: &quot;, dict[&#39;Age&#39;];</span><br><span class="line">以上实例输出结果：</span><br><span class="line">dict[&#39;Name&#39;]:  Zara</span><br><span class="line">dict[&#39;Age&#39;]:  7</span><br></pre></td></tr></table></figure><p>如果用字典里没有的键访问数据，会输出错误如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"> </span><br><span class="line">dict &#x3D; &#123;&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125;;</span><br><span class="line"> </span><br><span class="line">print &quot;dict[&#39;Alice&#39;]: &quot;, dict[&#39;Alice&#39;];</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dict[&#39;Zara&#39;]:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    print &quot;dict[&#39;Alice&#39;]: &quot;, dict[&#39;Alice&#39;];</span><br><span class="line">KeyError: &#39;Alice&#39;</span><br></pre></td></tr></table></figure><h4 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h4><p>向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"> </span><br><span class="line">dict &#x3D; &#123;&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125;;</span><br><span class="line"> </span><br><span class="line">dict[&#39;Age&#39;] &#x3D; 8; # update existing entry</span><br><span class="line">dict[&#39;School&#39;] &#x3D; &quot;DPS School&quot;; # Add new entry</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">print &quot;dict[&#39;Age&#39;]: &quot;, dict[&#39;Age&#39;];</span><br><span class="line">print &quot;dict[&#39;School&#39;]: &quot;, dict[&#39;School&#39;];</span><br></pre></td></tr></table></figure><p>以上实例输出结果：<br>dict[‘Age’]:  8<br>dict[‘School’]:  DPS School</p><h4 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h4><p>能删单一的元素也能清空字典，清空只需一项操作。<br>显示删除一个字典用del命令，如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"> </span><br><span class="line">dict &#x3D; &#123;&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7, &#39;Class&#39;: &#39;First&#39;&#125;;</span><br><span class="line"> </span><br><span class="line">del dict[&#39;Name&#39;]; # 删除键是&#39;Name&#39;的条目</span><br><span class="line">dict.clear();     # 清空词典所有条目</span><br><span class="line">del dict ;        # 删除词典</span><br><span class="line"> </span><br><span class="line">print &quot;dict[&#39;Age&#39;]: &quot;, dict[&#39;Age&#39;];</span><br><span class="line">print &quot;dict[&#39;School&#39;]: &quot;, dict[&#39;School&#39;];</span><br></pre></td></tr></table></figure><p>但这会引发一个异常，因为用del后字典不再存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dict[&#39;Age&#39;]:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    print &quot;dict[&#39;Age&#39;]: &quot;, dict[&#39;Age&#39;];</span><br><span class="line">TypeError: &#39;type&#39; object is unsubscriptable</span><br><span class="line">注：del()方法后面也会讨论。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h4><p>字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。<br>两个重要的点需要记住：<br>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"> </span><br><span class="line">dict &#x3D; &#123;&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7, &#39;Name&#39;: &#39;Manni&#39;&#125;;</span><br><span class="line"> </span><br><span class="line">print &quot;dict[&#39;Name&#39;]: &quot;, dict[&#39;Name&#39;];</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict[&#39;Name&#39;]:  Manni</span><br></pre></td></tr></table></figure><p>2）键必须不可变，所以可以用数，字符串或元组充当，所以用列表就不行，如下实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line"> </span><br><span class="line">dict &#x3D; &#123;[&#39;Name&#39;]: &#39;Zara&#39;, &#39;Age&#39;: 7&#125;;</span><br><span class="line"> </span><br><span class="line">print &quot;dict[&#39;Name&#39;]: &quot;, dict[&#39;Name&#39;];</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    dict &#x3D; &#123;[&#39;Name&#39;]: &#39;Zara&#39;, &#39;Age&#39;: 7&#125;;</span><br><span class="line">TypeError: list objects are unhashable</span><br></pre></td></tr></table></figure><h4 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h4><p>Python字典包含了以下内置函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">序号函数及描述</span><br><span class="line">1cmp(dict1, dict2)</span><br><span class="line">比较两个字典元素。</span><br><span class="line">2len(dict)</span><br><span class="line">计算字典元素个数，即键的总数。</span><br><span class="line">3str(dict)</span><br><span class="line">输出字典可打印的字符串表示。</span><br><span class="line">4type(variable)</span><br><span class="line">返回输入的变量类型，如果变量是字典就返回字典类型。</span><br></pre></td></tr></table></figure><p>Python字典包含了以下内置函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">序号函数及描述</span><br><span class="line">1radiansdict.clear()</span><br><span class="line">删除字典内所有元素</span><br><span class="line">2radiansdict.copy()</span><br><span class="line">返回一个字典的浅复制</span><br><span class="line">3radiansdict.fromkeys()</span><br><span class="line">创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值</span><br><span class="line">4radiansdict.get(key, default&#x3D;None)</span><br><span class="line">返回指定键的值，如果值不在字典中返回default值</span><br><span class="line">5radiansdict.has_key(key)</span><br><span class="line">如果键在字典dict里返回true，否则返回false</span><br><span class="line">6radiansdict.items()</span><br><span class="line">以列表返回可遍历的(键, 值) 元组数组</span><br><span class="line">7radiansdict.keys()</span><br><span class="line">以列表返回一个字典所有的键</span><br><span class="line">8radiansdict.setdefault(key, default&#x3D;None)</span><br><span class="line">和get()类似, 但如果键不已经存在于字典中，将会添加键并将值设为default</span><br><span class="line">9radiansdict.update(dict2)</span><br><span class="line">把字典dict2的键&#x2F;值对更新到dict里</span><br><span class="line">10radiansdict.values()</span><br><span class="line">以列表返回字典中的所有值</span><br></pre></td></tr></table></figure><h3 id="Python-日期和时间"><a href="#Python-日期和时间" class="headerlink" title="Python 日期和时间"></a>Python 日期和时间</h3><p>Python程序能用很多方式处理日期和时间。转换日期格式是一个常见的例行琐事。Python有一个time and calendar模组可以帮忙。</p><h4 id="什么是Tick？"><a href="#什么是Tick？" class="headerlink" title="什么是Tick？"></a>什么是Tick？</h4><p>时间间隔是以秒为单位的浮点小数。<br>每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。<br>Python附带的受欢迎的time模块下有很多函数可以转换常见日期格式。如函数time.time()用ticks计时单位返回从12:00am, January 1, 1970(epoch) 开始的记录的当前操作系统时间, 如下实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">import time;  # This is required to include time module.</span><br><span class="line"></span><br><span class="line">ticks &#x3D; time.time()</span><br><span class="line">print &quot;Number of ticks since 12:00am, January 1, 1970:&quot;, ticks</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number of ticks since 12:00am, January 1, 1970: 7186862.73399</span><br></pre></td></tr></table></figure><p>Tick单位最适于做日期运算。但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年某日。</p><h4 id="什么是时间元组？"><a href="#什么是时间元组？" class="headerlink" title="什么是时间元组？"></a>什么是时间元组？</h4><p>很多Python函数用一个元组装起来的9组数字处理时间:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">序号字段值</span><br><span class="line">04位数年2008</span><br><span class="line">1月1 到 12</span><br><span class="line">2日1到31</span><br><span class="line">3小时0到23</span><br><span class="line">4分钟</span><br><span class="line">5秒0到61 (60或61 是闰秒)</span><br><span class="line">6一周的第几日0到6 (0是周一)</span><br><span class="line">7一年的第几日1到366 (儒略历)</span><br><span class="line">8夏令时-1, 0, 1, -1是决定是否为夏令时的旗帜</span><br></pre></td></tr></table></figure><p>上述也就是struct_time元组。这种结构具有如下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">序号属性值</span><br><span class="line">0tm_year2008</span><br><span class="line">1tm_mon1 到 12</span><br><span class="line">2tm_mday1 到 31</span><br><span class="line">3tm_hour0 到 23</span><br><span class="line">4tm_min0 到 59</span><br><span class="line">5tm_sec0 到 61 (60或61 是闰秒)</span><br><span class="line">6tm_wday0到6 (0是周一)</span><br><span class="line">7tm_yday1 到 366(儒略历)</span><br><span class="line">8tm_isdst-1, 0, 1, -1是决定是否为夏令时的旗帜</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h4><p>从返回浮点数的时间辍方式向时间元组转换，只要将浮点数传递给如localtime之类的函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">import time;</span><br><span class="line"></span><br><span class="line">localtime &#x3D; time.localtime(time.time())</span><br><span class="line">print &quot;Local current time :&quot;, localtime</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Local current time : time.struct_time(tm_year&#x3D;2013, tm_mon&#x3D;7, </span><br><span class="line">tm_mday&#x3D;17, tm_hour&#x3D;21, tm_min&#x3D;26, tm_sec&#x3D;3, tm_wday&#x3D;2, tm_yday&#x3D;198, tm_isdst&#x3D;0)</span><br></pre></td></tr></table></figure><h4 id="获取格式化的时间"><a href="#获取格式化的时间" class="headerlink" title="获取格式化的时间"></a>获取格式化的时间</h4><p>你可以根据需求选取各种格式，但是最简单的获取可读的时间模式的函数是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asctime():</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">import time;</span><br><span class="line"></span><br><span class="line">localtime &#x3D; time.asctime( time.localtime(time.time()) )</span><br><span class="line">print &quot;Local current time :&quot;, localtime</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Local current time : Tue Jan 13 10:17:09 2009</span><br></pre></td></tr></table></figure><h4 id="获取某月日历"><a href="#获取某月日历" class="headerlink" title="获取某月日历"></a>获取某月日历</h4><p>Calendar模块有很广泛的方法用来处理年历和月历，例如打印某月的月历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">import calendar</span><br><span class="line"></span><br><span class="line">cal &#x3D; calendar.month(2008, 1)</span><br><span class="line">print &quot;Here is the calendar:&quot;</span><br><span class="line">print cal;</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Here is the calendar:</span><br><span class="line">    January 2008</span><br><span class="line">Mo Tu We Th Fr Sa Su</span><br><span class="line">    1  2  3  4  5  6</span><br><span class="line"> 7  8  9 10 11 12 13</span><br><span class="line">14 15 16 17 18 19 20</span><br><span class="line">21 22 23 24 25 26 27</span><br><span class="line">28 29 30 31</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Time模块"><a href="#Time模块" class="headerlink" title="Time模块"></a>Time模块</h3><p>Time模块包含了以下内置函数，既有时间处理相的，也有转换时间格式的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">序号函数及描述</span><br><span class="line">1time.altzone</span><br><span class="line">返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。</span><br><span class="line">2time.asctime([tupletime])</span><br><span class="line">接受时间元组并返回一个可读的形式为&quot;Tue Dec 11 18:07:14 2008&quot;（2008年12月11日 周二18时07分14秒）的24个字符的字符串。</span><br><span class="line">3time.clock( )</span><br><span class="line">用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。</span><br><span class="line">4time.ctime([secs])</span><br><span class="line">作用相当于asctime(localtime(secs))，未给参数相当于asctime()</span><br><span class="line">5time.gmtime([secs])</span><br><span class="line">接收时间辍（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注：t.tm_isdst始终为0</span><br><span class="line">6time.localtime([secs])</span><br><span class="line">接收时间辍（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。</span><br><span class="line">7time.mktime(tupletime)</span><br><span class="line">接受时间元组并返回时间辍（1970纪元后经过的浮点秒数）。</span><br><span class="line">8time.sleep(secs)</span><br><span class="line">推迟调用线程的运行，secs指秒数。</span><br><span class="line">9time.strftime(fmt[,tupletime])</span><br><span class="line">接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。</span><br><span class="line">10time.strptime(str,fmt&#x3D;&#39;%a %b %d %H:%M:%S %Y&#39;)</span><br><span class="line">根据fmt的格式把一个时间字符串解析为时间元组。</span><br><span class="line">11time.time( )</span><br><span class="line">返回当前时间的时间戳（1970纪元后经过的浮点秒数）。</span><br><span class="line">12time.tzset()</span><br><span class="line">根据环境变量TZ重新初始化时间相关设置。</span><br></pre></td></tr></table></figure><p>Time模块包含了以下2个非常重要的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">序号属性及描述</span><br><span class="line">1time.timezone</span><br><span class="line">属性time.timezone是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲;&lt;&#x3D;0大部分欧洲，亚洲，非洲）。</span><br><span class="line">2time.tzname</span><br><span class="line">属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。</span><br></pre></td></tr></table></figure><h3 id="日历（Calendar）模块"><a href="#日历（Calendar）模块" class="headerlink" title="日历（Calendar）模块"></a>日历（Calendar）模块</h3><p>此模块的函数都是日历相关的，例如打印某月的字符月历。<br>星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数。模块包含了以下内置函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">序号函数及描述</span><br><span class="line">1calendar.calendar(year,w&#x3D;2,l&#x3D;1,c&#x3D;6)</span><br><span class="line">返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。</span><br><span class="line">2calendar.firstweekday( )</span><br><span class="line">返回当前每周起始日期的设置。默认情况下，首次载入caendar模块时返回0，即星期一。</span><br><span class="line">3calendar.isleap(year)</span><br><span class="line">是闰年返回True，否则为false。</span><br><span class="line">4calendar.leapdays(y1,y2)</span><br><span class="line">返回在Y1，Y2两年之间的闰年总数。</span><br><span class="line">5calendar.month(year,month,w&#x3D;2,l&#x3D;1)</span><br><span class="line">返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。</span><br><span class="line">6calendar.monthcalendar(year,month)</span><br><span class="line">返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。</span><br><span class="line">7calendar.monthrange(year,month)</span><br><span class="line">返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。</span><br><span class="line">8calendar.prcal(year,w&#x3D;2,l&#x3D;1,c&#x3D;6)</span><br><span class="line">相当于 print calendar.calendar(year,w,l,c).</span><br><span class="line">9calendar.prmonth(year,month,w&#x3D;2,l&#x3D;1)</span><br><span class="line">相当于 print calendar.calendar（year，w，l，c）。</span><br><span class="line">10calendar.setfirstweekday(weekday)</span><br><span class="line">设置每周的起始日期码。0（星期一）到6（星期日）。</span><br><span class="line">11calendar.timegm(tupletime)</span><br><span class="line">和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间辍（1970纪元后经过的浮点秒数）。</span><br><span class="line">12calendar.weekday(year,month,day)</span><br><span class="line">返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。</span><br></pre></td></tr></table></figure><h3 id="其他相关模块和函数"><a href="#其他相关模块和函数" class="headerlink" title="其他相关模块和函数"></a>其他相关模块和函数</h3><p>在Python种，其他处理日期和时间的模块还有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">datetime模块</span><br><span class="line">pytz模块</span><br><span class="line">ateutil模块</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;用过的库&quot;&gt;&lt;a href=&quot;#用过的库&quot; class=&quot;headerlink&quot; title=&quot;用过的库&quot;&gt;&lt;/a&gt;用过的库&lt;/h2&gt;&lt;p&gt;这里把自己用过的，并且质量不错的的库做一个汇总&lt;/p&gt;</summary>
    
    
    
    
    <category term="Language" scheme="https://wangzitian0.github.io/tags/Language/"/>
    
    <category term="Python" scheme="https://wangzitian0.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Git个人总结</title>
    <link href="https://wangzitian0.github.io/2014/11/20/Git-notes/"/>
    <id>https://wangzitian0.github.io/2014/11/20/Git-notes/</id>
    <published>2014-11-20T04:28:00.000Z</published>
    <updated>2020-09-30T04:59:07.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>基本使用可以查看阮神博客，我只摘取我自己常用的命令 <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">ruanyf’s blog</a>，注释里面添加的缩写为 oh-my-zsh 里面的 alias 命令。</p><a id="more"></a><h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><p>初始化一个Git仓库，使用<code>git init</code> 或者 <code>git clone</code> 命令 从已有项目中克隆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure><h3 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ga 添加指定文件&#x2F;子目录到暂存区</span><br><span class="line">$ git add [file1] [dir]</span><br><span class="line"># 删除工作区文件&#x2F;子目录到暂存区</span><br><span class="line">$ git rm [file1] [dir]</span><br><span class="line"># 添加当前目录的所有文件改动到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"># 改名文件，S -&gt; T</span><br><span class="line">$ git mv [S] [T]</span><br></pre></td></tr></table></figure><h3 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># gcmsg 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1]... -m [message]</span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 在 review 不通过等情况下，可以通过这个命令撤销+再提交 commit</span><br><span class="line"># 使用一次新的commit，替代上一次提交。   这是一个实用命令！</span><br><span class="line">$ git commit --amend -m [message]</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git branch               # gb  列出所有本地分支</span><br><span class="line">$ git branch -a            # gba 列出所有本地分支和远程分支</span><br><span class="line">$ git branch [branch-name] # 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git checkout -b [branch] # gco 新建一个分支，并切换到该分支</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># gco 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># gm 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># gcp 选择一个commit，合并进当前分支。超级实用命令，典型场景可以把自己的某一次改动并入主分支。</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># gbd 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git branch -dr [remote&#x2F;branch]</span><br></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag,   gpoat &#x3D; git push origin all tag </span><br><span class="line">$ git push [remote] --tags</span><br></pre></td></tr></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># gst 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># glg 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># glol 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty&#x3D;format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># gbl 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># gd 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># gdca 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br></pre></td></tr></table></figure><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># gf 下载远程仓库的所有变动</span><br><span class="line">$ git fetch</span><br><span class="line"></span><br><span class="line"># gr -v 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># gra 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># gl 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># gp 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送所有分支当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --all --force</span><br></pre></td></tr></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line"># 比如线上回滚，一般会保留挂掉的提交，然后 revert 新建提交来回滚。</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入。非常实用的命令，避免在文件夹之间拷贝内容</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h2 id="Github工作流"><a href="#Github工作流" class="headerlink" title="Github工作流"></a>Github工作流</h2><p>Github是强调多人合作的做法，而且希望工程实现持续集成。算是一种比较优美的工作流。</p><ul><li>第一步：根据需求，从master拉出新分支，不区分功能分支或补丁分支。</li><li>第二步：新分支开发完成后，或者需要讨论的时候，就向master发起一个pull request（简称PR）。</li><li>第三步：Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。<br>第四步：你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</li></ul><h2 id="git-branch-策略"><a href="#git-branch-策略" class="headerlink" title="git branch 策略"></a>git branch 策略</h2><p>Git Flow常用的分支</p><ul><li>Production 分支<ul><li>也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改</li></ul></li><li>Develop 分支<ul><li>这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支</li></ul></li><li>Feature 分支<ul><li>这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release</li></ul></li><li>Release分支<ul><li>当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支</li></ul></li><li>Hotfix分支<ul><li>当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release</li></ul></li></ul><h2 id="Best-Practice"><a href="#Best-Practice" class="headerlink" title="Best Practice"></a>Best Practice</h2><ul><li>Never work on master</li><li>Pulling master should never create a merge commit</li><li>Tests are run after pull and before commit</li><li>Describe Features in Issues</li><li>Work on Issue Specific Feature Branches</li><li>Regularly git rebase origin/master Feature Branches to updated master</li><li>Interactive Rebase before Creating Pull Request</li><li>Peer Review Pull Request</li><li>Delete Feature Branch after Pull Request Approval</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h2&gt;&lt;p&gt;基本使用可以查看阮神博客，我只摘取我自己常用的命令 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&quot;&gt;ruanyf’s blog&lt;/a&gt;，注释里面添加的缩写为 oh-my-zsh 里面的 alias 命令。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Best Practice" scheme="https://wangzitian0.github.io/tags/Best-Practice/"/>
    
    <category term="Tools" scheme="https://wangzitian0.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>聊聊过去，聊聊现在，聊聊将来</title>
    <link href="https://wangzitian0.github.io/2014/06/22/Talk-about-past-now-future/"/>
    <id>https://wangzitian0.github.io/2014/06/22/Talk-about-past-now-future/</id>
    <published>2014-06-22T08:23:00.000Z</published>
    <updated>2020-09-30T04:59:07.881Z</updated>
    
    <content type="html"><![CDATA[<p>　　梦想是什么？梦想是越过生活的障碍，看到的更遥远的东西。</p> <a id="more"></a><h1 id="曾经的高考"><a href="#曾经的高考" class="headerlink" title="曾经的高考"></a>曾经的高考</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">理解了世界上的种种差别，才好从容易着力的地方用力。</span><br><span class="line">------这是高考教会我的道理</span><br></pre></td></tr></table></figure><p>高考之后我就再也没有写过关于高考的事情，进大学那段时间也一直在想将来要干嘛，一直没有回头过，现在来补上一个总结吧，毕竟过去这么久了，很多事情都能用冷静的眼光去看了。<br>我不知道是应该说高考过去两年了还是说高考过去三年了，大家所说的那些记忆深刻的事情基本上是在第一年，实际上对未来起作用的事情基本上在第二年，一混起来吧就感觉全模糊了。稍微写写印象特别深的事情。</p><ul><li>第一件事情就是被每一个教过我的语文英语老师盯上了，把班平拉低零点几被找去谈话是很正常的事情，主题是“你应该好好努力，班平比隔壁班低就差你这一点”。我安静的呆在教室学习的时间有三分之二用来学习语文和英语了，但是这两门高中始终处于班上垫底水平，以至于其他人语文英语考砸了都要到我这来找找安慰，卧槽，现在想起来还是觉得蛋疼。由于有着一种死猪不怕开水烫的心态，语文打70分（没错，150满分）的时候我也是死皮赖脸的嘻嘻哈哈。<br>复读这一年也是差不多三分之二的时间在学语文英语。你说我不努力么？实在不是，大把的时间砸上去了，就是没效果。但事实就是这样，一篇一页纸的东西，大部分人一个小时就能背下了，我可能要一周的所有早上，花时间就算了，问题是几乎是背完就忘，默写听写几乎就没拿过满分，其他的部分也是这样。</li><li>第二件事情就是被教理科的老师盯上了，被找去谈话也是很正常的事情，主题是“你不应该犯这些错，你本不该打这个分数”。我身上有一个很奇葩的现象，没几个人出来的题目我经常能算出来，但是很简单的地方也经常犯错。不过这个问题在复读这一年改善非常大。<br>很多人都说老师一般只会关注两头的学生，抓及格率和优秀率。说我高中过得惨兮兮的绝对没错，莫名其妙的被老师逼着走，于是高中文化课学习的主线就是蛋疼。</li><li>第三件事情是凤凰山黑网吧。因为有机房钥匙，所以一大帮子人周末在机房开黑。还有好几次通宵，实在玩得太嗨了，咳咳，还有用来开发大家的心智的纯洁善良小游戏。</li><li>第四件事情是206时期，每天海象突击队都会组织一波猛烈的进攻（我啥都没说），以及回寝唱歌+喝一两口邵阳老酒，咳咳，206的人才懂……</li><li>第五件事是104时期的大拇指文化，简直优秀得不行，槽点过多。。。一年后返校生活老师对我们说：“从来没见过你们这样的学生，现在这些学生不晓得多听话。”估计她以后也碰不着了，咳咳，我们得过一次文明寝室（注：每周评一次）。</li><li>第六件事是晚自习在走廊和田径场的游荡，呼吸新鲜的氧气。注：根据蒙哥的理论，灵长类雄性生物见到优质雌性生物后肾上腺激素和雄性激素的分泌会同时增加，相当于进行了有氧运动。</li></ul><p>其他的事情好多都感觉模糊了，或者只剩几个画面了，不像上面这些事情记忆深刻。<br>事后来看两次高考，还是觉得收获大于不愉快。首先是两拨靠谱的兄弟，特别难得。其次是第一年高考后很全面的反思了自己，真的就是穷则变，变则通。另外，因为很多事情都干得太费劲，不得已去想到底是什么原因，进而调整处事的策略，学着顺势而为。还有，能来北京也是很好的一件事情，在一个城市读几年书比自己背着个包就跑出来混要平滑轻松得多。 最后，语文英语花那么多的时间也是非常值得的，至少我现在可以做到文笔流畅，英语基本阅读没有问题。而且当时如果没有花那么多时间，考的大学会要掉一个层次。<br>复读让很多事情绕了个圈圈。也是通过这么个事情，获得了两个能力：一是把一个事情和别人说，基本就能判断身边的人分别有什么看法，会有什么反应，甚至是发多大的脾气。第二个是掉了一次大坑之后突然对各种文档和文件中措辞的差异特别敏感，现在见到各种通知基本上都不会理解错。或者说是这一年心思变得更加细致了。<br>还是开头这句话：理解了世界上的种种差别，才好从容易着力的地方用力。进了大学之后我就开始用这句话了，把力气花在最有价值的地方。用13年的时间去证明和了解自己的欠缺，代价应该够大了，不如学聪明点，因循善诱。学东西快就多学一些杂的东西。既然大部分科目花一两个通宵也能打着70分，花几年也肯定打不到95，那就打70呗，反正将来要用的时候还得重学。感觉现在学的这些课程看看概念和符号就行了，怎么想怎么推怎么算其实都不难。能快速学东西，能知道怎么用，能知道它能干嘛就行了，怎么干让更牛更踏实更细致的人去琢磨。去做那个把0变成1的人，至于如何把1变成10，把10变成100，让更优秀的人来。<br>　　作为一个水货，就应该走水货的路线，邯郸学步只会学得四不像。两军交战，用同样战术，那一定是兵力优资源多的那方胜，弱的那一方想胜必须学会集中所有优势去打一个点。</p><h1 id="专业上曾经的设想"><a href="#专业上曾经的设想" class="headerlink" title="专业上曾经的设想"></a>专业上曾经的设想</h1><p>　　先贴两篇三年前写的东西吧，复读，大一，大二加起来一共三年的时间，都在按照那个时候的规划在学东西。当时说我有病的人远远多于认同我的人，现在好像没人这么说了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">第一篇：《专业方面的想法》这是第一年录取结果出来之后发出来的，发完不久我就去准备复读事宜了。</span><br><span class="line"> </span><br><span class="line">半个月前写了这些字：</span><br><span class="line">　　总的来说我还是想学计算机的或计算机相关的如电子信息，通讯，软件，如果被录到车辆，电子，机械，自动化，土木之类的工科专业也还行，除此之外心理学或者哲学吧。</span><br><span class="line">　　觉得很奇怪？这不像我的风格？我也这么觉得的……当然，我一直很讨厌马克思理论什么的，过去是这样，现在是这样，将来估计还是这样，看着这类歌颂D的东西就烦。不过，就这一年，自己发生了翻天覆地的变化，很多事情的看法变了。可能接触跟人文有关的东西，更能了解自己，更能了解别人，对未来的好处可能会更多。当然了，不知道大学是不是还是像高中的政治历史可那样硬生生的给你套上“对”或“错”，或者动不动就说xx思想是不高尚的。方法论有好坏之分，价值观无高地之别，如果是那样，还是别学算了……</span><br><span class="line">　　另一方面，如果学计算机的话压力会很大的。并不是说学计算机的人多，这个问题不是个问题。关键是计算机业是天才最多的行业，很多人的想法都是非常奇特非常巧妙的，不服不行。而且敲代码这种事情需要心里极度安静，注意力高度集中，而且动不动就是长时间的工作。计算机是个很怪的学科，基础知识学好可能就是个把月的事情，可是学会怎么去用它却要花上很长很长的时间。就我现在接触的东西来说，已经有这种感觉了，很多高手十几行的事情，菜鸟要上百行，很多方法妙不可言啊。这个东西就要多和自己水平差不多的人交流才会有进步的，所以考个好大学很重要的。但它又是很罕见的不在乎出身的行业之一，别人招人都是直接考试的，不管你哪里毕业的。总的来说，想要混口饭吃不难，可是想要有点实在的成绩就要玩命了，而且它本身成功的人也不会多。还可以肯定一点，读计算机我一定不读研。</span><br><span class="line">　　别的方面，机械类还行，相对计算机会轻松一点。从小就喜欢盘弄这些东西，那时候就很喜欢拆东西，虽然很少有东西给我拆的，就算奔放起来拆了东西的结果不是被骂就是被打。现在来看我还是愿意去面对那些杠杆齿轮什么的东西。能把想法做成具体的东西，这个专业也比较适合我的。</span><br><span class="line">　　其他的电子信息基本应该和计算机差不多，当然还有很多研究型的理工学科或者基础学科……但我肯定不会学。其它的专业就更不考虑了……</span><br><span class="line"> </span><br><span class="line">今天发现两个杯具，补充一下：</span><br><span class="line">　　1.被****大学录取了，学校相当不错了，很多专业都牛逼。但我录取的是环境工程，我没脾气了……</span><br><span class="line">　　2.大学不管什么专业都有马克思哲学，说是要建立正确的人生观价值观，这尼玛非常的不科学……</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>第二篇：《“蓝海精英”与个人规划》，高三那个暑假看记录片的时候顺路整理的笔记，我现在依然觉得这些观点就算过了很长时间都不会过时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">　　08年的央视纪录片“蓝海精英”应该是有关新领域创始者最好的纪录片了，记得零八年的时候看过一集，是关于施正荣的，他建立的光伏产业佼佼企业“无锡尚德”曾经被大家广泛歌颂。但是后来出问题了，现在被人骂的体无完肤。这几天想到这个了，决定把剩下的看完，感觉还是启发比较大的。蓝海是指未被人们开发的海，蓝海精英们的大多数注定是不被人广泛知晓的，甚至是炮灰。</span><br><span class="line">　　加上之前看过的一些现代人物的传记，突然想总结一下这些人的特质。山寺月中闻桂子，郡亭枕上弄潮头。希望将来也能成为这样的一小撮人吧。就算不能，这些品质和特性绝对是优秀人士所具备的，现在开始就要努力去构建自己的能力体系：</span><br><span class="line">　　首先，他们几乎都是技术疯子，或是高学历偏执狂，或是掌握行业发展动向的海龟。他们在合适的时间成为了第一波拓荒者，“生于春天”可以很好的用来形容他们的时代，处于一个行业爆发点。</span><br><span class="line">　　其次，预见未来的趋势，分析人们的需求，理解人们的抱怨，把握理解政府政策的走向，不逆天。</span><br><span class="line">　　再次，善用逆向思维。几乎这几个企业家都有一个理念，别人做什么我就偏不做。用不同于大众的方法猛搞第一桶金或者拉牛-逼的vc，在恰当的时候转型或变革成为相应领域的绝对领跑者。</span><br><span class="line">　　与此同时，善用各种奇葩风骚的方法挖人墙角，收关键人才。猎头挖对手高层，高薪抢高水平人才，忽悠与自己行业无关的奇才，这系列的片子里每一个boss都有一套怂恿人的“歪理”，用此实实在在的笼络了大批人才。</span><br><span class="line">　　一直不忘坚持走正道，公开见光，却又善于合法合理的“不守规矩”。有骨气，不轻易融资或挂靠。</span><br><span class="line">　　品牌意识与不间断的微创新体制。应该是这两点保证了这几家企业长年的稳定发展....</span><br><span class="line">　　重实质不重表面，不讲屁话，只讲怎么做。</span><br><span class="line">　　有野心和野性。在不得不与大头正面冲突的时候不孬，敢干，凭靠硬霸的实力取胜。</span><br><span class="line">　　给人留下充足的空间，放权并允许犯错。是牛人却没有牛人的臭架子，能第一时间了解大家的各种心声。</span><br><span class="line">　　产权，资本和控制权的牢靠掌握。能把企业能做大的人都通晓资本，失控就没得玩了。</span><br><span class="line">　　他们的这些特质让企业飞速发展，他们的个人能力也同样重要：</span><br><span class="line">1.内心坚定执着，近乎变态的抗压能力。在困难面前，在怀疑面前，在否定面前，能够毫不动摇自己的信念。</span><br><span class="line">2.清晰冷静的自身定位与决策，不盲目看感觉，能站在信息不对称的有利面，善于听取不同意见并合理分析。</span><br><span class="line">3.不急不躁不操-蛋。以一种中庸的速度行事。</span><br><span class="line">4.专注。这几个企业家几乎是细分行业的领跑者，却异常坚定的做自己的点。</span><br><span class="line">5.静待诱惑。在诱惑面前静下来，不什么诱惑都去，不被潜在的陷阱吃掉。</span><br><span class="line">6.看的开，放得下。败了就败了，挂了就挂了，不偏执的坚持错误，该放开就马上放。</span><br><span class="line">7.精通忽悠之道。没有这一条前面的道理都要打折扣。反之，善于忽悠的人能协调好各种关系。</span><br><span class="line">8.实干。注重问题能不能搞定，忽略无关紧要的事，不讲虚的理论。</span><br><span class="line">9.义利合一。不忘记肩膀上的责任，担当社会。</span><br><span class="line">10.有稳定幸福并支持自己的家庭，后院无火。</span><br><span class="line">11.及其重要的一点，精通“人”学，知人知面知心。</span><br><span class="line">12.有激情。提到一些关键字，这些boss瞬间眼睛放光，语速加快，一股强大的力量瞬间爆发。</span><br><span class="line">13.幽默大度。懂得怎么去除别人和自己的压力。</span><br><span class="line"> </span><br><span class="line">看的时候想到什么就记下了了，没什么调理，仅仅只是记录一下。受能力和阅历的限制，能注意到的差不多就只有这么多了。</span><br></pre></td></tr></table></figure><h1 id="今天的设想"><a href="#今天的设想" class="headerlink" title="今天的设想"></a>今天的设想</h1><p>　　很久很久以前，我给自己的定位就是从商，我说的从商不是说单纯的买卖，而是说去创造市场需要的东西，是把一个个好的产品带到大家的生活中去。用科技和商业的力量去改变大家的习惯，也用自己的努力去改善自己的生活。读了两年大学，重新整理一下对这个问题的看法，也是对前程的一个规划。<br>　　先反思。<br>理工科的人概率论和线性代数谁都学对吧？那计算机院本科的专业前十叫来，或者随机抽10个研究生来，有几个知道平时上课学的概率论中的马尔可夫被广泛用作语音语义模式识别系统？有几个人知道线性代数中的矩阵知识怎样被用到网页搜索引擎中？又有几个人知道余弦定理可以用于信息分类技术？<br>Java应该大部分北邮人都学吧？给两周时间和不准咨询其他人，有几个能开发一套特定框架的完整c/s模式的app或网站？有几个能挂一个hadoop文件集群出来？又有几个人能给一个几十G的数据集挖出指定信息？<br>　　窥一叶而知秋，初级版不考虑精度和效率的这些问题都不算高深，但在北邮本硕阶段的人能答yes的人是真的很少，碰上几个也基本上是和自己研究方向有关所以了解。前面的问题属于做学术的人应该很早就应该知道的，后面的问题属于做工程的人应该很早就熟悉的。很多人其实是在用战术上的勤奋去掩盖战略上的懒惰，听从舆论而没有自己仔细的思考过该如何学习东西，把大学当成加强版的高中着实没有必要。<br>课本上没有的东西把课本学烂了也学不到这些关于“用”的知识，但计算机学科的核心全在一个“用”字上。同一个人，完全没有方向的去学三年后再用两年去做具体工作，和快速学习半年然后花三年边学边做，一定是后面这种方式做出来的东西更优。<br>我觉得我非常不适合做学术，甚至是坚决不读研。见过两三个白发苍苍的治学和理念都无可挑剔的老教授后感觉更强烈，既敬又畏，心底里觉得我做不到那样，我更适合做应用性的东西。刀子能用就行，磨得太快反而容易折断。我本身个性就偏强势急躁，一个团队中PUSH型的人学历高往往不是好事，对我而言有个本科差不多就够了。<br>我对自己将来的定位是做产品，我的理解一直就是技术永远只是做产品的一个辅助手段。很多人对技术和产品的理解偏差是很大的，比如“你好，我们是一个优秀的团队，还缺一个敲代码的。”，这就属于缺乏技术理念的。搭建一个小网站或者做一个小应用真的不算太麻烦的事情，一个野路子码农学一两个月就能做到，但产品初期更多需要考虑是设计和需求，偏重理念而不是技术。只有把这个产品的用户量从100这种数量级扩大到10000，或者从10000到1000000的时候，又或者是把一个东西的精度比率从1%提高到10%，或是从10%提高到90%的时候才需要科班出身的技术人才。也是基于这个原因，见到前面这句话基本上就可以把这个人拉黑了，会说那种话的肯定对技术没概念，对产品也没概念。<br>古人云：千军易得，一将难求。吾志乃为良将，电子信息行业的良将最需要的能力应该是下面这些：<br>0.有胆识，敢亮剑。亮剑不是不知者无畏，而是在充分考虑了细节后，明知后果，明知不敌，依然敢尝试，依然有亮剑的勇气。<br>1.权谋。平衡各种因素与力量的能力，市场与技术，细节与效率，扩张与收缩，制衡。<br>2.产品能力。敏锐的感知身边的问题，能判断一个产品一个想法能迎合哪些人，迎合多少人。<br>3.快速学习的能力。需要用到一门知识或者技术，能迅速的学会并知道怎么用。看到别人用的东西，能自己迅速的模仿出来。<br>4.快速demo的能力。能快速把想法转化成看得见的产品的能力，不一定要好用，但一定要能快速做出来给他人验证。　　<br>5.有完整的技术架构思维。不精通不是问题，但得提前认识精通的各路神人，别等有事了再去膜拜各路大仙。　　　　<br>6.解释的能力。能装的下完全矛盾的思想，并不被它们影响到行事，做事能找到“理论支持”。<br>　　这些能力几乎都不是象牙塔里读读书就能学到的，只有真抓实干，到项目中，到企业去，到现场去，真刀真枪的拼才能获得。当然，有机会MBA得去。<br>　　未来，我的归宿一定是创业型中小型企业或者是大企业开发新产品的组，有更多空间的地方，更容许犯错的地方，更能释放才智的地方。打策略游戏，我的特点非常明显，善打不善治。限制非常多的时候我做事不如绝大多数人，但是在大部分人都不知道怎么做的时候，经常能有一些奇招损招。<br>　　这两年能看到并且愿意走的道只这几条：<br>1.想到感觉很好的产品型项目，或者有机会遇到产品能力远高于自己的人，动手做。<br>2.肖姥爷那样出去待几年。<br>3.去bat，ms，gg工作三五年，攒经验，攒钱，等下一波大浪潮跟风。<br>4.回长沙，做非电子信息行业的事去，好好的享受生活。<br>难度上依次递减，但都是不错的选择，怎么抉择现在也说不准，还有时间去调整，走一步看一步就好。</p><h1 id="认识自己"><a href="#认识自己" class="headerlink" title="认识自己"></a>认识自己</h1><p>　　做人有所为不难，难的是有所不为。这三年一直在想如何才能不人云亦云，如何才能善用自己的特质，如何才能在做事的时候少费点劲。对于很厉害的人而言，做什么都能做好，不考虑太多也没关系。但对于我这种能力中等且极为极端的人想到什么事情，该不该做是需要仔细判断的。我一直是顺着这么个思路来的，若百分之九十的人都认同，那不用去干了，好机会肯定轮不到我了，如果不到百分之一的人认同，那也不用干了，说明过于理想化，无势难成事。<br>一句话由一个人说你可能会不以为然，由十个人说你可能将信将疑，由一百个人说你肯定信以为真。按着别人的方法去做事，完全不管天时地利人和的差异，很有可能就把自己带偏了，感觉就是干得特别费劲却事情干不成。读书人与非读书人最大的差异就是读书人能看得更高更远，更能贴近事物本质，更能独立思考，如若不然，读书只能给人带来“想太多”的不愉快。<br>　　哪些特质最重要？这个问题我想了很久很久，就用一棵树来打比方来给出我的答案吧。首先是树根，牢固的根系是树成长的根基：处事上有清晰的逻辑，个性上内敛坚忍执着，态度上不与规则对抗。其次是树顶，没有顶端优势的树长不高：做选择时往机会与可能性多的地方走。树枝，各种通识与专业能力，枝干越庞大意味着树也越大：文艺史哲政经数理管法码。叶子，具体的某一门课，一本书，一种思想，一种方法都是一片小小的叶子。树干，大树最不可或缺一部分，是它将树的每一部分串起来：对过往的反思能力。<br>根基是无论如何不能改变的，根变树倒，这三条根基改变了任何一条都会让之前的很多努力白费。树干必须保持完整，永远不忘记自己从哪来要去哪，不否定曾经做过的事情，无论是好的还是坏的，好事可以让自己有更多选择，坏事可以清除道路上的业障，是它们的相互作用产生了现在的我。顶端优势尽量不丢，站在路口，面对已经选择了的，正在选择的，还没有选择的路，去选择人迹更罕至的那条，去选择精彩，去面对必然的艰辛。有意识的让树枝完整，向不同的方向扩散，也许多一根少一根对树的影响不大，但是拥有更多枝干的树长得更轻松。至于叶子，只要让它顺应季节生长，能进行足够的光合作用为树提供能量就可以了，无伤筋骨。<br>人与人的出身的差别也可以用树来打比方。一棵长在温室里，在适宜的土壤，温度，空气湿度，二氧化碳浓度中生长，无论这棵小树有多弱小，最终总会很容易成长强大起来；而另一棵长在无人问津的石缝中，天气有多恶劣他就有多苦难，除了要与周围的树竞争养份和空气中的碳元素以外，还要忍受风暴，雷电，干旱，泥石流的冲击。这还不是最惨的事情，最惨的事是这种环境出来的树十有八九会长成歪脖子树。当然，这种树也不熟一无是处，只有这种树才是真正能承受风雨的树。两种树无好坏之分，各有所长。前面这种树就应该成为栋梁之才，成为桌子椅子柱子；后面这种树就应该成为靓丽的风景，为鸟兽遮风挡雨。霸蛮逆行倒施只会让这两种树都变成废木头。</p><p>　　感觉这几年面对着特别多无法辩解的事，无法自辩那就让时间来解释呗，时间总会证明一切。</p><h1 id="这一个学期读的书，看的剧"><a href="#这一个学期读的书，看的剧" class="headerlink" title="这一个学期读的书，看的剧"></a>这一个学期读的书，看的剧</h1><p>《活法》商圣稻盛和夫向世人传递的理念。中日文化本身就相似，六十年代东京奥运会时期日本的发展和现在的中国更是非常相似，他能在那样一个时代把企业经营到那样一种规模，他的理念一定适用于当代中国。这本书从头到尾都透着智慧，让人读着心安。</p><p>《数学之美》建议搞不清大学计算机专业的理科基础课到底有什么用的人可以去读一读。作为facebook，疼讯的高级工程师，吴军博士通过这本书非常好的归纳了互联网里所用的数学。这本书通俗易懂，拓展了不少应用知识，有不少知识的应用我都之前没见过。零零碎碎的学不如去找这种成册的书，事半功倍。</p><p>《死亡如此多情》当断不断，反受其乱。大篇幅讨论生死边缘的人的痛苦。提到安乐死，理念略超前。尽人事，随天命。很多事情人是需要提前准备的，包括死亡。</p><p>《重口心理学》标题党，不过里面的案例不错，了解人的脆弱面，每个人的出发点不同，对同一件事情的处理就会不同，对同一件处理看法也会不同。里面有一章关于强迫症的，一直觉得调戏强迫症患者是一件特别有意思的事情，哈哈哈哈。</p><p>《数据之美》如何把数据整得让人看懂。</p><p>三本关于游戏和设计的书，讲各种各样看起来理所当然，但实际上深思熟虑的交互理念。</p><p>《曾国藩全传》很震撼的书，曾在近代中国史上是一个饱受争议的人，但是他的奋斗史和为人之道却从未被人质疑过。<br>　　志大人之学。读书人在年轻的时候就应该要学会见天地，见众生，见自己。<br>经世致用。近代中国讲了两百年，湖湘人也一直被这四个字标榜。这是他早年治学的基本态度，一方面精读儒学理学，悉通八股，也是靠着这一套走上仕途。另一方面吸收四方的学说言论，胸怀韬略，为日后创湘军打下一个扎实的根基。<br>有原则。为官多年，始终清廉正直，不入泥潭。用人不拘一格，不因私废公。治家严明，不骄奢淫逸，让曾氏一族香火兴旺。还有很多的原则，。<br>庸人毁于惰，才人毁于傲。历史上大部分尾大不掉的非宗亲蕃王都死于非命，他却能在封建统治手段接近变态的晚清全身而退。他是一个能在历经巅峰之后还能保持清醒冷静的人。<br>与胡雪岩同时期，晚晴最值得学习的两个人，正所谓“做人曾国藩 做事胡雪岩”。</p><p>《历代经济变革》吴晓波书系，不愧是中国最畅销的财经作家，本本精品。中国几千年的商业史就是一部商政博弈历。在中国，很多事情不理解根源就会让人举步维艰。还有桑弘羊之问，仔细想想，历朝历代各个国家所有的经济制度，三个问题中都一定有一个问题答不上，和互联网的cap理论有异曲同工的感觉。有时间得把他的“浩荡·跌荡·激荡”三部曲读完吧。以管理者和观察者的角度来看待各种经济制度和管理制度，了解不同管理方式的特性。警醒自己，永远不要做类似于郎咸平那样的愤怒喷子酸腐文人，只知道说啥也不好，但啥建设性方案也给不出。</p><p>电视剧，感想：<br>《楚汉传奇》<br> 1.两个实力相当的人竞争，一定是出身差的胜，身份层次转换跨度越大的人洞察力越敏锐<br> 2.做事下手一定要快，先把资源占了再让出来远远好过没有资源向别人求<br> 3.要面子不如要里子<br> 4.一流的部队和二流的部队混在一起，战斗力连二流都不如<br> 5.乱世出英雄，草蟒之人只有在乱世才能爬上梯子顶端<br> 6.部下最需要领导做的事情不是嘘寒问暖而是赏罚分明<br> 7.谋大事需不动声色。</p><p>《康熙王朝》<br> 1.豪情万重天，做事先做人，男人需要有大山大水的情怀<br> 2.用人之道，平衡之道。<br> 3.人最经不起的事情是后院起火。<br> 4.祸事迟早要来，迟来不如早来，趁着年轻老子就把它干了。<br> 5.只要选择了往前走，憋一肚子委屈就是常态<br> 6.一流领导手下一定会有党争，二流领导手下同仇敌忾一致对上。</p><p>《雍正王朝》<br> 1.上有政策，下有对策，万古不变的规律<br> 2.创业难，守成更难，变革难上加难。<br>  3.集权会导致效率下降，分权易导致纷争<br> 4.鼎故革新的人往往死得惨<br> 5.用利益制人才是最好的制人方法<br> 6.变革要温水煮青蛙，太急无法成事<br> 7.明流下还有暗流，暗流比明流更可怕。</p><p>《汉武大帝》<br> 1.在等待的过程中准备，在忍受的过程中蓄势<br> 2.儒道法三家思想的矛盾和统一，古往今来成大功业者十有八九走的是法家道路<br> 3.汉族的民族特性很多两千年没有变过，<br> 4.成大功业的国注定劳民伤财，能成大功业的人往往精疲力竭。<br> 5.攻守异术，很多事情要绕着弯做才能做成，这是东方人特有的智慧。<br> 6.等待这首歌原本是阿娇出嫁时的配乐，小歌小调被磊叔唱完意韵完全变了，温柔不是什么了不起的事情，强硬的人温柔才有杀伤力。</p><p>《新三国》<br> 1.凡事讲究天时地利人和<br> 2.管理分霸道和王道，恩威并施最好<br> 3.仔细查了下三国时期各大城市的地名，特别有意思<br> 4.忽略三国演义的偏见，对司马懿的看法变了<br> 5.三人打架，最难当的是实力排第二的人，老大拣老二打就行了，老三保护自己看热闹就行，老二需要联合老三来打老大，却又与老三是对手，世上最难处理的关系莫过于亦敌亦友<br> 6.三国是最好的MBA教材，各种模式的领导都能找到原型，熟读三国历史的人领导力都不会太差。</p><h1 id="这个学期平时做的一些笔记"><a href="#这个学期平时做的一些笔记" class="headerlink" title="这个学期平时做的一些笔记"></a>这个学期平时做的一些笔记</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">平时积累的每一点才华，都可能在机会来临的时候变成杀手锏。</span><br><span class="line">与虚幻越接近，越能以观察者的身份看清现实，革命性的事物思想都源于虚幻。</span><br><span class="line">宁可遗憾，绝不后悔。</span><br><span class="line">人失我得不在争。</span><br><span class="line">无为而治，不在事物变化前作为。</span><br><span class="line">骨气，和气，义气，勇气。</span><br><span class="line">见天地，见众生，见自己</span><br><span class="line">古往今来，有太多委屈压不弯脊梁的人，悲悯而壮烈的正史恰恰是这样的一群人书写的。</span><br><span class="line">古来凡是有大才俊者，必有不尽人意之处。</span><br><span class="line">心地，心气，心思</span><br><span class="line">中庸之道，天容万物，海纳百川。</span><br><span class="line">不要用战术上的勤奋掩盖战略上的懒惰。</span><br><span class="line">我们所有学习的东西，总有一天都会用上，所有没有学习的东西，将来都要补课。</span><br><span class="line">爱而得到，幻灭痛苦怨憎；爱而不得，告别哀伤升华；</span><br><span class="line">宁做真小人，不做伪君子。</span><br><span class="line">明明是幼稚幻想症，却称自己是理想主义者；明明是认输的怂逼，却偏自诩为成熟沉稳、深谙世事。</span><br><span class="line">度过困难，你有了度过困难的智慧；面对困难，你有了面对困难的勇气；绕过困难，你有了绕过困难的狡猾。 </span><br><span class="line">草在结它的种子&#x2F;风在摇它的叶子&#x2F;我们站着，不说话&#x2F;就十分美好。</span><br><span class="line">测验一个人的心智是否属于上乘，只看脑子里能否同时容纳两种相反的思想，而无碍于其处世行事。</span><br><span class="line">谦虚不是把自己想得很糟，而是完全不想自己。 </span><br><span class="line">思想如哲人，心术如武士，才干如俗吏，身体如农民，方成实业之俊杰。</span><br><span class="line">东方的智慧，西方的运作，全球的市场。</span><br><span class="line">韧内敛、沉稳平和，忍人之不能忍，扛人之不愿扛</span><br><span class="line">无畏，无所谓</span><br><span class="line">屡败不乱，蒙羞含耻而无动于衷。</span><br><span class="line">爱情是两个强者的风花雪月，而不是两个弱者的苦大仇深。　　　　　　　　　　　　　　</span><br><span class="line">善战者，一往无前。善谋者，瞻前顾后。</span><br><span class="line">忍耻含愤，平静如水。</span><br><span class="line">莎士比亚说，适当的悲哀可以表示感情的深切，过度的伤心却可以证明智慧的欠缺。</span><br><span class="line">心宽似海，临危不乱，将相之风也。</span><br><span class="line">把脾气拿出来叫本能，把脾气收起来叫本事。</span><br><span class="line">妥协于形，不变于心。</span><br><span class="line">三千年读史，不外功名利禄。九万里悟道，终归诗酒田园。</span><br><span class="line">无以立业，何以家为。</span><br><span class="line">十年是一个里程，没有碑。</span><br><span class="line">孤独导致幻想，幻想导致创作。</span><br><span class="line">有些才华需要时间沉淀。</span><br><span class="line">学历是铜牌，能力是银牌，人缘是金牌，思维是王牌。</span><br><span class="line">长得美丽帅气，自己却不觉得，这就是气质；有钱有才华，别人却不知道，这就是修养。</span><br><span class="line">名声是误解的总和。</span><br><span class="line">有路的时候就应该坚持着把它走完，没有路的时候也应该走下去，走到看到路为止。</span><br><span class="line">大牌只有在最关键的时候打才有用。</span><br><span class="line">牛人多，无怨无悔的人少。</span><br><span class="line">人力所能及，做到极限。</span><br><span class="line">文人应该有情怀、有坚持、有风骨</span><br><span class="line">在中国，不得志的知识分子往往有犹疑不决、疲于奔命、懦弱的个性。</span><br><span class="line">优秀男人应该在阴郁中露出阳刚之气，在儒雅中透着逼人的霸气。</span><br><span class="line">做一个满腹经纶，却不炫耀的平凡人。</span><br><span class="line">用更多的时间和精力去积累内心的力量，必须让自己经得起沉淀。</span><br><span class="line">打狗还得找墙角。</span><br><span class="line">背对名利，面对强敌，才能保持坚毅决心。</span><br><span class="line">世上最柔弱者为水，碰到阻碍则会改变形态，放在圆形的容器则圆，放在方形的容器则方，看似无所主张，形成洪水则无所阻挡。</span><br><span class="line">守弱，谦下，虚怀若谷。</span><br><span class="line">剑术再好，只能敌一两个人，没什么好说的。要学就学兵法，学如何万人敌。</span><br><span class="line">慎在于畏小，智在于治大。</span><br><span class="line">狼和狗长得像，但狼一看狗就知道是狼还是狗。</span><br><span class="line">晚上千条路，白天一条路。</span><br><span class="line">互联网的实质不仅仅是技术，更是一种理念，一种讲究“专极快”的方法论，懂这种方法论就相当于懂互联网的精髓了。</span><br><span class="line">战争不仅仅是军事的较量，更是国策与国策的较量。将领和战术重要，但更决定性因素还是综合国力。</span><br></pre></td></tr></table></figure><h1 id="就写到这吧"><a href="#就写到这吧" class="headerlink" title="就写到这吧"></a>就写到这吧</h1><p>憋了两天才写完，囧<br>暑假加接下来一个学期，两个核心的目标，继续闷声前行。无论什么形式的野心都需要落到实处，都需要用才气，毅力和耐心来支撑。牢记这三个词“守弱，谦下，虚怀”，命中注定该遗憾的事情终究会遗憾，求一个全力以赴不后悔足矣。<br>每一篇总结都拿歌词结尾，这次拿《等待》吧，等待是沉重的，漫长的，无聊的，焦灼的，失落的，但是，永远不要忘了自己是因为期待而等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">我为什么还在等待</span><br><span class="line">我不知道为何仍这样痴情</span><br><span class="line">明知辉煌</span><br><span class="line">过后是暗淡</span><br><span class="line">仍期待着把一切从头来过</span><br><span class="line">我们既然曾经拥有</span><br><span class="line">我的爱就不想停顿</span><br><span class="line">每个梦里都有你的梦</span><br><span class="line">共同期待一个永恒的春天</span><br></pre></td></tr></table></figure><p>—-写于14年暑假开始 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　梦想是什么？梦想是越过生活的障碍，看到的更遥远的东西。&lt;/p&gt;</summary>
    
    
    
    
    <category term="From Qzone" scheme="https://wangzitian0.github.io/tags/From-Qzone/"/>
    
  </entry>
  
</feed>
